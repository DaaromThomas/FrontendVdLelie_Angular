{
  "version": 3,
  "sources": ["../../../../../../../packages/router/src/shared.ts", "../../../../../../../packages/router/src/utils/collection.ts", "../../../../../../../packages/router/src/url_tree.ts", "../../../../../../../packages/router/src/create_url_tree.ts", "../../../../../../../packages/router/src/events.ts", "../../../../../../../packages/router/src/router_outlet_context.ts", "../../../../../../../packages/router/src/utils/tree.ts", "../../../../../../../packages/router/src/router_state.ts", "../../../../../../../packages/router/src/directives/router_outlet.ts", "../../../../../../../packages/router/src/create_router_state.ts", "../../../../../../../packages/router/src/navigation_canceling_error.ts", "../../../../../../../packages/router/src/components/empty_outlet.ts", "../../../../../../../packages/router/src/utils/config.ts", "../../../../../../../packages/router/src/operators/activate_routes.ts", "../../../../../../../packages/router/src/utils/preactivation.ts", "../../../../../../../packages/router/src/utils/type_guards.ts", "../../../../../../../packages/router/src/operators/prioritized_guard_value.ts", "../../../../../../../packages/router/src/operators/check_guards.ts", "../../../../../../../packages/router/src/apply_redirects.ts", "../../../../../../../packages/router/src/utils/config_matching.ts", "../../../../../../../packages/router/src/recognize.ts", "../../../../../../../packages/router/src/operators/recognize.ts", "../../../../../../../packages/router/src/operators/resolve_data.ts", "../../../../../../../packages/router/src/operators/switch_tap.ts", "../../../../../../../packages/router/src/page_title_strategy.ts", "../../../../../../../packages/router/src/router_config.ts", "../../../../../../../packages/router/src/router_config_loader.ts", "../../../../../../../packages/router/src/url_handling_strategy.ts", "../../../../../../../packages/router/src/utils/view_transition.ts", "../../../../../../../packages/router/src/navigation_transition.ts", "../../../../../../../packages/router/src/route_reuse_strategy.ts", "../../../../../../../packages/router/src/statemanager/state_manager.ts", "../../../../../../../packages/router/src/utils/navigations.ts", "../../../../../../../packages/router/src/router.ts", "../../../../../../../packages/router/src/directives/router_link.ts", "../../../../../../../packages/router/src/directives/router_link_active.ts", "../../../../../../../packages/router/src/router_preloader.ts", "../../../../../../../packages/router/src/router_scroller.ts", "../../../../../../../packages/router/src/provide_router.ts", "../../../../../../../packages/router/src/router_module.ts", "../../../../../../../packages/router/src/utils/functional_guards.ts", "../../../../../../../packages/router/src/version.ts", "../../../../../../../packages/router/public_api.ts", "../../../../../../../packages/router/index.ts", "../../../../../../../packages/router/router.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Route, UrlMatchResult} from './models';\nimport {UrlSegment, UrlSegmentGroup} from './url_tree';\n\n\n/**\n * The primary routing outlet.\n *\n * @publicApi\n */\nexport const PRIMARY_OUTLET = 'primary';\n\n/**\n * A private symbol used to store the value of `Route.title` inside the `Route.data` if it is a\n * static string or `Route.resolve` if anything else. This allows us to reuse the existing route\n * data/resolvers to support the title feature without new instrumentation in the `Router` pipeline.\n */\nexport const RouteTitleKey = /* @__PURE__ */ Symbol('RouteTitle');\n\n/**\n * A collection of matrix and query URL parameters.\n * @see {@link convertToParamMap}\n * @see {@link ParamMap}\n *\n * @publicApi\n */\nexport type Params = {\n  [key: string]: any;\n};\n\n/**\n * A map that provides access to the required and optional parameters\n * specific to a route.\n * The map supports retrieving a single value with `get()`\n * or multiple values with `getAll()`.\n *\n * @see [URLSearchParams](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams)\n *\n * @publicApi\n */\nexport interface ParamMap {\n  /**\n   * Reports whether the map contains a given parameter.\n   * @param name The parameter name.\n   * @returns True if the map contains the given parameter, false otherwise.\n   */\n  has(name: string): boolean;\n  /**\n   * Retrieves a single value for a parameter.\n   * @param name The parameter name.\n   * @return The parameter's single value,\n   * or the first value if the parameter has multiple values,\n   * or `null` when there is no such parameter.\n   */\n  get(name: string): string|null;\n  /**\n   * Retrieves multiple values for a parameter.\n   * @param name The parameter name.\n   * @return An array containing one or more values,\n   * or an empty array if there is no such parameter.\n   *\n   */\n  getAll(name: string): string[];\n\n  /** Names of the parameters in the map. */\n  readonly keys: string[];\n}\n\nclass ParamsAsMap implements ParamMap {\n  private params: Params;\n\n  constructor(params: Params) {\n    this.params = params || {};\n  }\n\n  has(name: string): boolean {\n    return Object.prototype.hasOwnProperty.call(this.params, name);\n  }\n\n  get(name: string): string|null {\n    if (this.has(name)) {\n      const v = this.params[name];\n      return Array.isArray(v) ? v[0] : v;\n    }\n\n    return null;\n  }\n\n  getAll(name: string): string[] {\n    if (this.has(name)) {\n      const v = this.params[name];\n      return Array.isArray(v) ? v : [v];\n    }\n\n    return [];\n  }\n\n  get keys(): string[] {\n    return Object.keys(this.params);\n  }\n}\n\n/**\n * Converts a `Params` instance to a `ParamMap`.\n * @param params The instance to convert.\n * @returns The new map instance.\n *\n * @publicApi\n */\nexport function convertToParamMap(params: Params): ParamMap {\n  return new ParamsAsMap(params);\n}\n\n/**\n * Matches the route configuration (`route`) against the actual URL (`segments`).\n *\n * When no matcher is defined on a `Route`, this is the matcher used by the Router by default.\n *\n * @param segments The remaining unmatched segments in the current navigation\n * @param segmentGroup The current segment group being matched\n * @param route The `Route` to match against.\n *\n * @see {@link UrlMatchResult}\n * @see {@link Route}\n *\n * @returns The resulting match information or `null` if the `route` should not match.\n * @publicApi\n */\nexport function defaultUrlMatcher(\n    segments: UrlSegment[], segmentGroup: UrlSegmentGroup, route: Route): UrlMatchResult|null {\n  const parts = route.path!.split('/');\n\n  if (parts.length > segments.length) {\n    // The actual URL is shorter than the config, no match\n    return null;\n  }\n\n  if (route.pathMatch === 'full' &&\n      (segmentGroup.hasChildren() || parts.length < segments.length)) {\n    // The config is longer than the actual URL but we are looking for a full match, return null\n    return null;\n  }\n\n  const posParams: {[key: string]: UrlSegment} = {};\n\n  // Check each config part against the actual URL\n  for (let index = 0; index < parts.length; index++) {\n    const part = parts[index];\n    const segment = segments[index];\n    const isParameter = part.startsWith(':');\n    if (isParameter) {\n      posParams[part.substring(1)] = segment;\n    } else if (part !== segment.path) {\n      // The actual URL part does not match the config, no match\n      return null;\n    }\n  }\n\n  return {consumed: segments.slice(0, parts.length), posParams};\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ɵisPromise as isPromise} from '@angular/core';\nimport {from, isObservable, Observable, of} from 'rxjs';\n\nexport function shallowEqualArrays(a: any[], b: any[]): boolean {\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; ++i) {\n    if (!shallowEqual(a[i], b[i])) return false;\n  }\n  return true;\n}\n\nexport function shallowEqual(\n    a: {[key: string|symbol]: any}, b: {[key: string|symbol]: any}): boolean {\n  // While `undefined` should never be possible, it would sometimes be the case in IE 11\n  // and pre-chromium Edge. The check below accounts for this edge case.\n  const k1 = a ? getDataKeys(a) : undefined;\n  const k2 = b ? getDataKeys(b) : undefined;\n  if (!k1 || !k2 || k1.length != k2.length) {\n    return false;\n  }\n  let key: string|symbol;\n  for (let i = 0; i < k1.length; i++) {\n    key = k1[i];\n    if (!equalArraysOrString(a[key], b[key])) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Gets the keys of an object, including `symbol` keys.\n */\nexport function getDataKeys(obj: Object): Array<string|symbol> {\n  return [...Object.keys(obj), ...Object.getOwnPropertySymbols(obj)];\n}\n\n/**\n * Test equality for arrays of strings or a string.\n */\nexport function equalArraysOrString(a: string|string[], b: string|string[]) {\n  if (Array.isArray(a) && Array.isArray(b)) {\n    if (a.length !== b.length) return false;\n    const aSorted = [...a].sort();\n    const bSorted = [...b].sort();\n    return aSorted.every((val, index) => bSorted[index] === val);\n  } else {\n    return a === b;\n  }\n}\n\n/**\n * Return the last element of an array.\n */\nexport function last<T>(a: T[]): T|null {\n  return a.length > 0 ? a[a.length - 1] : null;\n}\n\nexport function wrapIntoObservable<T>(value: T|Promise<T>|Observable<T>): Observable<T> {\n  if (isObservable(value)) {\n    return value;\n  }\n\n  if (isPromise(value)) {\n    // Use `Promise.resolve()` to wrap promise-like instances.\n    // Required ie when a Resolver returns a AngularJS `$q` promise to correctly trigger the\n    // change detection.\n    return from(Promise.resolve(value));\n  }\n\n  return of(value);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injectable, ɵRuntimeError as RuntimeError} from '@angular/core';\n\nimport {RuntimeErrorCode} from './errors';\nimport {convertToParamMap, ParamMap, Params, PRIMARY_OUTLET} from './shared';\nimport {equalArraysOrString, shallowEqual} from './utils/collection';\n\n\n/**\n * A set of options which specify how to determine if a `UrlTree` is active, given the `UrlTree`\n * for the current router state.\n *\n * @publicApi\n * @see {@link Router#isActive}\n */\nexport interface IsActiveMatchOptions {\n  /**\n   * Defines the strategy for comparing the matrix parameters of two `UrlTree`s.\n   *\n   * The matrix parameter matching is dependent on the strategy for matching the\n   * segments. That is, if the `paths` option is set to `'subset'`, only\n   * the matrix parameters of the matching segments will be compared.\n   *\n   * - `'exact'`: Requires that matching segments also have exact matrix parameter\n   * matches.\n   * - `'subset'`: The matching segments in the router's active `UrlTree` may contain\n   * extra matrix parameters, but those that exist in the `UrlTree` in question must match.\n   * - `'ignored'`: When comparing `UrlTree`s, matrix params will be ignored.\n   */\n  matrixParams: 'exact'|'subset'|'ignored';\n  /**\n   * Defines the strategy for comparing the query parameters of two `UrlTree`s.\n   *\n   * - `'exact'`: the query parameters must match exactly.\n   * - `'subset'`: the active `UrlTree` may contain extra parameters,\n   * but must match the key and value of any that exist in the `UrlTree` in question.\n   * - `'ignored'`: When comparing `UrlTree`s, query params will be ignored.\n   */\n  queryParams: 'exact'|'subset'|'ignored';\n  /**\n   * Defines the strategy for comparing the `UrlSegment`s of the `UrlTree`s.\n   *\n   * - `'exact'`: all segments in each `UrlTree` must match.\n   * - `'subset'`: a `UrlTree` will be determined to be active if it\n   * is a subtree of the active route. That is, the active route may contain extra\n   * segments, but must at least have all the segments of the `UrlTree` in question.\n   */\n  paths: 'exact'|'subset';\n  /**\n   * - `'exact'`: indicates that the `UrlTree` fragments must be equal.\n   * - `'ignored'`: the fragments will not be compared when determining if a\n   * `UrlTree` is active.\n   */\n  fragment: 'exact'|'ignored';\n}\n\ntype ParamMatchOptions = 'exact'|'subset'|'ignored';\n\ntype PathCompareFn =\n    (container: UrlSegmentGroup, containee: UrlSegmentGroup, matrixParams: ParamMatchOptions) =>\n        boolean;\ntype ParamCompareFn = (container: Params, containee: Params) => boolean;\n\nconst pathCompareMap: Record<IsActiveMatchOptions['paths'], PathCompareFn> = {\n  'exact': equalSegmentGroups,\n  'subset': containsSegmentGroup,\n};\nconst paramCompareMap: Record<ParamMatchOptions, ParamCompareFn> = {\n  'exact': equalParams,\n  'subset': containsParams,\n  'ignored': () => true,\n};\n\nexport function containsTree(\n    container: UrlTree, containee: UrlTree, options: IsActiveMatchOptions): boolean {\n  return pathCompareMap[options.paths](container.root, containee.root, options.matrixParams) &&\n      paramCompareMap[options.queryParams](container.queryParams, containee.queryParams) &&\n      !(options.fragment === 'exact' && container.fragment !== containee.fragment);\n}\n\nfunction equalParams(container: Params, containee: Params): boolean {\n  // TODO: This does not handle array params correctly.\n  return shallowEqual(container, containee);\n}\n\nfunction equalSegmentGroups(\n    container: UrlSegmentGroup, containee: UrlSegmentGroup,\n    matrixParams: ParamMatchOptions): boolean {\n  if (!equalPath(container.segments, containee.segments)) return false;\n  if (!matrixParamsMatch(container.segments, containee.segments, matrixParams)) {\n    return false;\n  }\n  if (container.numberOfChildren !== containee.numberOfChildren) return false;\n  for (const c in containee.children) {\n    if (!container.children[c]) return false;\n    if (!equalSegmentGroups(container.children[c], containee.children[c], matrixParams))\n      return false;\n  }\n  return true;\n}\n\nfunction containsParams(container: Params, containee: Params): boolean {\n  return Object.keys(containee).length <= Object.keys(container).length &&\n      Object.keys(containee).every(key => equalArraysOrString(container[key], containee[key]));\n}\n\nfunction containsSegmentGroup(\n    container: UrlSegmentGroup, containee: UrlSegmentGroup,\n    matrixParams: ParamMatchOptions): boolean {\n  return containsSegmentGroupHelper(container, containee, containee.segments, matrixParams);\n}\n\nfunction containsSegmentGroupHelper(\n    container: UrlSegmentGroup, containee: UrlSegmentGroup, containeePaths: UrlSegment[],\n    matrixParams: ParamMatchOptions): boolean {\n  if (container.segments.length > containeePaths.length) {\n    const current = container.segments.slice(0, containeePaths.length);\n    if (!equalPath(current, containeePaths)) return false;\n    if (containee.hasChildren()) return false;\n    if (!matrixParamsMatch(current, containeePaths, matrixParams)) return false;\n    return true;\n\n  } else if (container.segments.length === containeePaths.length) {\n    if (!equalPath(container.segments, containeePaths)) return false;\n    if (!matrixParamsMatch(container.segments, containeePaths, matrixParams)) return false;\n    for (const c in containee.children) {\n      if (!container.children[c]) return false;\n      if (!containsSegmentGroup(container.children[c], containee.children[c], matrixParams)) {\n        return false;\n      }\n    }\n    return true;\n\n  } else {\n    const current = containeePaths.slice(0, container.segments.length);\n    const next = containeePaths.slice(container.segments.length);\n    if (!equalPath(container.segments, current)) return false;\n    if (!matrixParamsMatch(container.segments, current, matrixParams)) return false;\n    if (!container.children[PRIMARY_OUTLET]) return false;\n    return containsSegmentGroupHelper(\n        container.children[PRIMARY_OUTLET], containee, next, matrixParams);\n  }\n}\n\nfunction matrixParamsMatch(\n    containerPaths: UrlSegment[], containeePaths: UrlSegment[], options: ParamMatchOptions) {\n  return containeePaths.every((containeeSegment, i) => {\n    return paramCompareMap[options](containerPaths[i].parameters, containeeSegment.parameters);\n  });\n}\n\n/**\n * @description\n *\n * Represents the parsed URL.\n *\n * Since a router state is a tree, and the URL is nothing but a serialized state, the URL is a\n * serialized tree.\n * UrlTree is a data structure that provides a lot of affordances in dealing with URLs\n *\n * @usageNotes\n * ### Example\n *\n * ```\n * @Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const tree: UrlTree =\n *       router.parseUrl('/team/33/(user/victor//support:help)?debug=true#fragment');\n *     const f = tree.fragment; // return 'fragment'\n *     const q = tree.queryParams; // returns {debug: 'true'}\n *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];\n *     const s: UrlSegment[] = g.segments; // returns 2 segments 'team' and '33'\n *     g.children[PRIMARY_OUTLET].segments; // returns 2 segments 'user' and 'victor'\n *     g.children['support'].segments; // return 1 segment 'help'\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nexport class UrlTree {\n  /** @internal */\n  _queryParamMap?: ParamMap;\n\n  constructor(\n      /** The root segment group of the URL tree */\n      public root: UrlSegmentGroup = new UrlSegmentGroup([], {}),\n      /** The query params of the URL */\n      public queryParams: Params = {},\n      /** The fragment of the URL */\n      public fragment: string|null = null) {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      if (root.segments.length > 0) {\n        throw new RuntimeError(\n            RuntimeErrorCode.INVALID_ROOT_URL_SEGMENT,\n            'The root `UrlSegmentGroup` should not contain `segments`. ' +\n                'Instead, these segments belong in the `children` so they can be associated with a named outlet.');\n      }\n    }\n  }\n\n  get queryParamMap(): ParamMap {\n    if (!this._queryParamMap) {\n      this._queryParamMap = convertToParamMap(this.queryParams);\n    }\n    return this._queryParamMap;\n  }\n\n  /** @docsNotRequired */\n  toString(): string {\n    return DEFAULT_SERIALIZER.serialize(this);\n  }\n}\n\n/**\n * @description\n *\n * Represents the parsed URL segment group.\n *\n * See `UrlTree` for more information.\n *\n * @publicApi\n */\nexport class UrlSegmentGroup {\n  /** The parent node in the url tree */\n  parent: UrlSegmentGroup|null = null;\n\n  constructor(\n      /** The URL segments of this group. See `UrlSegment` for more information */\n      public segments: UrlSegment[],\n      /** The list of children of this group */\n      public children: {[key: string]: UrlSegmentGroup}) {\n    Object.values(children).forEach((v) => (v.parent = this));\n  }\n\n  /** Whether the segment has child segments */\n  hasChildren(): boolean {\n    return this.numberOfChildren > 0;\n  }\n\n  /** Number of child segments */\n  get numberOfChildren(): number {\n    return Object.keys(this.children).length;\n  }\n\n  /** @docsNotRequired */\n  toString(): string {\n    return serializePaths(this);\n  }\n}\n\n\n/**\n * @description\n *\n * Represents a single URL segment.\n *\n * A UrlSegment is a part of a URL between the two slashes. It contains a path and the matrix\n * parameters associated with the segment.\n *\n * @usageNotes\n * ### Example\n *\n * ```\n * @Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const tree: UrlTree = router.parseUrl('/team;id=33');\n *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];\n *     const s: UrlSegment[] = g.segments;\n *     s[0].path; // returns 'team'\n *     s[0].parameters; // returns {id: 33}\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nexport class UrlSegment {\n  /** @internal */\n  _parameterMap?: ParamMap;\n\n  constructor(\n      /** The path part of a URL segment */\n      public path: string,\n\n      /** The matrix parameters associated with a segment */\n      public parameters: {[name: string]: string}) {}\n\n  get parameterMap(): ParamMap {\n    if (!this._parameterMap) {\n      this._parameterMap = convertToParamMap(this.parameters);\n    }\n    return this._parameterMap;\n  }\n\n  /** @docsNotRequired */\n  toString(): string {\n    return serializePath(this);\n  }\n}\n\nexport function equalSegments(as: UrlSegment[], bs: UrlSegment[]): boolean {\n  return equalPath(as, bs) && as.every((a, i) => shallowEqual(a.parameters, bs[i].parameters));\n}\n\nexport function equalPath(as: UrlSegment[], bs: UrlSegment[]): boolean {\n  if (as.length !== bs.length) return false;\n  return as.every((a, i) => a.path === bs[i].path);\n}\n\nexport function mapChildrenIntoArray<T>(\n    segment: UrlSegmentGroup, fn: (v: UrlSegmentGroup, k: string) => T[]): T[] {\n  let res: T[] = [];\n  Object.entries(segment.children).forEach(([childOutlet, child]) => {\n    if (childOutlet === PRIMARY_OUTLET) {\n      res = res.concat(fn(child, childOutlet));\n    }\n  });\n  Object.entries(segment.children).forEach(([childOutlet, child]) => {\n    if (childOutlet !== PRIMARY_OUTLET) {\n      res = res.concat(fn(child, childOutlet));\n    }\n  });\n  return res;\n}\n\n\n/**\n * @description\n *\n * Serializes and deserializes a URL string into a URL tree.\n *\n * The url serialization strategy is customizable. You can\n * make all URLs case insensitive by providing a custom UrlSerializer.\n *\n * See `DefaultUrlSerializer` for an example of a URL serializer.\n *\n * @publicApi\n */\n@Injectable({providedIn: 'root', useFactory: () => new DefaultUrlSerializer()})\nexport abstract class UrlSerializer {\n  /** Parse a url into a `UrlTree` */\n  abstract parse(url: string): UrlTree;\n\n  /** Converts a `UrlTree` into a url */\n  abstract serialize(tree: UrlTree): string;\n}\n\n/**\n * @description\n *\n * A default implementation of the `UrlSerializer`.\n *\n * Example URLs:\n *\n * ```\n * /inbox/33(popup:compose)\n * /inbox/33;open=true/messages/44\n * ```\n *\n * DefaultUrlSerializer uses parentheses to serialize secondary segments (e.g., popup:compose), the\n * colon syntax to specify the outlet, and the ';parameter=value' syntax (e.g., open=true) to\n * specify route specific parameters.\n *\n * @publicApi\n */\nexport class DefaultUrlSerializer implements UrlSerializer {\n  /** Parses a url into a `UrlTree` */\n  parse(url: string): UrlTree {\n    const p = new UrlParser(url);\n    return new UrlTree(p.parseRootSegment(), p.parseQueryParams(), p.parseFragment());\n  }\n\n  /** Converts a `UrlTree` into a url */\n  serialize(tree: UrlTree): string {\n    const segment = `/${serializeSegment(tree.root, true)}`;\n    const query = serializeQueryParams(tree.queryParams);\n    const fragment =\n        typeof tree.fragment === `string` ? `#${encodeUriFragment(tree.fragment)}` : '';\n\n    return `${segment}${query}${fragment}`;\n  }\n}\n\nconst DEFAULT_SERIALIZER = new DefaultUrlSerializer();\n\nexport function serializePaths(segment: UrlSegmentGroup): string {\n  return segment.segments.map(p => serializePath(p)).join('/');\n}\n\nfunction serializeSegment(segment: UrlSegmentGroup, root: boolean): string {\n  if (!segment.hasChildren()) {\n    return serializePaths(segment);\n  }\n\n  if (root) {\n    const primary = segment.children[PRIMARY_OUTLET] ?\n        serializeSegment(segment.children[PRIMARY_OUTLET], false) :\n        '';\n    const children: string[] = [];\n\n    Object.entries(segment.children).forEach(([k, v]) => {\n      if (k !== PRIMARY_OUTLET) {\n        children.push(`${k}:${serializeSegment(v, false)}`);\n      }\n    });\n\n    return children.length > 0 ? `${primary}(${children.join('//')})` : primary;\n\n  } else {\n    const children = mapChildrenIntoArray(segment, (v: UrlSegmentGroup, k: string) => {\n      if (k === PRIMARY_OUTLET) {\n        return [serializeSegment(segment.children[PRIMARY_OUTLET], false)];\n      }\n\n      return [`${k}:${serializeSegment(v, false)}`];\n    });\n\n    // use no parenthesis if the only child is a primary outlet route\n    if (Object.keys(segment.children).length === 1 && segment.children[PRIMARY_OUTLET] != null) {\n      return `${serializePaths(segment)}/${children[0]}`;\n    }\n\n    return `${serializePaths(segment)}/(${children.join('//')})`;\n  }\n}\n\n/**\n * Encodes a URI string with the default encoding. This function will only ever be called from\n * `encodeUriQuery` or `encodeUriSegment` as it's the base set of encodings to be used. We need\n * a custom encoding because encodeURIComponent is too aggressive and encodes stuff that doesn't\n * have to be encoded per https://url.spec.whatwg.org.\n */\nfunction encodeUriString(s: string): string {\n  return encodeURIComponent(s)\n      .replace(/%40/g, '@')\n      .replace(/%3A/gi, ':')\n      .replace(/%24/g, '$')\n      .replace(/%2C/gi, ',');\n}\n\n/**\n * This function should be used to encode both keys and values in a query string key/value. In\n * the following URL, you need to call encodeUriQuery on \"k\" and \"v\":\n *\n * http://www.site.org/html;mk=mv?k=v#f\n */\nexport function encodeUriQuery(s: string): string {\n  return encodeUriString(s).replace(/%3B/gi, ';');\n}\n\n/**\n * This function should be used to encode a URL fragment. In the following URL, you need to call\n * encodeUriFragment on \"f\":\n *\n * http://www.site.org/html;mk=mv?k=v#f\n */\nexport function encodeUriFragment(s: string): string {\n  return encodeURI(s);\n}\n\n/**\n * This function should be run on any URI segment as well as the key and value in a key/value\n * pair for matrix params. In the following URL, you need to call encodeUriSegment on \"html\",\n * \"mk\", and \"mv\":\n *\n * http://www.site.org/html;mk=mv?k=v#f\n */\nexport function encodeUriSegment(s: string): string {\n  return encodeUriString(s).replace(/\\(/g, '%28').replace(/\\)/g, '%29').replace(/%26/gi, '&');\n}\n\nexport function decode(s: string): string {\n  return decodeURIComponent(s);\n}\n\n// Query keys/values should have the \"+\" replaced first, as \"+\" in a query string is \" \".\n// decodeURIComponent function will not decode \"+\" as a space.\nexport function decodeQuery(s: string): string {\n  return decode(s.replace(/\\+/g, '%20'));\n}\n\nexport function serializePath(path: UrlSegment): string {\n  return `${encodeUriSegment(path.path)}${serializeMatrixParams(path.parameters)}`;\n}\n\nfunction serializeMatrixParams(params: {[key: string]: string}): string {\n  return Object.keys(params)\n      .map(key => `;${encodeUriSegment(key)}=${encodeUriSegment(params[key])}`)\n      .join('');\n}\n\nfunction serializeQueryParams(params: {[key: string]: any}): string {\n  const strParams: string[] =\n      Object.keys(params)\n          .map((name) => {\n            const value = params[name];\n            return Array.isArray(value) ?\n                value.map(v => `${encodeUriQuery(name)}=${encodeUriQuery(v)}`).join('&') :\n                `${encodeUriQuery(name)}=${encodeUriQuery(value)}`;\n          })\n          .filter(s => !!s);\n\n  return strParams.length ? `?${strParams.join('&')}` : '';\n}\n\nconst SEGMENT_RE = /^[^\\/()?;#]+/;\nfunction matchSegments(str: string): string {\n  const match = str.match(SEGMENT_RE);\n  return match ? match[0] : '';\n}\n\nconst MATRIX_PARAM_SEGMENT_RE = /^[^\\/()?;=#]+/;\nfunction matchMatrixKeySegments(str: string): string {\n  const match = str.match(MATRIX_PARAM_SEGMENT_RE);\n  return match ? match[0] : '';\n}\n\nconst QUERY_PARAM_RE = /^[^=?&#]+/;\n// Return the name of the query param at the start of the string or an empty string\nfunction matchQueryParams(str: string): string {\n  const match = str.match(QUERY_PARAM_RE);\n  return match ? match[0] : '';\n}\n\nconst QUERY_PARAM_VALUE_RE = /^[^&#]+/;\n// Return the value of the query param at the start of the string or an empty string\nfunction matchUrlQueryParamValue(str: string): string {\n  const match = str.match(QUERY_PARAM_VALUE_RE);\n  return match ? match[0] : '';\n}\n\nclass UrlParser {\n  private remaining: string;\n\n  constructor(private url: string) {\n    this.remaining = url;\n  }\n\n  parseRootSegment(): UrlSegmentGroup {\n    this.consumeOptional('/');\n\n    if (this.remaining === '' || this.peekStartsWith('?') || this.peekStartsWith('#')) {\n      return new UrlSegmentGroup([], {});\n    }\n\n    // The root segment group never has segments\n    return new UrlSegmentGroup([], this.parseChildren());\n  }\n\n  parseQueryParams(): Params {\n    const params: Params = {};\n    if (this.consumeOptional('?')) {\n      do {\n        this.parseQueryParam(params);\n      } while (this.consumeOptional('&'));\n    }\n    return params;\n  }\n\n  parseFragment(): string|null {\n    return this.consumeOptional('#') ? decodeURIComponent(this.remaining) : null;\n  }\n\n  private parseChildren(): {[outlet: string]: UrlSegmentGroup} {\n    if (this.remaining === '') {\n      return {};\n    }\n\n    this.consumeOptional('/');\n\n    const segments: UrlSegment[] = [];\n    if (!this.peekStartsWith('(')) {\n      segments.push(this.parseSegment());\n    }\n\n    while (this.peekStartsWith('/') && !this.peekStartsWith('//') && !this.peekStartsWith('/(')) {\n      this.capture('/');\n      segments.push(this.parseSegment());\n    }\n\n    let children: {[outlet: string]: UrlSegmentGroup} = {};\n    if (this.peekStartsWith('/(')) {\n      this.capture('/');\n      children = this.parseParens(true);\n    }\n\n    let res: {[outlet: string]: UrlSegmentGroup} = {};\n    if (this.peekStartsWith('(')) {\n      res = this.parseParens(false);\n    }\n\n    if (segments.length > 0 || Object.keys(children).length > 0) {\n      res[PRIMARY_OUTLET] = new UrlSegmentGroup(segments, children);\n    }\n\n    return res;\n  }\n\n  // parse a segment with its matrix parameters\n  // ie `name;k1=v1;k2`\n  private parseSegment(): UrlSegment {\n    const path = matchSegments(this.remaining);\n    if (path === '' && this.peekStartsWith(';')) {\n      throw new RuntimeError(\n          RuntimeErrorCode.EMPTY_PATH_WITH_PARAMS,\n          (typeof ngDevMode === 'undefined' || ngDevMode) &&\n              `Empty path url segment cannot have parameters: '${this.remaining}'.`);\n    }\n\n    this.capture(path);\n    return new UrlSegment(decode(path), this.parseMatrixParams());\n  }\n\n  private parseMatrixParams(): {[key: string]: string} {\n    const params: {[key: string]: string} = {};\n    while (this.consumeOptional(';')) {\n      this.parseParam(params);\n    }\n    return params;\n  }\n\n  private parseParam(params: {[key: string]: string}): void {\n    const key = matchMatrixKeySegments(this.remaining);\n    if (!key) {\n      return;\n    }\n    this.capture(key);\n    let value: any = '';\n    if (this.consumeOptional('=')) {\n      const valueMatch = matchSegments(this.remaining);\n      if (valueMatch) {\n        value = valueMatch;\n        this.capture(value);\n      }\n    }\n\n    params[decode(key)] = decode(value);\n  }\n\n  // Parse a single query parameter `name[=value]`\n  private parseQueryParam(params: Params): void {\n    const key = matchQueryParams(this.remaining);\n    if (!key) {\n      return;\n    }\n    this.capture(key);\n    let value: any = '';\n    if (this.consumeOptional('=')) {\n      const valueMatch = matchUrlQueryParamValue(this.remaining);\n      if (valueMatch) {\n        value = valueMatch;\n        this.capture(value);\n      }\n    }\n\n    const decodedKey = decodeQuery(key);\n    const decodedVal = decodeQuery(value);\n\n    if (params.hasOwnProperty(decodedKey)) {\n      // Append to existing values\n      let currentVal = params[decodedKey];\n      if (!Array.isArray(currentVal)) {\n        currentVal = [currentVal];\n        params[decodedKey] = currentVal;\n      }\n      currentVal.push(decodedVal);\n    } else {\n      // Create a new value\n      params[decodedKey] = decodedVal;\n    }\n  }\n\n  // parse `(a/b//outlet_name:c/d)`\n  private parseParens(allowPrimary: boolean): {[outlet: string]: UrlSegmentGroup} {\n    const segments: {[key: string]: UrlSegmentGroup} = {};\n    this.capture('(');\n\n    while (!this.consumeOptional(')') && this.remaining.length > 0) {\n      const path = matchSegments(this.remaining);\n\n      const next = this.remaining[path.length];\n\n      // if is is not one of these characters, then the segment was unescaped\n      // or the group was not closed\n      if (next !== '/' && next !== ')' && next !== ';') {\n        throw new RuntimeError(\n            RuntimeErrorCode.UNPARSABLE_URL,\n            (typeof ngDevMode === 'undefined' || ngDevMode) && `Cannot parse url '${this.url}'`);\n      }\n\n      let outletName: string = undefined!;\n      if (path.indexOf(':') > -1) {\n        outletName = path.slice(0, path.indexOf(':'));\n        this.capture(outletName);\n        this.capture(':');\n      } else if (allowPrimary) {\n        outletName = PRIMARY_OUTLET;\n      }\n\n      const children = this.parseChildren();\n      segments[outletName] = Object.keys(children).length === 1 ? children[PRIMARY_OUTLET] :\n                                                                  new UrlSegmentGroup([], children);\n      this.consumeOptional('//');\n    }\n\n    return segments;\n  }\n\n  private peekStartsWith(str: string): boolean {\n    return this.remaining.startsWith(str);\n  }\n\n  // Consumes the prefix when it is present and returns whether it has been consumed\n  private consumeOptional(str: string): boolean {\n    if (this.peekStartsWith(str)) {\n      this.remaining = this.remaining.substring(str.length);\n      return true;\n    }\n    return false;\n  }\n\n  private capture(str: string): void {\n    if (!this.consumeOptional(str)) {\n      throw new RuntimeError(\n          RuntimeErrorCode.UNEXPECTED_VALUE_IN_URL,\n          (typeof ngDevMode === 'undefined' || ngDevMode) && `Expected \"${str}\".`);\n    }\n  }\n}\n\nexport function createRoot(rootCandidate: UrlSegmentGroup) {\n  return rootCandidate.segments.length > 0 ?\n      new UrlSegmentGroup([], {[PRIMARY_OUTLET]: rootCandidate}) :\n      rootCandidate;\n}\n\n/**\n * Recursively\n * - merges primary segment children into their parents\n * - drops empty children (those which have no segments and no children themselves). This latter\n * prevents serializing a group into something like `/a(aux:)`, where `aux` is an empty child\n * segment.\n * - merges named outlets without a primary segment sibling into the children. This prevents\n * serializing a URL like `//(a:a)(b:b) instead of `/(a:a//b:b)` when the aux b route lives on the\n * root but the `a` route lives under an empty path primary route.\n */\nexport function squashSegmentGroup(segmentGroup: UrlSegmentGroup): UrlSegmentGroup {\n  const newChildren: Record<string, UrlSegmentGroup> = {};\n  for (const childOutlet of Object.keys(segmentGroup.children)) {\n    const child = segmentGroup.children[childOutlet];\n    const childCandidate = squashSegmentGroup(child);\n    // moves named children in an empty path primary child into this group\n    if (childOutlet === PRIMARY_OUTLET && childCandidate.segments.length === 0 &&\n        childCandidate.hasChildren()) {\n      for (const [grandChildOutlet, grandChild] of Object.entries(childCandidate.children)) {\n        newChildren[grandChildOutlet] = grandChild;\n      }\n    }  // don't add empty children\n    else if (childCandidate.segments.length > 0 || childCandidate.hasChildren()) {\n      newChildren[childOutlet] = childCandidate;\n    }\n  }\n  const s = new UrlSegmentGroup(segmentGroup.segments, newChildren);\n  return mergeTrivialChildren(s);\n}\n\n/**\n * When possible, merges the primary outlet child into the parent `UrlSegmentGroup`.\n *\n * When a segment group has only one child which is a primary outlet, merges that child into the\n * parent. That is, the child segment group's segments are merged into the `s` and the child's\n * children become the children of `s`. Think of this like a 'squash', merging the child segment\n * group into the parent.\n */\nfunction mergeTrivialChildren(s: UrlSegmentGroup): UrlSegmentGroup {\n  if (s.numberOfChildren === 1 && s.children[PRIMARY_OUTLET]) {\n    const c = s.children[PRIMARY_OUTLET];\n    return new UrlSegmentGroup(s.segments.concat(c.segments), c.children);\n  }\n\n  return s;\n}\n\nexport function isUrlTree(v: any): v is UrlTree {\n  return v instanceof UrlTree;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ɵRuntimeError as RuntimeError} from '@angular/core';\n\nimport {RuntimeErrorCode} from './errors';\nimport {ActivatedRouteSnapshot} from './router_state';\nimport {Params, PRIMARY_OUTLET} from './shared';\nimport {createRoot, squashSegmentGroup, UrlSegment, UrlSegmentGroup, UrlTree} from './url_tree';\nimport {last, shallowEqual} from './utils/collection';\n\n\n/**\n * Creates a `UrlTree` relative to an `ActivatedRouteSnapshot`.\n *\n * @publicApi\n *\n *\n * @param relativeTo The `ActivatedRouteSnapshot` to apply the commands to\n * @param commands An array of URL fragments with which to construct the new URL tree.\n * If the path is static, can be the literal URL string. For a dynamic path, pass an array of path\n * segments, followed by the parameters for each segment.\n * The fragments are applied to the one provided in the `relativeTo` parameter.\n * @param queryParams The query parameters for the `UrlTree`. `null` if the `UrlTree` does not have\n *     any query parameters.\n * @param fragment The fragment for the `UrlTree`. `null` if the `UrlTree` does not have a fragment.\n *\n * @usageNotes\n *\n * ```\n * // create /team/33/user/11\n * createUrlTreeFromSnapshot(snapshot, ['/team', 33, 'user', 11]);\n *\n * // create /team/33;expand=true/user/11\n * createUrlTreeFromSnapshot(snapshot, ['/team', 33, {expand: true}, 'user', 11]);\n *\n * // you can collapse static segments like this (this works only with the first passed-in value):\n * createUrlTreeFromSnapshot(snapshot, ['/team/33/user', userId]);\n *\n * // If the first segment can contain slashes, and you do not want the router to split it,\n * // you can do the following:\n * createUrlTreeFromSnapshot(snapshot, [{segmentPath: '/one/two'}]);\n *\n * // create /team/33/(user/11//right:chat)\n * createUrlTreeFromSnapshot(snapshot, ['/team', 33, {outlets: {primary: 'user/11', right:\n * 'chat'}}], null, null);\n *\n * // remove the right secondary node\n * createUrlTreeFromSnapshot(snapshot, ['/team', 33, {outlets: {primary: 'user/11', right: null}}]);\n *\n * // For the examples below, assume the current URL is for the `/team/33/user/11` and the\n * `ActivatedRouteSnapshot` points to `user/11`:\n *\n * // navigate to /team/33/user/11/details\n * createUrlTreeFromSnapshot(snapshot, ['details']);\n *\n * // navigate to /team/33/user/22\n * createUrlTreeFromSnapshot(snapshot, ['../22']);\n *\n * // navigate to /team/44/user/22\n * createUrlTreeFromSnapshot(snapshot, ['../../team/44/user/22']);\n * ```\n */\nexport function createUrlTreeFromSnapshot(\n    relativeTo: ActivatedRouteSnapshot, commands: any[], queryParams: Params|null = null,\n    fragment: string|null = null): UrlTree {\n  const relativeToUrlSegmentGroup = createSegmentGroupFromRoute(relativeTo);\n  return createUrlTreeFromSegmentGroup(relativeToUrlSegmentGroup, commands, queryParams, fragment);\n}\n\nexport function createSegmentGroupFromRoute(route: ActivatedRouteSnapshot): UrlSegmentGroup {\n  let targetGroup: UrlSegmentGroup|undefined;\n\n  function createSegmentGroupFromRouteRecursive(currentRoute: ActivatedRouteSnapshot):\n      UrlSegmentGroup {\n    const childOutlets: {[outlet: string]: UrlSegmentGroup} = {};\n    for (const childSnapshot of currentRoute.children) {\n      const root = createSegmentGroupFromRouteRecursive(childSnapshot);\n      childOutlets[childSnapshot.outlet] = root;\n    }\n    const segmentGroup = new UrlSegmentGroup(currentRoute.url, childOutlets);\n    if (currentRoute === route) {\n      targetGroup = segmentGroup;\n    }\n    return segmentGroup;\n  }\n  const rootCandidate = createSegmentGroupFromRouteRecursive(route.root);\n  const rootSegmentGroup = createRoot(rootCandidate);\n\n  return targetGroup ?? rootSegmentGroup;\n}\n\nexport function createUrlTreeFromSegmentGroup(\n    relativeTo: UrlSegmentGroup, commands: any[], queryParams: Params|null,\n    fragment: string|null): UrlTree {\n  let root = relativeTo;\n  while (root.parent) {\n    root = root.parent;\n  }\n  // There are no commands so the `UrlTree` goes to the same path as the one created from the\n  // `UrlSegmentGroup`. All we need to do is update the `queryParams` and `fragment` without\n  // applying any other logic.\n  if (commands.length === 0) {\n    return tree(root, root, root, queryParams, fragment);\n  }\n\n  const nav = computeNavigation(commands);\n\n  if (nav.toRoot()) {\n    return tree(root, root, new UrlSegmentGroup([], {}), queryParams, fragment);\n  }\n\n  const position = findStartingPositionForTargetGroup(nav, root, relativeTo);\n  const newSegmentGroup = position.processChildren ?\n      updateSegmentGroupChildren(position.segmentGroup, position.index, nav.commands) :\n      updateSegmentGroup(position.segmentGroup, position.index, nav.commands);\n  return tree(root, position.segmentGroup, newSegmentGroup, queryParams, fragment);\n}\n\nfunction isMatrixParams(command: any): boolean {\n  return typeof command === 'object' && command != null && !command.outlets && !command.segmentPath;\n}\n\n/**\n * Determines if a given command has an `outlets` map. When we encounter a command\n * with an outlets k/v map, we need to apply each outlet individually to the existing segment.\n */\nfunction isCommandWithOutlets(command: any): command is {outlets: {[key: string]: any}} {\n  return typeof command === 'object' && command != null && command.outlets;\n}\n\nfunction tree(\n    oldRoot: UrlSegmentGroup, oldSegmentGroup: UrlSegmentGroup, newSegmentGroup: UrlSegmentGroup,\n    queryParams: Params|null, fragment: string|null): UrlTree {\n  let qp: any = {};\n  if (queryParams) {\n    Object.entries(queryParams).forEach(([name, value]) => {\n      qp[name] = Array.isArray(value) ? value.map((v: any) => `${v}`) : `${value}`;\n    });\n  }\n\n  let rootCandidate: UrlSegmentGroup;\n  if (oldRoot === oldSegmentGroup) {\n    rootCandidate = newSegmentGroup;\n  } else {\n    rootCandidate = replaceSegment(oldRoot, oldSegmentGroup, newSegmentGroup);\n  }\n\n  const newRoot = createRoot(squashSegmentGroup(rootCandidate));\n  return new UrlTree(newRoot, qp, fragment);\n}\n\n/**\n * Replaces the `oldSegment` which is located in some child of the `current` with the `newSegment`.\n * This also has the effect of creating new `UrlSegmentGroup` copies to update references. This\n * shouldn't be necessary but the fallback logic for an invalid ActivatedRoute in the creation uses\n * the Router's current url tree. If we don't create new segment groups, we end up modifying that\n * value.\n */\nfunction replaceSegment(\n    current: UrlSegmentGroup, oldSegment: UrlSegmentGroup,\n    newSegment: UrlSegmentGroup): UrlSegmentGroup {\n  const children: {[key: string]: UrlSegmentGroup} = {};\n  Object.entries(current.children).forEach(([outletName, c]) => {\n    if (c === oldSegment) {\n      children[outletName] = newSegment;\n    } else {\n      children[outletName] = replaceSegment(c, oldSegment, newSegment);\n    }\n  });\n  return new UrlSegmentGroup(current.segments, children);\n}\n\nclass Navigation {\n  constructor(\n      public isAbsolute: boolean, public numberOfDoubleDots: number, public commands: any[]) {\n    if (isAbsolute && commands.length > 0 && isMatrixParams(commands[0])) {\n      throw new RuntimeError(\n          RuntimeErrorCode.ROOT_SEGMENT_MATRIX_PARAMS,\n          (typeof ngDevMode === 'undefined' || ngDevMode) &&\n              'Root segment cannot have matrix parameters');\n    }\n\n    const cmdWithOutlet = commands.find(isCommandWithOutlets);\n    if (cmdWithOutlet && cmdWithOutlet !== last(commands)) {\n      throw new RuntimeError(\n          RuntimeErrorCode.MISPLACED_OUTLETS_COMMAND,\n          (typeof ngDevMode === 'undefined' || ngDevMode) &&\n              '{outlets:{}} has to be the last command');\n    }\n  }\n\n  public toRoot(): boolean {\n    return this.isAbsolute && this.commands.length === 1 && this.commands[0] == '/';\n  }\n}\n\n/** Transforms commands to a normalized `Navigation` */\nfunction computeNavigation(commands: any[]): Navigation {\n  if ((typeof commands[0] === 'string') && commands.length === 1 && commands[0] === '/') {\n    return new Navigation(true, 0, commands);\n  }\n\n  let numberOfDoubleDots = 0;\n  let isAbsolute = false;\n\n  const res: any[] = commands.reduce((res, cmd, cmdIdx) => {\n    if (typeof cmd === 'object' && cmd != null) {\n      if (cmd.outlets) {\n        const outlets: {[k: string]: any} = {};\n        Object.entries(cmd.outlets).forEach(([name, commands]) => {\n          outlets[name] = typeof commands === 'string' ? commands.split('/') : commands;\n        });\n        return [...res, {outlets}];\n      }\n\n      if (cmd.segmentPath) {\n        return [...res, cmd.segmentPath];\n      }\n    }\n\n    if (!(typeof cmd === 'string')) {\n      return [...res, cmd];\n    }\n\n    if (cmdIdx === 0) {\n      cmd.split('/').forEach((urlPart, partIndex) => {\n        if (partIndex == 0 && urlPart === '.') {\n          // skip './a'\n        } else if (partIndex == 0 && urlPart === '') {  //  '/a'\n          isAbsolute = true;\n        } else if (urlPart === '..') {  //  '../a'\n          numberOfDoubleDots++;\n        } else if (urlPart != '') {\n          res.push(urlPart);\n        }\n      });\n\n      return res;\n    }\n\n    return [...res, cmd];\n  }, []);\n\n  return new Navigation(isAbsolute, numberOfDoubleDots, res);\n}\n\nclass Position {\n  constructor(\n      public segmentGroup: UrlSegmentGroup, public processChildren: boolean, public index: number) {\n  }\n}\n\nfunction findStartingPositionForTargetGroup(\n    nav: Navigation, root: UrlSegmentGroup, target: UrlSegmentGroup): Position {\n  if (nav.isAbsolute) {\n    return new Position(root, true, 0);\n  }\n\n  if (!target) {\n    // `NaN` is used only to maintain backwards compatibility with incorrectly mocked\n    // `ActivatedRouteSnapshot` in tests. In prior versions of this code, the position here was\n    // determined based on an internal property that was rarely mocked, resulting in `NaN`. In\n    // reality, this code path should _never_ be touched since `target` is not allowed to be falsey.\n    return new Position(root, false, NaN);\n  }\n  if (target.parent === null) {\n    return new Position(target, true, 0);\n  }\n\n  const modifier = isMatrixParams(nav.commands[0]) ? 0 : 1;\n  const index = target.segments.length - 1 + modifier;\n  return createPositionApplyingDoubleDots(target, index, nav.numberOfDoubleDots);\n}\n\nfunction createPositionApplyingDoubleDots(\n    group: UrlSegmentGroup, index: number, numberOfDoubleDots: number): Position {\n  let g = group;\n  let ci = index;\n  let dd = numberOfDoubleDots;\n  while (dd > ci) {\n    dd -= ci;\n    g = g.parent!;\n    if (!g) {\n      throw new RuntimeError(\n          RuntimeErrorCode.INVALID_DOUBLE_DOTS,\n          (typeof ngDevMode === 'undefined' || ngDevMode) && 'Invalid number of \\'../\\'');\n    }\n    ci = g.segments.length;\n  }\n  return new Position(g, false, ci - dd);\n}\n\nfunction getOutlets(commands: unknown[]): {[k: string]: unknown[]|string} {\n  if (isCommandWithOutlets(commands[0])) {\n    return commands[0].outlets;\n  }\n\n  return {[PRIMARY_OUTLET]: commands};\n}\n\nfunction updateSegmentGroup(\n    segmentGroup: UrlSegmentGroup, startIndex: number, commands: any[]): UrlSegmentGroup {\n  if (!segmentGroup) {\n    segmentGroup = new UrlSegmentGroup([], {});\n  }\n  if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n    return updateSegmentGroupChildren(segmentGroup, startIndex, commands);\n  }\n\n  const m = prefixedWith(segmentGroup, startIndex, commands);\n  const slicedCommands = commands.slice(m.commandIndex);\n  if (m.match && m.pathIndex < segmentGroup.segments.length) {\n    const g = new UrlSegmentGroup(segmentGroup.segments.slice(0, m.pathIndex), {});\n    g.children[PRIMARY_OUTLET] =\n        new UrlSegmentGroup(segmentGroup.segments.slice(m.pathIndex), segmentGroup.children);\n    return updateSegmentGroupChildren(g, 0, slicedCommands);\n  } else if (m.match && slicedCommands.length === 0) {\n    return new UrlSegmentGroup(segmentGroup.segments, {});\n  } else if (m.match && !segmentGroup.hasChildren()) {\n    return createNewSegmentGroup(segmentGroup, startIndex, commands);\n  } else if (m.match) {\n    return updateSegmentGroupChildren(segmentGroup, 0, slicedCommands);\n  } else {\n    return createNewSegmentGroup(segmentGroup, startIndex, commands);\n  }\n}\n\nfunction updateSegmentGroupChildren(\n    segmentGroup: UrlSegmentGroup, startIndex: number, commands: any[]): UrlSegmentGroup {\n  if (commands.length === 0) {\n    return new UrlSegmentGroup(segmentGroup.segments, {});\n  } else {\n    const outlets = getOutlets(commands);\n    const children: {[key: string]: UrlSegmentGroup} = {};\n    // If the set of commands applies to anything other than the primary outlet and the child\n    // segment is an empty path primary segment on its own, we want to apply the commands to the\n    // empty child path rather than here. The outcome is that the empty primary child is effectively\n    // removed from the final output UrlTree. Imagine the following config:\n    //\n    // {path: '', children: [{path: '**', outlet: 'popup'}]}.\n    //\n    // Navigation to /(popup:a) will activate the child outlet correctly Given a follow-up\n    // navigation with commands\n    // ['/', {outlets: {'popup': 'b'}}], we _would not_ want to apply the outlet commands to the\n    // root segment because that would result in\n    // //(popup:a)(popup:b) since the outlet command got applied one level above where it appears in\n    // the `ActivatedRoute` rather than updating the existing one.\n    //\n    // Because empty paths do not appear in the URL segments and the fact that the segments used in\n    // the output `UrlTree` are squashed to eliminate these empty paths where possible\n    // https://github.com/angular/angular/blob/13f10de40e25c6900ca55bd83b36bd533dacfa9e/packages/router/src/url_tree.ts#L755\n    // it can be hard to determine what is the right thing to do when applying commands to a\n    // `UrlSegmentGroup` that is created from an \"unsquashed\"/expanded `ActivatedRoute` tree.\n    // This code effectively \"squashes\" empty path primary routes when they have no siblings on\n    // the same level of the tree.\n    if (Object.keys(outlets).some(o => o !== PRIMARY_OUTLET) &&\n        segmentGroup.children[PRIMARY_OUTLET] && segmentGroup.numberOfChildren === 1 &&\n        segmentGroup.children[PRIMARY_OUTLET].segments.length === 0) {\n      const childrenOfEmptyChild =\n          updateSegmentGroupChildren(segmentGroup.children[PRIMARY_OUTLET], startIndex, commands);\n      return new UrlSegmentGroup(segmentGroup.segments, childrenOfEmptyChild.children);\n    }\n\n    Object.entries(outlets).forEach(([outlet, commands]) => {\n      if (typeof commands === 'string') {\n        commands = [commands];\n      }\n      if (commands !== null) {\n        children[outlet] = updateSegmentGroup(segmentGroup.children[outlet], startIndex, commands);\n      }\n    });\n\n    Object.entries(segmentGroup.children).forEach(([childOutlet, child]) => {\n      if (outlets[childOutlet] === undefined) {\n        children[childOutlet] = child;\n      }\n    });\n    return new UrlSegmentGroup(segmentGroup.segments, children);\n  }\n}\n\nfunction prefixedWith(segmentGroup: UrlSegmentGroup, startIndex: number, commands: any[]) {\n  let currentCommandIndex = 0;\n  let currentPathIndex = startIndex;\n\n  const noMatch = {match: false, pathIndex: 0, commandIndex: 0};\n  while (currentPathIndex < segmentGroup.segments.length) {\n    if (currentCommandIndex >= commands.length) return noMatch;\n    const path = segmentGroup.segments[currentPathIndex];\n    const command = commands[currentCommandIndex];\n    // Do not try to consume command as part of the prefixing if it has outlets because it can\n    // contain outlets other than the one being processed. Consuming the outlets command would\n    // result in other outlets being ignored.\n    if (isCommandWithOutlets(command)) {\n      break;\n    }\n    const curr = `${command}`;\n    const next =\n        currentCommandIndex < commands.length - 1 ? commands[currentCommandIndex + 1] : null;\n\n    if (currentPathIndex > 0 && curr === undefined) break;\n\n    if (curr && next && (typeof next === 'object') && next.outlets === undefined) {\n      if (!compare(curr, next, path)) return noMatch;\n      currentCommandIndex += 2;\n    } else {\n      if (!compare(curr, {}, path)) return noMatch;\n      currentCommandIndex++;\n    }\n    currentPathIndex++;\n  }\n\n  return {match: true, pathIndex: currentPathIndex, commandIndex: currentCommandIndex};\n}\n\nfunction createNewSegmentGroup(\n    segmentGroup: UrlSegmentGroup, startIndex: number, commands: any[]): UrlSegmentGroup {\n  const paths = segmentGroup.segments.slice(0, startIndex);\n\n  let i = 0;\n  while (i < commands.length) {\n    const command = commands[i];\n    if (isCommandWithOutlets(command)) {\n      const children = createNewSegmentChildren(command.outlets);\n      return new UrlSegmentGroup(paths, children);\n    }\n\n    // if we start with an object literal, we need to reuse the path part from the segment\n    if (i === 0 && isMatrixParams(commands[0])) {\n      const p = segmentGroup.segments[startIndex];\n      paths.push(new UrlSegment(p.path, stringify(commands[0])));\n      i++;\n      continue;\n    }\n\n    const curr = isCommandWithOutlets(command) ? command.outlets[PRIMARY_OUTLET] : `${command}`;\n    const next = (i < commands.length - 1) ? commands[i + 1] : null;\n    if (curr && next && isMatrixParams(next)) {\n      paths.push(new UrlSegment(curr, stringify(next)));\n      i += 2;\n    } else {\n      paths.push(new UrlSegment(curr, {}));\n      i++;\n    }\n  }\n  return new UrlSegmentGroup(paths, {});\n}\n\nfunction createNewSegmentChildren(outlets: {[name: string]: unknown[]|string}):\n    {[outlet: string]: UrlSegmentGroup} {\n  const children: {[outlet: string]: UrlSegmentGroup} = {};\n  Object.entries(outlets).forEach(([outlet, commands]) => {\n    if (typeof commands === 'string') {\n      commands = [commands];\n    }\n    if (commands !== null) {\n      children[outlet] = createNewSegmentGroup(new UrlSegmentGroup([], {}), 0, commands);\n    }\n  });\n  return children;\n}\n\nfunction stringify(params: {[key: string]: any}): {[key: string]: string} {\n  const res: {[key: string]: string} = {};\n  Object.entries(params).forEach(([k, v]) => res[k] = `${v}`);\n  return res;\n}\n\nfunction compare(path: string, params: {[key: string]: any}, segment: UrlSegment): boolean {\n  return path == segment.path && shallowEqual(params, segment.parameters);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Route} from './models';\nimport {ActivatedRouteSnapshot, RouterStateSnapshot} from './router_state';\nimport {UrlTree} from './url_tree';\n\n/**\n * Identifies the call or event that triggered a navigation.\n *\n * * 'imperative': Triggered by `router.navigateByUrl()` or `router.navigate()`.\n * * 'popstate' : Triggered by a `popstate` event.\n * * 'hashchange'-: Triggered by a `hashchange` event.\n *\n * @publicApi\n */\nexport type NavigationTrigger = 'imperative'|'popstate'|'hashchange';\nexport const IMPERATIVE_NAVIGATION = 'imperative';\n\n/**\n * Identifies the type of a router event.\n *\n * @publicApi\n */\nexport const enum EventType {\n  NavigationStart,\n  NavigationEnd,\n  NavigationCancel,\n  NavigationError,\n  RoutesRecognized,\n  ResolveStart,\n  ResolveEnd,\n  GuardsCheckStart,\n  GuardsCheckEnd,\n  RouteConfigLoadStart,\n  RouteConfigLoadEnd,\n  ChildActivationStart,\n  ChildActivationEnd,\n  ActivationStart,\n  ActivationEnd,\n  Scroll,\n  NavigationSkipped,\n}\n\n/**\n * Base for events the router goes through, as opposed to events tied to a specific\n * route. Fired one time for any given navigation.\n *\n * The following code shows how a class subscribes to router events.\n *\n * ```ts\n * import {Event, RouterEvent, Router} from '@angular/router';\n *\n * class MyService {\n *   constructor(public router: Router) {\n *     router.events.pipe(\n *        filter((e: Event | RouterEvent): e is RouterEvent => e instanceof RouterEvent)\n *     ).subscribe((e: RouterEvent) => {\n *       // Do something\n *     });\n *   }\n * }\n * ```\n *\n * @see {@link Event}\n * @see [Router events summary](guide/router-reference#router-events)\n * @publicApi\n */\nexport class RouterEvent {\n  constructor(\n      /** A unique ID that the router assigns to every router navigation. */\n      public id: number,\n      /** The URL that is the destination for this navigation. */\n      public url: string) {}\n}\n\n/**\n * An event triggered when a navigation starts.\n *\n * @publicApi\n */\nexport class NavigationStart extends RouterEvent {\n  readonly type = EventType.NavigationStart;\n\n  /**\n   * Identifies the call or event that triggered the navigation.\n   * An `imperative` trigger is a call to `router.navigateByUrl()` or `router.navigate()`.\n   *\n   * @see {@link NavigationEnd}\n   * @see {@link NavigationCancel}\n   * @see {@link NavigationError}\n   */\n  navigationTrigger?: NavigationTrigger;\n\n  /**\n   * The navigation state that was previously supplied to the `pushState` call,\n   * when the navigation is triggered by a `popstate` event. Otherwise null.\n   *\n   * The state object is defined by `NavigationExtras`, and contains any\n   * developer-defined state value, as well as a unique ID that\n   * the router assigns to every router transition/navigation.\n   *\n   * From the perspective of the router, the router never \"goes back\".\n   * When the user clicks on the back button in the browser,\n   * a new navigation ID is created.\n   *\n   * Use the ID in this previous-state object to differentiate between a newly created\n   * state and one returned to by a `popstate` event, so that you can restore some\n   * remembered state, such as scroll position.\n   *\n   */\n  restoredState?: {[k: string]: any, navigationId: number}|null;\n\n  constructor(\n      /** @docsNotRequired */\n      id: number,\n      /** @docsNotRequired */\n      url: string,\n      /** @docsNotRequired */\n      navigationTrigger: NavigationTrigger = 'imperative',\n      /** @docsNotRequired */\n      restoredState: {[k: string]: any, navigationId: number}|null = null) {\n    super(id, url);\n    this.navigationTrigger = navigationTrigger;\n    this.restoredState = restoredState;\n  }\n\n  /** @docsNotRequired */\n  override toString(): string {\n    return `NavigationStart(id: ${this.id}, url: '${this.url}')`;\n  }\n}\n\n/**\n * An event triggered when a navigation ends successfully.\n *\n * @see {@link NavigationStart}\n * @see {@link NavigationCancel}\n * @see {@link NavigationError}\n *\n * @publicApi\n */\nexport class NavigationEnd extends RouterEvent {\n  readonly type = EventType.NavigationEnd;\n\n  constructor(\n      /** @docsNotRequired */\n      id: number,\n      /** @docsNotRequired */\n      url: string,\n      /** @docsNotRequired */\n      public urlAfterRedirects: string) {\n    super(id, url);\n  }\n\n  /** @docsNotRequired */\n  override toString(): string {\n    return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${\n        this.urlAfterRedirects}')`;\n  }\n}\n\n/**\n * A code for the `NavigationCancel` event of the `Router` to indicate the\n * reason a navigation failed.\n *\n * @publicApi\n */\nexport const enum NavigationCancellationCode {\n  /**\n   * A navigation failed because a guard returned a `UrlTree` to redirect.\n   */\n  Redirect,\n  /**\n   * A navigation failed because a more recent navigation started.\n   */\n  SupersededByNewNavigation,\n  /**\n   * A navigation failed because one of the resolvers completed without emitting a value.\n   */\n  NoDataFromResolver,\n  /**\n   * A navigation failed because a guard returned `false`.\n   */\n  GuardRejected,\n}\n\n/**\n * A code for the `NavigationSkipped` event of the `Router` to indicate the\n * reason a navigation was skipped.\n *\n * @publicApi\n */\nexport const enum NavigationSkippedCode {\n  /**\n   * A navigation was skipped because the navigation URL was the same as the current Router URL.\n   */\n  IgnoredSameUrlNavigation,\n  /**\n   * A navigation was skipped because the configured `UrlHandlingStrategy` return `false` for both\n   * the current Router URL and the target of the navigation.\n   *\n   * @see {@link UrlHandlingStrategy}\n   */\n  IgnoredByUrlHandlingStrategy,\n}\n\n/**\n * An event triggered when a navigation is canceled, directly or indirectly.\n * This can happen for several reasons including when a route guard\n * returns `false` or initiates a redirect by returning a `UrlTree`.\n *\n * @see {@link NavigationStart}\n * @see {@link NavigationEnd}\n * @see {@link NavigationError}\n *\n * @publicApi\n */\nexport class NavigationCancel extends RouterEvent {\n  readonly type = EventType.NavigationCancel;\n\n  constructor(\n      /** @docsNotRequired */\n      id: number,\n      /** @docsNotRequired */\n      url: string,\n      /**\n       * A description of why the navigation was cancelled. For debug purposes only. Use `code`\n       * instead for a stable cancellation reason that can be used in production.\n       */\n      public reason: string,\n      /**\n       * A code to indicate why the navigation was canceled. This cancellation code is stable for\n       * the reason and can be relied on whereas the `reason` string could change and should not be\n       * used in production.\n       */\n      readonly code?: NavigationCancellationCode) {\n    super(id, url);\n  }\n\n  /** @docsNotRequired */\n  override toString(): string {\n    return `NavigationCancel(id: ${this.id}, url: '${this.url}')`;\n  }\n}\n\n/**\n * An event triggered when a navigation is skipped.\n * This can happen for a couple reasons including onSameUrlHandling\n * is set to `ignore` and the navigation URL is not different than the\n * current state.\n *\n * @publicApi\n */\nexport class NavigationSkipped extends RouterEvent {\n  readonly type = EventType.NavigationSkipped;\n\n  constructor(\n      /** @docsNotRequired */\n      id: number,\n      /** @docsNotRequired */\n      url: string,\n      /**\n       * A description of why the navigation was skipped. For debug purposes only. Use `code`\n       * instead for a stable skipped reason that can be used in production.\n       */\n      public reason: string,\n      /**\n       * A code to indicate why the navigation was skipped. This code is stable for\n       * the reason and can be relied on whereas the `reason` string could change and should not be\n       * used in production.\n       */\n      readonly code?: NavigationSkippedCode) {\n    super(id, url);\n  }\n}\n\n/**\n * An event triggered when a navigation fails due to an unexpected error.\n *\n * @see {@link NavigationStart}\n * @see {@link NavigationEnd}\n * @see {@link NavigationCancel}\n *\n * @publicApi\n */\nexport class NavigationError extends RouterEvent {\n  readonly type = EventType.NavigationError;\n\n  constructor(\n      /** @docsNotRequired */\n      id: number,\n      /** @docsNotRequired */\n      url: string,\n      /** @docsNotRequired */\n      public error: any,\n      /**\n       * The target of the navigation when the error occurred.\n       *\n       * Note that this can be `undefined` because an error could have occurred before the\n       * `RouterStateSnapshot` was created for the navigation.\n       */\n      readonly target?: RouterStateSnapshot) {\n    super(id, url);\n  }\n\n  /** @docsNotRequired */\n  override toString(): string {\n    return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`;\n  }\n}\n\n/**\n * An event triggered when routes are recognized.\n *\n * @publicApi\n */\nexport class RoutesRecognized extends RouterEvent {\n  readonly type = EventType.RoutesRecognized;\n\n  constructor(\n      /** @docsNotRequired */\n      id: number,\n      /** @docsNotRequired */\n      url: string,\n      /** @docsNotRequired */\n      public urlAfterRedirects: string,\n      /** @docsNotRequired */\n      public state: RouterStateSnapshot) {\n    super(id, url);\n  }\n\n  /** @docsNotRequired */\n  override toString(): string {\n    return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${\n        this.urlAfterRedirects}', state: ${this.state})`;\n  }\n}\n\n/**\n * An event triggered at the start of the Guard phase of routing.\n *\n * @see {@link GuardsCheckEnd}\n *\n * @publicApi\n */\nexport class GuardsCheckStart extends RouterEvent {\n  readonly type = EventType.GuardsCheckStart;\n\n  constructor(\n      /** @docsNotRequired */\n      id: number,\n      /** @docsNotRequired */\n      url: string,\n      /** @docsNotRequired */\n      public urlAfterRedirects: string,\n      /** @docsNotRequired */\n      public state: RouterStateSnapshot) {\n    super(id, url);\n  }\n\n  override toString(): string {\n    return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${\n        this.urlAfterRedirects}', state: ${this.state})`;\n  }\n}\n\n/**\n * An event triggered at the end of the Guard phase of routing.\n *\n * @see {@link GuardsCheckStart}\n *\n * @publicApi\n */\nexport class GuardsCheckEnd extends RouterEvent {\n  readonly type = EventType.GuardsCheckEnd;\n\n  constructor(\n      /** @docsNotRequired */\n      id: number,\n      /** @docsNotRequired */\n      url: string,\n      /** @docsNotRequired */\n      public urlAfterRedirects: string,\n      /** @docsNotRequired */\n      public state: RouterStateSnapshot,\n      /** @docsNotRequired */\n      public shouldActivate: boolean) {\n    super(id, url);\n  }\n\n  override toString(): string {\n    return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${\n        this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`;\n  }\n}\n\n/**\n * An event triggered at the start of the Resolve phase of routing.\n *\n * Runs in the \"resolve\" phase whether or not there is anything to resolve.\n * In future, may change to only run when there are things to be resolved.\n *\n * @see {@link ResolveEnd}\n *\n * @publicApi\n */\nexport class ResolveStart extends RouterEvent {\n  readonly type = EventType.ResolveStart;\n\n  constructor(\n      /** @docsNotRequired */\n      id: number,\n      /** @docsNotRequired */\n      url: string,\n      /** @docsNotRequired */\n      public urlAfterRedirects: string,\n      /** @docsNotRequired */\n      public state: RouterStateSnapshot) {\n    super(id, url);\n  }\n\n  override toString(): string {\n    return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${\n        this.urlAfterRedirects}', state: ${this.state})`;\n  }\n}\n\n/**\n * An event triggered at the end of the Resolve phase of routing.\n * @see {@link ResolveStart}\n *\n * @publicApi\n */\nexport class ResolveEnd extends RouterEvent {\n  readonly type = EventType.ResolveEnd;\n\n  constructor(\n      /** @docsNotRequired */\n      id: number,\n      /** @docsNotRequired */\n      url: string,\n      /** @docsNotRequired */\n      public urlAfterRedirects: string,\n      /** @docsNotRequired */\n      public state: RouterStateSnapshot) {\n    super(id, url);\n  }\n\n  override toString(): string {\n    return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${\n        this.urlAfterRedirects}', state: ${this.state})`;\n  }\n}\n\n/**\n * An event triggered before lazy loading a route configuration.\n *\n * @see {@link RouteConfigLoadEnd}\n *\n * @publicApi\n */\nexport class RouteConfigLoadStart {\n  readonly type = EventType.RouteConfigLoadStart;\n\n  constructor(\n      /** @docsNotRequired */\n      public route: Route) {}\n  toString(): string {\n    return `RouteConfigLoadStart(path: ${this.route.path})`;\n  }\n}\n\n/**\n * An event triggered when a route has been lazy loaded.\n *\n * @see {@link RouteConfigLoadStart}\n *\n * @publicApi\n */\nexport class RouteConfigLoadEnd {\n  readonly type = EventType.RouteConfigLoadEnd;\n\n  constructor(\n      /** @docsNotRequired */\n      public route: Route) {}\n  toString(): string {\n    return `RouteConfigLoadEnd(path: ${this.route.path})`;\n  }\n}\n\n/**\n * An event triggered at the start of the child-activation\n * part of the Resolve phase of routing.\n * @see {@link ChildActivationEnd}\n * @see {@link ResolveStart}\n *\n * @publicApi\n */\nexport class ChildActivationStart {\n  readonly type = EventType.ChildActivationStart;\n\n  constructor(\n      /** @docsNotRequired */\n      public snapshot: ActivatedRouteSnapshot) {}\n  toString(): string {\n    const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';\n    return `ChildActivationStart(path: '${path}')`;\n  }\n}\n\n/**\n * An event triggered at the end of the child-activation part\n * of the Resolve phase of routing.\n * @see {@link ChildActivationStart}\n * @see {@link ResolveStart}\n * @publicApi\n */\nexport class ChildActivationEnd {\n  readonly type = EventType.ChildActivationEnd;\n\n  constructor(\n      /** @docsNotRequired */\n      public snapshot: ActivatedRouteSnapshot) {}\n  toString(): string {\n    const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';\n    return `ChildActivationEnd(path: '${path}')`;\n  }\n}\n\n/**\n * An event triggered at the start of the activation part\n * of the Resolve phase of routing.\n * @see {@link ActivationEnd}\n * @see {@link ResolveStart}\n *\n * @publicApi\n */\nexport class ActivationStart {\n  readonly type = EventType.ActivationStart;\n\n  constructor(\n      /** @docsNotRequired */\n      public snapshot: ActivatedRouteSnapshot) {}\n  toString(): string {\n    const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';\n    return `ActivationStart(path: '${path}')`;\n  }\n}\n\n/**\n * An event triggered at the end of the activation part\n * of the Resolve phase of routing.\n * @see {@link ActivationStart}\n * @see {@link ResolveStart}\n *\n * @publicApi\n */\nexport class ActivationEnd {\n  readonly type = EventType.ActivationEnd;\n\n  constructor(\n      /** @docsNotRequired */\n      public snapshot: ActivatedRouteSnapshot) {}\n  toString(): string {\n    const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';\n    return `ActivationEnd(path: '${path}')`;\n  }\n}\n\n/**\n * An event triggered by scrolling.\n *\n * @publicApi\n */\nexport class Scroll {\n  readonly type = EventType.Scroll;\n\n  constructor(\n      /** @docsNotRequired */\n      readonly routerEvent: NavigationEnd|NavigationSkipped,\n\n      /** @docsNotRequired */\n      readonly position: [number, number]|null,\n\n      /** @docsNotRequired */\n      readonly anchor: string|null) {}\n\n  toString(): string {\n    const pos = this.position ? `${this.position[0]}, ${this.position[1]}` : null;\n    return `Scroll(anchor: '${this.anchor}', position: '${pos}')`;\n  }\n}\n\nexport class BeforeActivateRoutes {}\nexport class RedirectRequest {\n  constructor(readonly url: UrlTree) {}\n}\nexport type PrivateRouterEvents = BeforeActivateRoutes|RedirectRequest;\n\n/**\n * Router events that allow you to track the lifecycle of the router.\n *\n * The events occur in the following sequence:\n *\n * * [NavigationStart](api/router/NavigationStart): Navigation starts.\n * * [RouteConfigLoadStart](api/router/RouteConfigLoadStart): Before\n * the router [lazy loads](/guide/router#lazy-loading) a route configuration.\n * * [RouteConfigLoadEnd](api/router/RouteConfigLoadEnd): After a route has been lazy loaded.\n * * [RoutesRecognized](api/router/RoutesRecognized): When the router parses the URL\n * and the routes are recognized.\n * * [GuardsCheckStart](api/router/GuardsCheckStart): When the router begins the *guards*\n * phase of routing.\n * * [ChildActivationStart](api/router/ChildActivationStart): When the router\n * begins activating a route's children.\n * * [ActivationStart](api/router/ActivationStart): When the router begins activating a route.\n * * [GuardsCheckEnd](api/router/GuardsCheckEnd): When the router finishes the *guards*\n * phase of routing successfully.\n * * [ResolveStart](api/router/ResolveStart): When the router begins the *resolve*\n * phase of routing.\n * * [ResolveEnd](api/router/ResolveEnd): When the router finishes the *resolve*\n * phase of routing successfully.\n * * [ChildActivationEnd](api/router/ChildActivationEnd): When the router finishes\n * activating a route's children.\n * * [ActivationEnd](api/router/ActivationEnd): When the router finishes activating a route.\n * * [NavigationEnd](api/router/NavigationEnd): When navigation ends successfully.\n * * [NavigationCancel](api/router/NavigationCancel): When navigation is canceled.\n * * [NavigationError](api/router/NavigationError): When navigation fails\n * due to an unexpected error.\n * * [Scroll](api/router/Scroll): When the user scrolls.\n *\n * @publicApi\n */\nexport type Event = NavigationStart|NavigationEnd|NavigationCancel|NavigationError|RoutesRecognized|\n    GuardsCheckStart|GuardsCheckEnd|RouteConfigLoadStart|RouteConfigLoadEnd|ChildActivationStart|\n    ChildActivationEnd|ActivationStart|ActivationEnd|Scroll|ResolveStart|ResolveEnd|\n    NavigationSkipped;\n\nexport function stringifyEvent(routerEvent: Event): string {\n  switch (routerEvent.type) {\n    case EventType.ActivationEnd:\n      return `ActivationEnd(path: '${routerEvent.snapshot.routeConfig?.path || ''}')`;\n    case EventType.ActivationStart:\n      return `ActivationStart(path: '${routerEvent.snapshot.routeConfig?.path || ''}')`;\n    case EventType.ChildActivationEnd:\n      return `ChildActivationEnd(path: '${routerEvent.snapshot.routeConfig?.path || ''}')`;\n    case EventType.ChildActivationStart:\n      return `ChildActivationStart(path: '${routerEvent.snapshot.routeConfig?.path || ''}')`;\n    case EventType.GuardsCheckEnd:\n      return `GuardsCheckEnd(id: ${routerEvent.id}, url: '${\n          routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${\n          routerEvent.state}, shouldActivate: ${routerEvent.shouldActivate})`;\n    case EventType.GuardsCheckStart:\n      return `GuardsCheckStart(id: ${routerEvent.id}, url: '${\n          routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${\n          routerEvent.state})`;\n    case EventType.NavigationCancel:\n      return `NavigationCancel(id: ${routerEvent.id}, url: '${routerEvent.url}')`;\n    case EventType.NavigationSkipped:\n      return `NavigationSkipped(id: ${routerEvent.id}, url: '${routerEvent.url}')`;\n    case EventType.NavigationEnd:\n      return `NavigationEnd(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${\n          routerEvent.urlAfterRedirects}')`;\n    case EventType.NavigationError:\n      return `NavigationError(id: ${routerEvent.id}, url: '${routerEvent.url}', error: ${\n          routerEvent.error})`;\n    case EventType.NavigationStart:\n      return `NavigationStart(id: ${routerEvent.id}, url: '${routerEvent.url}')`;\n    case EventType.ResolveEnd:\n      return `ResolveEnd(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${\n          routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;\n    case EventType.ResolveStart:\n      return `ResolveStart(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${\n          routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;\n    case EventType.RouteConfigLoadEnd:\n      return `RouteConfigLoadEnd(path: ${routerEvent.route.path})`;\n    case EventType.RouteConfigLoadStart:\n      return `RouteConfigLoadStart(path: ${routerEvent.route.path})`;\n    case EventType.RoutesRecognized:\n      return `RoutesRecognized(id: ${routerEvent.id}, url: '${\n          routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${\n          routerEvent.state})`;\n    case EventType.Scroll:\n      const pos =\n          routerEvent.position ? `${routerEvent.position[0]}, ${routerEvent.position[1]}` : null;\n      return `Scroll(anchor: '${routerEvent.anchor}', position: '${pos}')`;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ComponentRef, EnvironmentInjector, Injectable} from '@angular/core';\n\nimport {RouterOutletContract} from './directives/router_outlet';\nimport {ActivatedRoute} from './router_state';\n\n\n/**\n * Store contextual information about a `RouterOutlet`\n *\n * @publicApi\n */\nexport class OutletContext {\n  outlet: RouterOutletContract|null = null;\n  route: ActivatedRoute|null = null;\n  injector: EnvironmentInjector|null = null;\n  children = new ChildrenOutletContexts();\n  attachRef: ComponentRef<any>|null = null;\n}\n\n/**\n * Store contextual information about the children (= nested) `RouterOutlet`\n *\n * @publicApi\n */\n@Injectable({providedIn: 'root'})\nexport class ChildrenOutletContexts {\n  // contexts for child outlets, by name.\n  private contexts = new Map<string, OutletContext>();\n\n  /** Called when a `RouterOutlet` directive is instantiated */\n  onChildOutletCreated(childName: string, outlet: RouterOutletContract): void {\n    const context = this.getOrCreateContext(childName);\n    context.outlet = outlet;\n    this.contexts.set(childName, context);\n  }\n\n  /**\n   * Called when a `RouterOutlet` directive is destroyed.\n   * We need to keep the context as the outlet could be destroyed inside a NgIf and might be\n   * re-created later.\n   */\n  onChildOutletDestroyed(childName: string): void {\n    const context = this.getContext(childName);\n    if (context) {\n      context.outlet = null;\n      context.attachRef = null;\n    }\n  }\n\n  /**\n   * Called when the corresponding route is deactivated during navigation.\n   * Because the component get destroyed, all children outlet are destroyed.\n   */\n  onOutletDeactivated(): Map<string, OutletContext> {\n    const contexts = this.contexts;\n    this.contexts = new Map();\n    return contexts;\n  }\n\n  onOutletReAttached(contexts: Map<string, OutletContext>) {\n    this.contexts = contexts;\n  }\n\n  getOrCreateContext(childName: string): OutletContext {\n    let context = this.getContext(childName);\n\n    if (!context) {\n      context = new OutletContext();\n      this.contexts.set(childName, context);\n    }\n\n    return context;\n  }\n\n  getContext(childName: string): OutletContext|null {\n    return this.contexts.get(childName) || null;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport class Tree<T> {\n  /** @internal */\n  _root: TreeNode<T>;\n\n  constructor(root: TreeNode<T>) {\n    this._root = root;\n  }\n\n  get root(): T {\n    return this._root.value;\n  }\n\n  /**\n   * @internal\n   */\n  parent(t: T): T|null {\n    const p = this.pathFromRoot(t);\n    return p.length > 1 ? p[p.length - 2] : null;\n  }\n\n  /**\n   * @internal\n   */\n  children(t: T): T[] {\n    const n = findNode(t, this._root);\n    return n ? n.children.map(t => t.value) : [];\n  }\n\n  /**\n   * @internal\n   */\n  firstChild(t: T): T|null {\n    const n = findNode(t, this._root);\n    return n && n.children.length > 0 ? n.children[0].value : null;\n  }\n\n  /**\n   * @internal\n   */\n  siblings(t: T): T[] {\n    const p = findPath(t, this._root);\n    if (p.length < 2) return [];\n\n    const c = p[p.length - 2].children.map(c => c.value);\n    return c.filter(cc => cc !== t);\n  }\n\n  /**\n   * @internal\n   */\n  pathFromRoot(t: T): T[] {\n    return findPath(t, this._root).map(s => s.value);\n  }\n}\n\n\n// DFS for the node matching the value\nfunction findNode<T>(value: T, node: TreeNode<T>): TreeNode<T>|null {\n  if (value === node.value) return node;\n\n  for (const child of node.children) {\n    const node = findNode(value, child);\n    if (node) return node;\n  }\n\n  return null;\n}\n\n// Return the path to the node with the given value using DFS\nfunction findPath<T>(value: T, node: TreeNode<T>): TreeNode<T>[] {\n  if (value === node.value) return [node];\n\n  for (const child of node.children) {\n    const path = findPath(value, child);\n    if (path.length) {\n      path.unshift(node);\n      return path;\n    }\n  }\n\n  return [];\n}\n\nexport class TreeNode<T> {\n  constructor(public value: T, public children: TreeNode<T>[]) {}\n\n  toString(): string {\n    return `TreeNode(${this.value})`;\n  }\n}\n\n// Return the list of T indexed by outlet name\nexport function nodeChildrenAsMap<T extends {outlet: string}>(node: TreeNode<T>|null) {\n  const map: {[outlet: string]: TreeNode<T>} = {};\n\n  if (node) {\n    node.children.forEach(child => map[child.value.outlet] = child);\n  }\n\n  return map;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type} from '@angular/core';\nimport {BehaviorSubject, Observable, of} from 'rxjs';\nimport {map} from 'rxjs/operators';\n\nimport {Data, ResolveData, Route} from './models';\nimport {convertToParamMap, ParamMap, Params, PRIMARY_OUTLET, RouteTitleKey} from './shared';\nimport {equalSegments, UrlSegment, UrlTree} from './url_tree';\nimport {shallowEqual, shallowEqualArrays} from './utils/collection';\nimport {Tree, TreeNode} from './utils/tree';\n\n/**\n * Represents the state of the router as a tree of activated routes.\n *\n * @usageNotes\n *\n * Every node in the route tree is an `ActivatedRoute` instance\n * that knows about the \"consumed\" URL segments, the extracted parameters,\n * and the resolved data.\n * Use the `ActivatedRoute` properties to traverse the tree from any node.\n *\n * The following fragment shows how a component gets the root node\n * of the current state to establish its own route tree:\n *\n * ```\n * @Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const state: RouterState = router.routerState;\n *     const root: ActivatedRoute = state.root;\n *     const child = root.firstChild;\n *     const id: Observable<string> = child.params.map(p => p.id);\n *     //...\n *   }\n * }\n * ```\n *\n * @see {@link ActivatedRoute}\n * @see [Getting route information](guide/router#getting-route-information)\n *\n * @publicApi\n */\nexport class RouterState extends Tree<ActivatedRoute> {\n  /** @internal */\n  constructor(\n      root: TreeNode<ActivatedRoute>,\n      /** The current snapshot of the router state */\n      public snapshot: RouterStateSnapshot) {\n    super(root);\n    setRouterState(<RouterState>this, root);\n  }\n\n  override toString(): string {\n    return this.snapshot.toString();\n  }\n}\n\nexport function createEmptyState(urlTree: UrlTree, rootComponent: Type<any>|null): RouterState {\n  const snapshot = createEmptyStateSnapshot(urlTree, rootComponent);\n  const emptyUrl = new BehaviorSubject([new UrlSegment('', {})]);\n  const emptyParams = new BehaviorSubject({});\n  const emptyData = new BehaviorSubject({});\n  const emptyQueryParams = new BehaviorSubject({});\n  const fragment = new BehaviorSubject<string|null>('');\n  const activated = new ActivatedRoute(\n      emptyUrl, emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent,\n      snapshot.root);\n  activated.snapshot = snapshot.root;\n  return new RouterState(new TreeNode<ActivatedRoute>(activated, []), snapshot);\n}\n\nexport function createEmptyStateSnapshot(\n    urlTree: UrlTree, rootComponent: Type<any>|null): RouterStateSnapshot {\n  const emptyParams = {};\n  const emptyData = {};\n  const emptyQueryParams = {};\n  const fragment = '';\n  const activated = new ActivatedRouteSnapshot(\n      [], emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, null,\n      {});\n  return new RouterStateSnapshot('', new TreeNode<ActivatedRouteSnapshot>(activated, []));\n}\n\n/**\n * Provides access to information about a route associated with a component\n * that is loaded in an outlet.\n * Use to traverse the `RouterState` tree and extract information from nodes.\n *\n * The following example shows how to construct a component using information from a\n * currently activated route.\n *\n * Note: the observables in this class only emit when the current and previous values differ based\n * on shallow equality. For example, changing deeply nested properties in resolved `data` will not\n * cause the `ActivatedRoute.data` `Observable` to emit a new value.\n *\n * {@example router/activated-route/module.ts region=\"activated-route\"\n *     header=\"activated-route.component.ts\"}\n *\n * @see [Getting route information](guide/router#getting-route-information)\n *\n * @publicApi\n */\nexport class ActivatedRoute {\n  /** The current snapshot of this route */\n  snapshot!: ActivatedRouteSnapshot;\n  /** @internal */\n  _futureSnapshot: ActivatedRouteSnapshot;\n  /** @internal */\n  _routerState!: RouterState;\n  /** @internal */\n  _paramMap?: Observable<ParamMap>;\n  /** @internal */\n  _queryParamMap?: Observable<ParamMap>;\n\n  /** An Observable of the resolved route title */\n  readonly title: Observable<string|undefined>;\n\n  /** An observable of the URL segments matched by this route. */\n  public url: Observable<UrlSegment[]>;\n  /** An observable of the matrix parameters scoped to this route. */\n  public params: Observable<Params>;\n  /** An observable of the query parameters shared by all the routes. */\n  public queryParams: Observable<Params>;\n  /** An observable of the URL fragment shared by all the routes. */\n  public fragment: Observable<string|null>;\n  /** An observable of the static and resolved data of this route. */\n  public data: Observable<Data>;\n\n  /** @internal */\n  constructor(\n      /** @internal */\n      public urlSubject: BehaviorSubject<UrlSegment[]>,\n      /** @internal */\n      public paramsSubject: BehaviorSubject<Params>,\n      /** @internal */\n      public queryParamsSubject: BehaviorSubject<Params>,\n      /** @internal */\n      public fragmentSubject: BehaviorSubject<string|null>,\n      /** @internal */\n      public dataSubject: BehaviorSubject<Data>,\n      /** The outlet name of the route, a constant. */\n      public outlet: string,\n      /** The component of the route, a constant. */\n      public component: Type<any>|null, futureSnapshot: ActivatedRouteSnapshot) {\n    this._futureSnapshot = futureSnapshot;\n    this.title = this.dataSubject?.pipe(map((d: Data) => d[RouteTitleKey])) ?? of(undefined);\n    // TODO(atscott): Verify that these can be changed to `.asObservable()` with TGP.\n    this.url = urlSubject;\n    this.params = paramsSubject;\n    this.queryParams = queryParamsSubject;\n    this.fragment = fragmentSubject;\n    this.data = dataSubject;\n  }\n\n  /** The configuration used to match this route. */\n  get routeConfig(): Route|null {\n    return this._futureSnapshot.routeConfig;\n  }\n\n  /** The root of the router state. */\n  get root(): ActivatedRoute {\n    return this._routerState.root;\n  }\n\n  /** The parent of this route in the router state tree. */\n  get parent(): ActivatedRoute|null {\n    return this._routerState.parent(this);\n  }\n\n  /** The first child of this route in the router state tree. */\n  get firstChild(): ActivatedRoute|null {\n    return this._routerState.firstChild(this);\n  }\n\n  /** The children of this route in the router state tree. */\n  get children(): ActivatedRoute[] {\n    return this._routerState.children(this);\n  }\n\n  /** The path from the root of the router state tree to this route. */\n  get pathFromRoot(): ActivatedRoute[] {\n    return this._routerState.pathFromRoot(this);\n  }\n\n  /**\n   * An Observable that contains a map of the required and optional parameters\n   * specific to the route.\n   * The map supports retrieving single and multiple values from the same parameter.\n   */\n  get paramMap(): Observable<ParamMap> {\n    if (!this._paramMap) {\n      this._paramMap = this.params.pipe(map((p: Params): ParamMap => convertToParamMap(p)));\n    }\n    return this._paramMap;\n  }\n\n  /**\n   * An Observable that contains a map of the query parameters available to all routes.\n   * The map supports retrieving single and multiple values from the query parameter.\n   */\n  get queryParamMap(): Observable<ParamMap> {\n    if (!this._queryParamMap) {\n      this._queryParamMap =\n          this.queryParams.pipe(map((p: Params): ParamMap => convertToParamMap(p)));\n    }\n    return this._queryParamMap;\n  }\n\n  toString(): string {\n    return this.snapshot ? this.snapshot.toString() : `Future(${this._futureSnapshot})`;\n  }\n}\n\nexport type ParamsInheritanceStrategy = 'emptyOnly'|'always';\n\n/** @internal */\nexport type Inherited = {\n  params: Params,\n  data: Data,\n  resolve: Data,\n};\n\n/**\n * Returns the inherited params, data, and resolve for a given route.\n *\n * By default, we do not inherit parent data unless the current route is path-less or the parent\n * route is component-less.\n */\nexport function getInherited(\n    route: ActivatedRouteSnapshot, parent: ActivatedRouteSnapshot|null,\n    paramsInheritanceStrategy: ParamsInheritanceStrategy = 'emptyOnly'): Inherited {\n  let inherited: Inherited;\n  const {routeConfig} = route;\n  if (parent !== null &&\n      (paramsInheritanceStrategy === 'always' ||\n       // inherit parent data if route is empty path\n       routeConfig?.path === '' ||\n       // inherit parent data if parent was componentless\n       (!parent.component && !parent.routeConfig?.loadComponent))) {\n    inherited = {\n      params: {...parent.params, ...route.params},\n      data: {...parent.data, ...route.data},\n      resolve: {\n        // Snapshots are created with data inherited from parent and guards (i.e. canActivate) can\n        // change data because it's not frozen...\n        // This first line could be deleted chose to break/disallow mutating the `data` object in\n        // guards.\n        // Note that data from parents still override this mutated data so anyone relying on this\n        // might be surprised that it doesn't work if parent data is inherited but otherwise does.\n        ...route.data,\n        // Ensure inherited resolved data overrides inherited static data\n        ...parent.data,\n        // static data from the current route overrides any inherited data\n        ...routeConfig?.data,\n        // resolved data from current route overrides everything\n        ...route._resolvedData,\n      }\n    };\n  } else {\n    inherited = {\n      params: route.params,\n      data: route.data,\n      resolve: {...route.data, ...(route._resolvedData ?? {})}\n    };\n  }\n\n  if (routeConfig && hasStaticTitle(routeConfig)) {\n    inherited.resolve[RouteTitleKey] = routeConfig.title;\n  }\n  return inherited;\n}\n\n/**\n * @description\n *\n * Contains the information about a route associated with a component loaded in an\n * outlet at a particular moment in time. ActivatedRouteSnapshot can also be used to\n * traverse the router state tree.\n *\n * The following example initializes a component with route information extracted\n * from the snapshot of the root node at the time of creation.\n *\n * ```\n * @Component({templateUrl:'./my-component.html'})\n * class MyComponent {\n *   constructor(route: ActivatedRoute) {\n *     const id: string = route.snapshot.params.id;\n *     const url: string = route.snapshot.url.join('');\n *     const user = route.snapshot.data.user;\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nexport class ActivatedRouteSnapshot {\n  /** The configuration used to match this route **/\n  public readonly routeConfig: Route|null;\n  /** @internal */\n  _resolve: ResolveData;\n  /** @internal */\n  _resolvedData?: Data;\n  /** @internal */\n  _routerState!: RouterStateSnapshot;\n  /** @internal */\n  _paramMap?: ParamMap;\n  /** @internal */\n  _queryParamMap?: ParamMap;\n\n  /** The resolved route title */\n  get title(): string|undefined {\n    // Note: This _must_ be a getter because the data is mutated in the resolvers. Title will not be\n    // available at the time of class instantiation.\n    return this.data?.[RouteTitleKey];\n  }\n\n  /** @internal */\n  constructor(\n      /** The URL segments matched by this route */\n      public url: UrlSegment[],\n      /**\n       *  The matrix parameters scoped to this route.\n       *\n       *  You can compute all params (or data) in the router state or to get params outside\n       *  of an activated component by traversing the `RouterState` tree as in the following\n       *  example:\n       *  ```\n       *  collectRouteParams(router: Router) {\n       *    let params = {};\n       *    let stack: ActivatedRouteSnapshot[] = [router.routerState.snapshot.root];\n       *    while (stack.length > 0) {\n       *      const route = stack.pop()!;\n       *      params = {...params, ...route.params};\n       *      stack.push(...route.children);\n       *    }\n       *    return params;\n       *  }\n       *  ```\n       */\n      public params: Params,\n      /** The query parameters shared by all the routes */\n      public queryParams: Params,\n      /** The URL fragment shared by all the routes */\n      public fragment: string|null,\n      /** The static and resolved data of this route */\n      public data: Data,\n      /** The outlet name of the route */\n      public outlet: string,\n      /** The component of the route */\n      public component: Type<any>|null, routeConfig: Route|null, resolve: ResolveData) {\n    this.routeConfig = routeConfig;\n    this._resolve = resolve;\n  }\n\n  /** The root of the router state */\n  get root(): ActivatedRouteSnapshot {\n    return this._routerState.root;\n  }\n\n  /** The parent of this route in the router state tree */\n  get parent(): ActivatedRouteSnapshot|null {\n    return this._routerState.parent(this);\n  }\n\n  /** The first child of this route in the router state tree */\n  get firstChild(): ActivatedRouteSnapshot|null {\n    return this._routerState.firstChild(this);\n  }\n\n  /** The children of this route in the router state tree */\n  get children(): ActivatedRouteSnapshot[] {\n    return this._routerState.children(this);\n  }\n\n  /** The path from the root of the router state tree to this route */\n  get pathFromRoot(): ActivatedRouteSnapshot[] {\n    return this._routerState.pathFromRoot(this);\n  }\n\n  get paramMap(): ParamMap {\n    if (!this._paramMap) {\n      this._paramMap = convertToParamMap(this.params);\n    }\n    return this._paramMap;\n  }\n\n  get queryParamMap(): ParamMap {\n    if (!this._queryParamMap) {\n      this._queryParamMap = convertToParamMap(this.queryParams);\n    }\n    return this._queryParamMap;\n  }\n\n  toString(): string {\n    const url = this.url.map(segment => segment.toString()).join('/');\n    const matched = this.routeConfig ? this.routeConfig.path : '';\n    return `Route(url:'${url}', path:'${matched}')`;\n  }\n}\n\n/**\n * @description\n *\n * Represents the state of the router at a moment in time.\n *\n * This is a tree of activated route snapshots. Every node in this tree knows about\n * the \"consumed\" URL segments, the extracted parameters, and the resolved data.\n *\n * The following example shows how a component is initialized with information\n * from the snapshot of the root node's state at the time of creation.\n *\n * ```\n * @Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const state: RouterState = router.routerState;\n *     const snapshot: RouterStateSnapshot = state.snapshot;\n *     const root: ActivatedRouteSnapshot = snapshot.root;\n *     const child = root.firstChild;\n *     const id: Observable<string> = child.params.map(p => p.id);\n *     //...\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nexport class RouterStateSnapshot extends Tree<ActivatedRouteSnapshot> {\n  /** @internal */\n  constructor(\n      /** The url from which this snapshot was created */\n      public url: string, root: TreeNode<ActivatedRouteSnapshot>) {\n    super(root);\n    setRouterState(<RouterStateSnapshot>this, root);\n  }\n\n  override toString(): string {\n    return serializeNode(this._root);\n  }\n}\n\nfunction setRouterState<U, T extends {_routerState: U}>(state: U, node: TreeNode<T>): void {\n  node.value._routerState = state;\n  node.children.forEach(c => setRouterState(state, c));\n}\n\nfunction serializeNode(node: TreeNode<ActivatedRouteSnapshot>): string {\n  const c = node.children.length > 0 ? ` { ${node.children.map(serializeNode).join(', ')} } ` : '';\n  return `${node.value}${c}`;\n}\n\n/**\n * The expectation is that the activate route is created with the right set of parameters.\n * So we push new values into the observables only when they are not the initial values.\n * And we detect that by checking if the snapshot field is set.\n */\nexport function advanceActivatedRoute(route: ActivatedRoute): void {\n  if (route.snapshot) {\n    const currentSnapshot = route.snapshot;\n    const nextSnapshot = route._futureSnapshot;\n    route.snapshot = nextSnapshot;\n    if (!shallowEqual(currentSnapshot.queryParams, nextSnapshot.queryParams)) {\n      route.queryParamsSubject.next(nextSnapshot.queryParams);\n    }\n    if (currentSnapshot.fragment !== nextSnapshot.fragment) {\n      route.fragmentSubject.next(nextSnapshot.fragment);\n    }\n    if (!shallowEqual(currentSnapshot.params, nextSnapshot.params)) {\n      route.paramsSubject.next(nextSnapshot.params);\n    }\n    if (!shallowEqualArrays(currentSnapshot.url, nextSnapshot.url)) {\n      route.urlSubject.next(nextSnapshot.url);\n    }\n    if (!shallowEqual(currentSnapshot.data, nextSnapshot.data)) {\n      route.dataSubject.next(nextSnapshot.data);\n    }\n  } else {\n    route.snapshot = route._futureSnapshot;\n\n    // this is for resolved data\n    route.dataSubject.next(route._futureSnapshot.data);\n  }\n}\n\n\nexport function equalParamsAndUrlSegments(\n    a: ActivatedRouteSnapshot, b: ActivatedRouteSnapshot): boolean {\n  const equalUrlParams = shallowEqual(a.params, b.params) && equalSegments(a.url, b.url);\n  const parentsMismatch = !a.parent !== !b.parent;\n\n  return equalUrlParams && !parentsMismatch &&\n      (!a.parent || equalParamsAndUrlSegments(a.parent, b.parent!));\n}\n\nexport function hasStaticTitle(config: Route) {\n  return typeof config.title === 'string' || config.title === null;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ChangeDetectorRef, ComponentRef, Directive, EnvironmentInjector, EventEmitter, inject, Injectable, InjectionToken, Injector, Input, OnDestroy, OnInit, Output, reflectComponentType, SimpleChanges, ViewContainerRef, ɵRuntimeError as RuntimeError,} from '@angular/core';\nimport {combineLatest, of, Subscription} from 'rxjs';\nimport {switchMap} from 'rxjs/operators';\n\nimport {RuntimeErrorCode} from '../errors';\nimport {Data} from '../models';\nimport {ChildrenOutletContexts} from '../router_outlet_context';\nimport {ActivatedRoute} from '../router_state';\nimport {PRIMARY_OUTLET} from '../shared';\n\n\n/**\n * An interface that defines the contract for developing a component outlet for the `Router`.\n *\n * An outlet acts as a placeholder that Angular dynamically fills based on the current router state.\n *\n * A router outlet should register itself with the `Router` via\n * `ChildrenOutletContexts#onChildOutletCreated` and unregister with\n * `ChildrenOutletContexts#onChildOutletDestroyed`. When the `Router` identifies a matched `Route`,\n * it looks for a registered outlet in the `ChildrenOutletContexts` and activates it.\n *\n * @see {@link ChildrenOutletContexts}\n * @publicApi\n */\nexport interface RouterOutletContract {\n  /**\n   * Whether the given outlet is activated.\n   *\n   * An outlet is considered \"activated\" if it has an active component.\n   */\n  isActivated: boolean;\n\n  /** The instance of the activated component or `null` if the outlet is not activated. */\n  component: Object|null;\n\n  /**\n   * The `Data` of the `ActivatedRoute` snapshot.\n   */\n  activatedRouteData: Data;\n\n  /**\n   * The `ActivatedRoute` for the outlet or `null` if the outlet is not activated.\n   */\n  activatedRoute: ActivatedRoute|null;\n\n  /**\n   * Called by the `Router` when the outlet should activate (create a component).\n   */\n  activateWith(activatedRoute: ActivatedRoute, environmentInjector: EnvironmentInjector|null): void;\n\n  /**\n   * A request to destroy the currently activated component.\n   *\n   * When a `RouteReuseStrategy` indicates that an `ActivatedRoute` should be removed but stored for\n   * later re-use rather than destroyed, the `Router` will call `detach` instead.\n   */\n  deactivate(): void;\n\n  /**\n   * Called when the `RouteReuseStrategy` instructs to detach the subtree.\n   *\n   * This is similar to `deactivate`, but the activated component should _not_ be destroyed.\n   * Instead, it is returned so that it can be reattached later via the `attach` method.\n   */\n  detach(): ComponentRef<unknown>;\n\n  /**\n   * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree.\n   */\n  attach(ref: ComponentRef<unknown>, activatedRoute: ActivatedRoute): void;\n\n  /**\n   * Emits an activate event when a new component is instantiated\n   **/\n  activateEvents?: EventEmitter<unknown>;\n\n  /**\n   * Emits a deactivate event when a component is destroyed.\n   */\n  deactivateEvents?: EventEmitter<unknown>;\n\n  /**\n   * Emits an attached component instance when the `RouteReuseStrategy` instructs to re-attach a\n   * previously detached subtree.\n   **/\n  attachEvents?: EventEmitter<unknown>;\n\n  /**\n   * Emits a detached component instance when the `RouteReuseStrategy` instructs to detach the\n   * subtree.\n   */\n  detachEvents?: EventEmitter<unknown>;\n\n  /**\n   * Used to indicate that the outlet is able to bind data from the `Router` to the outlet\n   * component's inputs.\n   *\n   * When this is `undefined` or `false` and the developer has opted in to the\n   * feature using `withComponentInputBinding`, a warning will be logged in dev mode if this outlet\n   * is used in the application.\n   */\n  readonly supportsBindingToComponentInputs?: true;\n}\n\n/**\n * @description\n *\n * Acts as a placeholder that Angular dynamically fills based on the current router state.\n *\n * Each outlet can have a unique name, determined by the optional `name` attribute.\n * The name cannot be set or changed dynamically. If not set, default value is \"primary\".\n *\n * ```\n * <router-outlet></router-outlet>\n * <router-outlet name='left'></router-outlet>\n * <router-outlet name='right'></router-outlet>\n * ```\n *\n * Named outlets can be the targets of secondary routes.\n * The `Route` object for a secondary route has an `outlet` property to identify the target outlet:\n *\n * `{path: <base-path>, component: <component>, outlet: <target_outlet_name>}`\n *\n * Using named outlets and secondary routes, you can target multiple outlets in\n * the same `RouterLink` directive.\n *\n * The router keeps track of separate branches in a navigation tree for each named outlet and\n * generates a representation of that tree in the URL.\n * The URL for a secondary route uses the following syntax to specify both the primary and secondary\n * routes at the same time:\n *\n * `http://base-path/primary-route-path(outlet-name:route-path)`\n *\n * A router outlet emits an activate event when a new component is instantiated,\n * deactivate event when a component is destroyed.\n * An attached event emits when the `RouteReuseStrategy` instructs the outlet to reattach the\n * subtree, and the detached event emits when the `RouteReuseStrategy` instructs the outlet to\n * detach the subtree.\n *\n * ```\n * <router-outlet\n *   (activate)='onActivate($event)'\n *   (deactivate)='onDeactivate($event)'\n *   (attach)='onAttach($event)'\n *   (detach)='onDetach($event)'></router-outlet>\n * ```\n *\n * @see [Routing tutorial](guide/router-tutorial-toh#named-outlets \"Example of a named\n * outlet and secondary route configuration\").\n * @see {@link RouterLink}\n * @see {@link Route}\n * @ngModule RouterModule\n *\n * @publicApi\n */\n@Directive({\n  selector: 'router-outlet',\n  exportAs: 'outlet',\n  standalone: true,\n})\nexport class RouterOutlet implements OnDestroy, OnInit, RouterOutletContract {\n  private activated: ComponentRef<any>|null = null;\n  /** @internal */\n  get activatedComponentRef(): ComponentRef<any>|null {\n    return this.activated;\n  }\n  private _activatedRoute: ActivatedRoute|null = null;\n  /**\n   * The name of the outlet\n   *\n   * @see [named outlets](guide/router-tutorial-toh#displaying-multiple-routes-in-named-outlets)\n   */\n  @Input() name = PRIMARY_OUTLET;\n\n  @Output('activate') activateEvents = new EventEmitter<any>();\n  @Output('deactivate') deactivateEvents = new EventEmitter<any>();\n  /**\n   * Emits an attached component instance when the `RouteReuseStrategy` instructs to re-attach a\n   * previously detached subtree.\n   **/\n  @Output('attach') attachEvents = new EventEmitter<unknown>();\n  /**\n   * Emits a detached component instance when the `RouteReuseStrategy` instructs to detach the\n   * subtree.\n   */\n  @Output('detach') detachEvents = new EventEmitter<unknown>();\n\n  private parentContexts = inject(ChildrenOutletContexts);\n  private location = inject(ViewContainerRef);\n  private changeDetector = inject(ChangeDetectorRef);\n  private environmentInjector = inject(EnvironmentInjector);\n  private inputBinder = inject(INPUT_BINDER, {optional: true});\n  /** @nodoc */\n  readonly supportsBindingToComponentInputs = true;\n\n  /** @nodoc */\n  ngOnChanges(changes: SimpleChanges) {\n    if (changes['name']) {\n      const {firstChange, previousValue} = changes['name'];\n      if (firstChange) {\n        // The first change is handled by ngOnInit. Because ngOnChanges doesn't get called when no\n        // input is set at all, we need to centrally handle the first change there.\n        return;\n      }\n\n      // unregister with the old name\n      if (this.isTrackedInParentContexts(previousValue)) {\n        this.deactivate();\n        this.parentContexts.onChildOutletDestroyed(previousValue);\n      }\n      // register the new name\n      this.initializeOutletWithName();\n    }\n  }\n\n  /** @nodoc */\n  ngOnDestroy(): void {\n    // Ensure that the registered outlet is this one before removing it on the context.\n    if (this.isTrackedInParentContexts(this.name)) {\n      this.parentContexts.onChildOutletDestroyed(this.name);\n    }\n    this.inputBinder?.unsubscribeFromRouteData(this);\n  }\n\n  private isTrackedInParentContexts(outletName: string) {\n    return this.parentContexts.getContext(outletName)?.outlet === this;\n  }\n\n  /** @nodoc */\n  ngOnInit(): void {\n    this.initializeOutletWithName();\n  }\n\n  private initializeOutletWithName() {\n    this.parentContexts.onChildOutletCreated(this.name, this);\n    if (this.activated) {\n      return;\n    }\n\n    // If the outlet was not instantiated at the time the route got activated we need to populate\n    // the outlet when it is initialized (ie inside a NgIf)\n    const context = this.parentContexts.getContext(this.name);\n    if (context?.route) {\n      if (context.attachRef) {\n        // `attachRef` is populated when there is an existing component to mount\n        this.attach(context.attachRef, context.route);\n      } else {\n        // otherwise the component defined in the configuration is created\n        this.activateWith(context.route, context.injector);\n      }\n    }\n  }\n\n  get isActivated(): boolean {\n    return !!this.activated;\n  }\n\n  /**\n   * @returns The currently activated component instance.\n   * @throws An error if the outlet is not activated.\n   */\n  get component(): Object {\n    if (!this.activated)\n      throw new RuntimeError(\n          RuntimeErrorCode.OUTLET_NOT_ACTIVATED,\n          (typeof ngDevMode === 'undefined' || ngDevMode) && 'Outlet is not activated');\n    return this.activated.instance;\n  }\n\n  get activatedRoute(): ActivatedRoute {\n    if (!this.activated)\n      throw new RuntimeError(\n          RuntimeErrorCode.OUTLET_NOT_ACTIVATED,\n          (typeof ngDevMode === 'undefined' || ngDevMode) && 'Outlet is not activated');\n    return this._activatedRoute as ActivatedRoute;\n  }\n\n  get activatedRouteData(): Data {\n    if (this._activatedRoute) {\n      return this._activatedRoute.snapshot.data;\n    }\n    return {};\n  }\n\n  /**\n   * Called when the `RouteReuseStrategy` instructs to detach the subtree\n   */\n  detach(): ComponentRef<any> {\n    if (!this.activated)\n      throw new RuntimeError(\n          RuntimeErrorCode.OUTLET_NOT_ACTIVATED,\n          (typeof ngDevMode === 'undefined' || ngDevMode) && 'Outlet is not activated');\n    this.location.detach();\n    const cmp = this.activated;\n    this.activated = null;\n    this._activatedRoute = null;\n    this.detachEvents.emit(cmp.instance);\n    return cmp;\n  }\n\n  /**\n   * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree\n   */\n  attach(ref: ComponentRef<any>, activatedRoute: ActivatedRoute) {\n    this.activated = ref;\n    this._activatedRoute = activatedRoute;\n    this.location.insert(ref.hostView);\n    this.inputBinder?.bindActivatedRouteToOutletComponent(this);\n    this.attachEvents.emit(ref.instance);\n  }\n\n  deactivate(): void {\n    if (this.activated) {\n      const c = this.component;\n      this.activated.destroy();\n      this.activated = null;\n      this._activatedRoute = null;\n      this.deactivateEvents.emit(c);\n    }\n  }\n\n  activateWith(activatedRoute: ActivatedRoute, environmentInjector?: EnvironmentInjector|null) {\n    if (this.isActivated) {\n      throw new RuntimeError(\n          RuntimeErrorCode.OUTLET_ALREADY_ACTIVATED,\n          (typeof ngDevMode === 'undefined' || ngDevMode) &&\n              'Cannot activate an already activated outlet');\n    }\n    this._activatedRoute = activatedRoute;\n    const location = this.location;\n    const snapshot = activatedRoute.snapshot;\n    const component = snapshot.component!;\n    const childContexts = this.parentContexts.getOrCreateContext(this.name).children;\n    const injector = new OutletInjector(activatedRoute, childContexts, location.injector);\n\n    this.activated = location.createComponent(component, {\n      index: location.length,\n      injector,\n      environmentInjector: environmentInjector ?? this.environmentInjector\n    });\n    // Calling `markForCheck` to make sure we will run the change detection when the\n    // `RouterOutlet` is inside a `ChangeDetectionStrategy.OnPush` component.\n    this.changeDetector.markForCheck();\n    this.inputBinder?.bindActivatedRouteToOutletComponent(this);\n    this.activateEvents.emit(this.activated.instance);\n  }\n}\n\nclass OutletInjector implements Injector {\n  constructor(\n      private route: ActivatedRoute, private childContexts: ChildrenOutletContexts,\n      private parent: Injector) {}\n\n  get(token: any, notFoundValue?: any): any {\n    if (token === ActivatedRoute) {\n      return this.route;\n    }\n\n    if (token === ChildrenOutletContexts) {\n      return this.childContexts;\n    }\n\n    return this.parent.get(token, notFoundValue);\n  }\n}\n\nexport const INPUT_BINDER = new InjectionToken<RoutedComponentInputBinder>('');\n\n/**\n * Injectable used as a tree-shakable provider for opting in to binding router data to component\n * inputs.\n *\n * The RouterOutlet registers itself with this service when an `ActivatedRoute` is attached or\n * activated. When this happens, the service subscribes to the `ActivatedRoute` observables (params,\n * queryParams, data) and sets the inputs of the component using `ComponentRef.setInput`.\n * Importantly, when an input does not have an item in the route data with a matching key, this\n * input is set to `undefined`. If it were not done this way, the previous information would be\n * retained if the data got removed from the route (i.e. if a query parameter is removed).\n *\n * The `RouterOutlet` should unregister itself when destroyed via `unsubscribeFromRouteData` so that\n * the subscriptions are cleaned up.\n */\n@Injectable()\nexport class RoutedComponentInputBinder {\n  private outletDataSubscriptions = new Map<RouterOutlet, Subscription>;\n\n  bindActivatedRouteToOutletComponent(outlet: RouterOutlet) {\n    this.unsubscribeFromRouteData(outlet);\n    this.subscribeToRouteData(outlet);\n  }\n\n  unsubscribeFromRouteData(outlet: RouterOutlet) {\n    this.outletDataSubscriptions.get(outlet)?.unsubscribe();\n    this.outletDataSubscriptions.delete(outlet);\n  }\n\n  private subscribeToRouteData(outlet: RouterOutlet) {\n    const {activatedRoute} = outlet;\n    const dataSubscription =\n        combineLatest([\n          activatedRoute.queryParams,\n          activatedRoute.params,\n          activatedRoute.data,\n        ])\n            .pipe(switchMap(([queryParams, params, data], index) => {\n              data = {...queryParams, ...params, ...data};\n              // Get the first result from the data subscription synchronously so it's available to\n              // the component as soon as possible (and doesn't require a second change detection).\n              if (index === 0) {\n                return of(data);\n              }\n              // Promise.resolve is used to avoid synchronously writing the wrong data when\n              // two of the Observables in the `combineLatest` stream emit one after\n              // another.\n              return Promise.resolve(data);\n            }))\n            .subscribe(data => {\n              // Outlet may have been deactivated or changed names to be associated with a different\n              // route\n              if (!outlet.isActivated || !outlet.activatedComponentRef ||\n                  outlet.activatedRoute !== activatedRoute || activatedRoute.component === null) {\n                this.unsubscribeFromRouteData(outlet);\n                return;\n              }\n\n              const mirror = reflectComponentType(activatedRoute.component);\n              if (!mirror) {\n                this.unsubscribeFromRouteData(outlet);\n                return;\n              }\n\n              for (const {templateName} of mirror.inputs) {\n                outlet.activatedComponentRef.setInput(templateName, data[templateName]);\n              }\n            });\n\n    this.outletDataSubscriptions.set(outlet, dataSubscription);\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {BehaviorSubject} from 'rxjs';\n\nimport {DetachedRouteHandleInternal, RouteReuseStrategy} from './route_reuse_strategy';\nimport {ActivatedRoute, ActivatedRouteSnapshot, RouterState, RouterStateSnapshot} from './router_state';\nimport {TreeNode} from './utils/tree';\n\nexport function createRouterState(\n    routeReuseStrategy: RouteReuseStrategy, curr: RouterStateSnapshot,\n    prevState: RouterState): RouterState {\n  const root = createNode(routeReuseStrategy, curr._root, prevState ? prevState._root : undefined);\n  return new RouterState(root, curr);\n}\n\nfunction createNode(\n    routeReuseStrategy: RouteReuseStrategy, curr: TreeNode<ActivatedRouteSnapshot>,\n    prevState?: TreeNode<ActivatedRoute>): TreeNode<ActivatedRoute> {\n  // reuse an activated route that is currently displayed on the screen\n  if (prevState && routeReuseStrategy.shouldReuseRoute(curr.value, prevState.value.snapshot)) {\n    const value = prevState.value;\n    value._futureSnapshot = curr.value;\n    const children = createOrReuseChildren(routeReuseStrategy, curr, prevState);\n    return new TreeNode<ActivatedRoute>(value, children);\n  } else {\n    if (routeReuseStrategy.shouldAttach(curr.value)) {\n      // retrieve an activated route that is used to be displayed, but is not currently displayed\n      const detachedRouteHandle = routeReuseStrategy.retrieve(curr.value);\n      if (detachedRouteHandle !== null) {\n        const tree = (detachedRouteHandle as DetachedRouteHandleInternal).route;\n        tree.value._futureSnapshot = curr.value;\n        tree.children = curr.children.map(c => createNode(routeReuseStrategy, c));\n        return tree;\n      }\n    }\n\n    const value = createActivatedRoute(curr.value);\n    const children = curr.children.map(c => createNode(routeReuseStrategy, c));\n    return new TreeNode<ActivatedRoute>(value, children);\n  }\n}\n\nfunction createOrReuseChildren(\n    routeReuseStrategy: RouteReuseStrategy, curr: TreeNode<ActivatedRouteSnapshot>,\n    prevState: TreeNode<ActivatedRoute>) {\n  return curr.children.map(child => {\n    for (const p of prevState.children) {\n      if (routeReuseStrategy.shouldReuseRoute(child.value, p.value.snapshot)) {\n        return createNode(routeReuseStrategy, child, p);\n      }\n    }\n    return createNode(routeReuseStrategy, child);\n  });\n}\n\nfunction createActivatedRoute(c: ActivatedRouteSnapshot) {\n  return new ActivatedRoute(\n      new BehaviorSubject(c.url), new BehaviorSubject(c.params), new BehaviorSubject(c.queryParams),\n      new BehaviorSubject(c.fragment), new BehaviorSubject(c.data), c.outlet, c.component, c);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {NavigationCancellationCode} from './events';\nimport {NavigationBehaviorOptions} from './models';\nimport {isUrlTree, UrlSerializer, UrlTree} from './url_tree';\n\nexport const NAVIGATION_CANCELING_ERROR = 'ngNavigationCancelingError';\n\nexport type NavigationCancelingError =\n    Error&{[NAVIGATION_CANCELING_ERROR]: true, cancellationCode: NavigationCancellationCode};\nexport type RedirectingNavigationCancelingError = NavigationCancelingError&{\n  url: UrlTree;\n  navigationBehaviorOptions?: NavigationBehaviorOptions;\n  cancellationCode: NavigationCancellationCode.Redirect;\n};\n\nexport function redirectingNavigationError(\n    urlSerializer: UrlSerializer, redirect: UrlTree): RedirectingNavigationCancelingError {\n  const {redirectTo, navigationBehaviorOptions} =\n      isUrlTree(redirect) ? {redirectTo: redirect, navigationBehaviorOptions: undefined} : redirect;\n  const error =\n      navigationCancelingError(\n          ngDevMode && `Redirecting to \"${urlSerializer.serialize(redirectTo)}\"`,\n          NavigationCancellationCode.Redirect, redirect) as RedirectingNavigationCancelingError;\n  error.url = redirectTo;\n  error.navigationBehaviorOptions = navigationBehaviorOptions;\n  return error;\n}\n\nexport function navigationCancelingError(\n    message: string|null|false, code: NavigationCancellationCode, redirectUrl?: UrlTree) {\n  const error =\n      new Error('NavigationCancelingError: ' + (message || '')) as NavigationCancelingError;\n  error[NAVIGATION_CANCELING_ERROR] = true;\n  error.cancellationCode = code;\n  if (redirectUrl) {\n    (error as RedirectingNavigationCancelingError).url = redirectUrl;\n  }\n  return error;\n}\n\nexport function isRedirectingNavigationCancelingError(\n    error: unknown|\n    RedirectingNavigationCancelingError): error is RedirectingNavigationCancelingError {\n  return isNavigationCancelingError(error) && isUrlTree((error as any).url);\n}\nexport function isNavigationCancelingError(error: unknown): error is NavigationCancelingError {\n  return error && (error as any)[NAVIGATION_CANCELING_ERROR];\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Component} from '@angular/core';\n\nimport {RouterOutlet} from '../directives/router_outlet';\n\n/**\n * This component is used internally within the router to be a placeholder when an empty\n * router-outlet is needed. For example, with a config such as:\n *\n * `{path: 'parent', outlet: 'nav', children: [...]}`\n *\n * In order to render, there needs to be a component on this config, which will default\n * to this `EmptyOutletComponent`.\n */\n@Component({\n  template: `<router-outlet></router-outlet>`,\n  imports: [RouterOutlet],\n  standalone: true,\n})\nexport class ɵEmptyOutletComponent {\n}\n\nexport {ɵEmptyOutletComponent as EmptyOutletComponent};\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {createEnvironmentInjector, EnvironmentInjector, isStandalone, Type, ɵisNgModule as isNgModule, ɵRuntimeError as RuntimeError} from '@angular/core';\n\nimport {EmptyOutletComponent} from '../components/empty_outlet';\nimport {RuntimeErrorCode} from '../errors';\nimport {Route, Routes} from '../models';\nimport {ActivatedRouteSnapshot} from '../router_state';\nimport {PRIMARY_OUTLET} from '../shared';\n\n/**\n * Creates an `EnvironmentInjector` if the `Route` has providers and one does not already exist\n * and returns the injector. Otherwise, if the `Route` does not have `providers`, returns the\n * `currentInjector`.\n *\n * @param route The route that might have providers\n * @param currentInjector The parent injector of the `Route`\n */\nexport function getOrCreateRouteInjectorIfNeeded(\n    route: Route, currentInjector: EnvironmentInjector) {\n  if (route.providers && !route._injector) {\n    route._injector =\n        createEnvironmentInjector(route.providers, currentInjector, `Route: ${route.path}`);\n  }\n  return route._injector ?? currentInjector;\n}\n\nexport function getLoadedRoutes(route: Route): Route[]|undefined {\n  return route._loadedRoutes;\n}\n\nexport function getLoadedInjector(route: Route): EnvironmentInjector|undefined {\n  return route._loadedInjector;\n}\nexport function getLoadedComponent(route: Route): Type<unknown>|undefined {\n  return route._loadedComponent;\n}\n\nexport function getProvidersInjector(route: Route): EnvironmentInjector|undefined {\n  return route._injector;\n}\n\nexport function validateConfig(\n    config: Routes, parentPath: string = '', requireStandaloneComponents = false): void {\n  // forEach doesn't iterate undefined values\n  for (let i = 0; i < config.length; i++) {\n    const route: Route = config[i];\n    const fullPath: string = getFullPath(parentPath, route);\n    validateNode(route, fullPath, requireStandaloneComponents);\n  }\n}\n\nexport function assertStandalone(fullPath: string, component: Type<unknown>|undefined) {\n  if (component && isNgModule(component)) {\n    throw new RuntimeError(\n        RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n        `Invalid configuration of route '${\n            fullPath}'. You are using 'loadComponent' with a module, ` +\n            `but it must be used with standalone components. Use 'loadChildren' instead.`);\n  } else if (component && !isStandalone(component)) {\n    throw new RuntimeError(\n        RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n        `Invalid configuration of route '${fullPath}'. The component must be standalone.`);\n  }\n}\n\nfunction validateNode(route: Route, fullPath: string, requireStandaloneComponents: boolean): void {\n  if (typeof ngDevMode === 'undefined' || ngDevMode) {\n    if (!route) {\n      throw new RuntimeError(RuntimeErrorCode.INVALID_ROUTE_CONFIG, `\n      Invalid configuration of route '${fullPath}': Encountered undefined route.\n      The reason might be an extra comma.\n\n      Example:\n      const routes: Routes = [\n        { path: '', redirectTo: '/dashboard', pathMatch: 'full' },\n        { path: 'dashboard',  component: DashboardComponent },, << two commas\n        { path: 'detail/:id', component: HeroDetailComponent }\n      ];\n    `);\n    }\n    if (Array.isArray(route)) {\n      throw new RuntimeError(\n          RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n          `Invalid configuration of route '${fullPath}': Array cannot be specified`);\n    }\n    if (!route.redirectTo && !route.component && !route.loadComponent && !route.children &&\n        !route.loadChildren && (route.outlet && route.outlet !== PRIMARY_OUTLET)) {\n      throw new RuntimeError(\n          RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n          `Invalid configuration of route '${\n              fullPath}': a componentless route without children or loadChildren cannot have a named outlet set`);\n    }\n    if (route.redirectTo && route.children) {\n      throw new RuntimeError(\n          RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n          `Invalid configuration of route '${\n              fullPath}': redirectTo and children cannot be used together`);\n    }\n    if (route.redirectTo && route.loadChildren) {\n      throw new RuntimeError(\n          RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n          `Invalid configuration of route '${\n              fullPath}': redirectTo and loadChildren cannot be used together`);\n    }\n    if (route.children && route.loadChildren) {\n      throw new RuntimeError(\n          RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n          `Invalid configuration of route '${\n              fullPath}': children and loadChildren cannot be used together`);\n    }\n    if (route.redirectTo && (route.component || route.loadComponent)) {\n      throw new RuntimeError(\n          RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n          `Invalid configuration of route '${\n              fullPath}': redirectTo and component/loadComponent cannot be used together`);\n    }\n    if (route.component && route.loadComponent) {\n      throw new RuntimeError(\n          RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n          `Invalid configuration of route '${\n              fullPath}': component and loadComponent cannot be used together`);\n    }\n    if (route.redirectTo && route.canActivate) {\n      throw new RuntimeError(\n          RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n          `Invalid configuration of route '${\n              fullPath}': redirectTo and canActivate cannot be used together. Redirects happen before activation ` +\n              `so canActivate will never be executed.`);\n    }\n    if (route.path && route.matcher) {\n      throw new RuntimeError(\n          RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n          `Invalid configuration of route '${fullPath}': path and matcher cannot be used together`);\n    }\n    if (route.redirectTo === void 0 && !route.component && !route.loadComponent &&\n        !route.children && !route.loadChildren) {\n      throw new RuntimeError(\n          RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n          `Invalid configuration of route '${\n              fullPath}'. One of the following must be provided: component, loadComponent, redirectTo, children or loadChildren`);\n    }\n    if (route.path === void 0 && route.matcher === void 0) {\n      throw new RuntimeError(\n          RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n          `Invalid configuration of route '${\n              fullPath}': routes must have either a path or a matcher specified`);\n    }\n    if (typeof route.path === 'string' && route.path.charAt(0) === '/') {\n      throw new RuntimeError(\n          RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n          `Invalid configuration of route '${fullPath}': path cannot start with a slash`);\n    }\n    if (route.path === '' && route.redirectTo !== void 0 && route.pathMatch === void 0) {\n      const exp =\n          `The default value of 'pathMatch' is 'prefix', but often the intent is to use 'full'.`;\n      throw new RuntimeError(\n          RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n          `Invalid configuration of route '{path: \"${fullPath}\", redirectTo: \"${\n              route.redirectTo}\"}': please provide 'pathMatch'. ${exp}`);\n    }\n    if (requireStandaloneComponents) {\n      assertStandalone(fullPath, route.component);\n    }\n  }\n  if (route.children) {\n    validateConfig(route.children, fullPath, requireStandaloneComponents);\n  }\n}\n\nfunction getFullPath(parentPath: string, currentRoute: Route): string {\n  if (!currentRoute) {\n    return parentPath;\n  }\n  if (!parentPath && !currentRoute.path) {\n    return '';\n  } else if (parentPath && !currentRoute.path) {\n    return `${parentPath}/`;\n  } else if (!parentPath && currentRoute.path) {\n    return currentRoute.path;\n  } else {\n    return `${parentPath}/${currentRoute.path}`;\n  }\n}\n\n/**\n * Makes a copy of the config and adds any default required properties.\n */\nexport function standardizeConfig(r: Route): Route {\n  const children = r.children && r.children.map(standardizeConfig);\n  const c = children ? {...r, children} : {...r};\n  if ((!c.component && !c.loadComponent) && (children || c.loadChildren) &&\n      (c.outlet && c.outlet !== PRIMARY_OUTLET)) {\n    c.component = EmptyOutletComponent;\n  }\n  return c;\n}\n\n/** Returns the `route.outlet` or PRIMARY_OUTLET if none exists. */\nexport function getOutlet(route: Route): string {\n  return route.outlet || PRIMARY_OUTLET;\n}\n\n/**\n * Sorts the `routes` such that the ones with an outlet matching `outletName` come first.\n * The order of the configs is otherwise preserved.\n */\nexport function sortByMatchingOutlets(routes: Routes, outletName: string): Routes {\n  const sortedConfig = routes.filter(r => getOutlet(r) === outletName);\n  sortedConfig.push(...routes.filter(r => getOutlet(r) !== outletName));\n  return sortedConfig;\n}\n\n/**\n * Gets the first injector in the snapshot's parent tree.\n *\n * If the `Route` has a static list of providers, the returned injector will be the one created from\n * those. If it does not exist, the returned injector may come from the parents, which may be from a\n * loaded config or their static providers.\n *\n * Returns `null` if there is neither this nor any parents have a stored injector.\n *\n * Generally used for retrieving the injector to use for getting tokens for guards/resolvers and\n * also used for getting the correct injector to use for creating components.\n */\nexport function getClosestRouteInjector(snapshot: ActivatedRouteSnapshot): EnvironmentInjector|\n    null {\n  if (!snapshot) return null;\n\n  // If the current route has its own injector, which is created from the static providers on the\n  // route itself, we should use that. Otherwise, we start at the parent since we do not want to\n  // include the lazy loaded injector from this route.\n  if (snapshot.routeConfig?._injector) {\n    return snapshot.routeConfig._injector;\n  }\n\n  for (let s = snapshot.parent; s; s = s.parent) {\n    const route = s.routeConfig;\n    // Note that the order here is important. `_loadedInjector` stored on the route with\n    // `loadChildren: () => NgModule` so it applies to child routes with priority. The `_injector`\n    // is created from the static providers on that parent route, so it applies to the children as\n    // well, but only if there is no lazy loaded NgModuleRef injector.\n    if (route?._loadedInjector) return route._loadedInjector;\n    if (route?._injector) return route._injector;\n  }\n\n  return null;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {MonoTypeOperatorFunction} from 'rxjs';\nimport {map} from 'rxjs/operators';\n\nimport {ActivationEnd, ChildActivationEnd, Event} from '../events';\nimport {NavigationTransition} from '../navigation_transition';\nimport {DetachedRouteHandleInternal, RouteReuseStrategy} from '../route_reuse_strategy';\nimport {ChildrenOutletContexts} from '../router_outlet_context';\nimport {ActivatedRoute, advanceActivatedRoute, RouterState} from '../router_state';\nimport {getClosestRouteInjector} from '../utils/config';\nimport {nodeChildrenAsMap, TreeNode} from '../utils/tree';\n\nlet warnedAboutUnsupportedInputBinding = false;\n\nexport const activateRoutes =\n    (rootContexts: ChildrenOutletContexts, routeReuseStrategy: RouteReuseStrategy,\n     forwardEvent: (evt: Event) => void,\n     inputBindingEnabled: boolean): MonoTypeOperatorFunction<NavigationTransition> => map(t => {\n      new ActivateRoutes(\n          routeReuseStrategy, t.targetRouterState!, t.currentRouterState, forwardEvent,\n          inputBindingEnabled)\n          .activate(rootContexts);\n      return t;\n    });\n\nexport class ActivateRoutes {\n  constructor(\n      private routeReuseStrategy: RouteReuseStrategy, private futureState: RouterState,\n      private currState: RouterState, private forwardEvent: (evt: Event) => void,\n      private inputBindingEnabled: boolean) {}\n\n  activate(parentContexts: ChildrenOutletContexts): void {\n    const futureRoot = this.futureState._root;\n    const currRoot = this.currState ? this.currState._root : null;\n\n    this.deactivateChildRoutes(futureRoot, currRoot, parentContexts);\n    advanceActivatedRoute(this.futureState.root);\n    this.activateChildRoutes(futureRoot, currRoot, parentContexts);\n  }\n\n  // De-activate the child route that are not re-used for the future state\n  private deactivateChildRoutes(\n      futureNode: TreeNode<ActivatedRoute>, currNode: TreeNode<ActivatedRoute>|null,\n      contexts: ChildrenOutletContexts): void {\n    const children: {[outletName: string]: TreeNode<ActivatedRoute>} = nodeChildrenAsMap(currNode);\n\n    // Recurse on the routes active in the future state to de-activate deeper children\n    futureNode.children.forEach(futureChild => {\n      const childOutletName = futureChild.value.outlet;\n      this.deactivateRoutes(futureChild, children[childOutletName], contexts);\n      delete children[childOutletName];\n    });\n\n    // De-activate the routes that will not be re-used\n    Object.values(children).forEach((v: TreeNode<ActivatedRoute>) => {\n      this.deactivateRouteAndItsChildren(v, contexts);\n    });\n  }\n\n  private deactivateRoutes(\n      futureNode: TreeNode<ActivatedRoute>, currNode: TreeNode<ActivatedRoute>,\n      parentContext: ChildrenOutletContexts): void {\n    const future = futureNode.value;\n    const curr = currNode ? currNode.value : null;\n\n    if (future === curr) {\n      // Reusing the node, check to see if the children need to be de-activated\n      if (future.component) {\n        // If we have a normal route, we need to go through an outlet.\n        const context = parentContext.getContext(future.outlet);\n        if (context) {\n          this.deactivateChildRoutes(futureNode, currNode, context.children);\n        }\n      } else {\n        // if we have a componentless route, we recurse but keep the same outlet map.\n        this.deactivateChildRoutes(futureNode, currNode, parentContext);\n      }\n    } else {\n      if (curr) {\n        // Deactivate the current route which will not be re-used\n        this.deactivateRouteAndItsChildren(currNode, parentContext);\n      }\n    }\n  }\n\n  private deactivateRouteAndItsChildren(\n      route: TreeNode<ActivatedRoute>, parentContexts: ChildrenOutletContexts): void {\n    // If there is no component, the Route is never attached to an outlet (because there is no\n    // component to attach).\n    if (route.value.component && this.routeReuseStrategy.shouldDetach(route.value.snapshot)) {\n      this.detachAndStoreRouteSubtree(route, parentContexts);\n    } else {\n      this.deactivateRouteAndOutlet(route, parentContexts);\n    }\n  }\n\n  private detachAndStoreRouteSubtree(\n      route: TreeNode<ActivatedRoute>, parentContexts: ChildrenOutletContexts): void {\n    const context = parentContexts.getContext(route.value.outlet);\n    const contexts = context && route.value.component ? context.children : parentContexts;\n    const children: {[outletName: string]: TreeNode<ActivatedRoute>} = nodeChildrenAsMap(route);\n\n    for (const childOutlet of Object.keys(children)) {\n      this.deactivateRouteAndItsChildren(children[childOutlet], contexts);\n    }\n\n    if (context && context.outlet) {\n      const componentRef = context.outlet.detach();\n      const contexts = context.children.onOutletDeactivated();\n      this.routeReuseStrategy.store(route.value.snapshot, {componentRef, route, contexts});\n    }\n  }\n\n  private deactivateRouteAndOutlet(\n      route: TreeNode<ActivatedRoute>, parentContexts: ChildrenOutletContexts): void {\n    const context = parentContexts.getContext(route.value.outlet);\n    // The context could be `null` if we are on a componentless route but there may still be\n    // children that need deactivating.\n    const contexts = context && route.value.component ? context.children : parentContexts;\n    const children: {[outletName: string]: TreeNode<ActivatedRoute>} = nodeChildrenAsMap(route);\n\n    for (const childOutlet of Object.keys(children)) {\n      this.deactivateRouteAndItsChildren(children[childOutlet], contexts);\n    }\n\n    if (context) {\n      if (context.outlet) {\n        // Destroy the component\n        context.outlet.deactivate();\n        // Destroy the contexts for all the outlets that were in the component\n        context.children.onOutletDeactivated();\n      }\n      // Clear the information about the attached component on the context but keep the reference to\n      // the outlet. Clear even if outlet was not yet activated to avoid activating later with old\n      // info\n      context.attachRef = null;\n      context.route = null;\n    }\n  }\n\n  private activateChildRoutes(\n      futureNode: TreeNode<ActivatedRoute>, currNode: TreeNode<ActivatedRoute>|null,\n      contexts: ChildrenOutletContexts): void {\n    const children: {[outlet: string]: TreeNode<ActivatedRoute>} = nodeChildrenAsMap(currNode);\n    futureNode.children.forEach(c => {\n      this.activateRoutes(c, children[c.value.outlet], contexts);\n      this.forwardEvent(new ActivationEnd(c.value.snapshot));\n    });\n    if (futureNode.children.length) {\n      this.forwardEvent(new ChildActivationEnd(futureNode.value.snapshot));\n    }\n  }\n\n  private activateRoutes(\n      futureNode: TreeNode<ActivatedRoute>, currNode: TreeNode<ActivatedRoute>,\n      parentContexts: ChildrenOutletContexts): void {\n    const future = futureNode.value;\n    const curr = currNode ? currNode.value : null;\n\n    advanceActivatedRoute(future);\n\n    // reusing the node\n    if (future === curr) {\n      if (future.component) {\n        // If we have a normal route, we need to go through an outlet.\n        const context = parentContexts.getOrCreateContext(future.outlet);\n        this.activateChildRoutes(futureNode, currNode, context.children);\n      } else {\n        // if we have a componentless route, we recurse but keep the same outlet map.\n        this.activateChildRoutes(futureNode, currNode, parentContexts);\n      }\n    } else {\n      if (future.component) {\n        // if we have a normal route, we need to place the component into the outlet and recurse.\n        const context = parentContexts.getOrCreateContext(future.outlet);\n\n        if (this.routeReuseStrategy.shouldAttach(future.snapshot)) {\n          const stored =\n              (<DetachedRouteHandleInternal>this.routeReuseStrategy.retrieve(future.snapshot));\n          this.routeReuseStrategy.store(future.snapshot, null);\n          context.children.onOutletReAttached(stored.contexts);\n          context.attachRef = stored.componentRef;\n          context.route = stored.route.value;\n          if (context.outlet) {\n            // Attach right away when the outlet has already been instantiated\n            // Otherwise attach from `RouterOutlet.ngOnInit` when it is instantiated\n            context.outlet.attach(stored.componentRef, stored.route.value);\n          }\n\n          advanceActivatedRoute(stored.route.value);\n          this.activateChildRoutes(futureNode, null, context.children);\n        } else {\n          const injector = getClosestRouteInjector(future.snapshot);\n          context.attachRef = null;\n          context.route = future;\n          context.injector = injector;\n          if (context.outlet) {\n            // Activate the outlet when it has already been instantiated\n            // Otherwise it will get activated from its `ngOnInit` when instantiated\n            context.outlet.activateWith(future, context.injector);\n          }\n\n          this.activateChildRoutes(futureNode, null, context.children);\n        }\n      } else {\n        // if we have a componentless route, we recurse but keep the same outlet map.\n        this.activateChildRoutes(futureNode, null, parentContexts);\n      }\n    }\n    if ((typeof ngDevMode === 'undefined' || ngDevMode)) {\n      const context = parentContexts.getOrCreateContext(future.outlet);\n      const outlet = context.outlet;\n      if (outlet && this.inputBindingEnabled && !outlet.supportsBindingToComponentInputs &&\n          !warnedAboutUnsupportedInputBinding) {\n        console.warn(\n            `'withComponentInputBinding' feature is enabled but ` +\n            `this application is using an outlet that may not support binding to component inputs.`);\n        warnedAboutUnsupportedInputBinding = true;\n      }\n    }\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injector, ProviderToken, ɵisInjectable as isInjectable} from '@angular/core';\n\nimport {RunGuardsAndResolvers} from '../models';\nimport {ChildrenOutletContexts, OutletContext} from '../router_outlet_context';\nimport {ActivatedRouteSnapshot, equalParamsAndUrlSegments, RouterStateSnapshot} from '../router_state';\nimport {equalPath} from '../url_tree';\nimport {shallowEqual} from '../utils/collection';\nimport {nodeChildrenAsMap, TreeNode} from '../utils/tree';\n\nexport class CanActivate {\n  readonly route: ActivatedRouteSnapshot;\n  constructor(public path: ActivatedRouteSnapshot[]) {\n    this.route = this.path[this.path.length - 1];\n  }\n}\n\nexport class CanDeactivate {\n  constructor(public component: Object|null, public route: ActivatedRouteSnapshot) {}\n}\n\nexport declare type Checks = {\n  canDeactivateChecks: CanDeactivate[],\n  canActivateChecks: CanActivate[],\n};\n\nexport function getAllRouteGuards(\n    future: RouterStateSnapshot, curr: RouterStateSnapshot,\n    parentContexts: ChildrenOutletContexts) {\n  const futureRoot = future._root;\n  const currRoot = curr ? curr._root : null;\n\n  return getChildRouteGuards(futureRoot, currRoot, parentContexts, [futureRoot.value]);\n}\n\nexport function getCanActivateChild(p: ActivatedRouteSnapshot):\n    {node: ActivatedRouteSnapshot, guards: any[]}|null {\n  const canActivateChild = p.routeConfig ? p.routeConfig.canActivateChild : null;\n  if (!canActivateChild || canActivateChild.length === 0) return null;\n  return {node: p, guards: canActivateChild};\n}\n\nexport function getTokenOrFunctionIdentity<T>(\n    tokenOrFunction: Function|ProviderToken<T>, injector: Injector): Function|T {\n  const NOT_FOUND = Symbol();\n  const result = injector.get<T|Symbol>(tokenOrFunction, NOT_FOUND);\n  if (result === NOT_FOUND) {\n    if (typeof tokenOrFunction === 'function' && !isInjectable(tokenOrFunction)) {\n      // We think the token is just a function so return it as-is\n      return tokenOrFunction;\n    } else {\n      // This will throw the not found error\n      return injector.get<T>(tokenOrFunction);\n    }\n  }\n  return result as T;\n}\n\nfunction getChildRouteGuards(\n    futureNode: TreeNode<ActivatedRouteSnapshot>, currNode: TreeNode<ActivatedRouteSnapshot>|null,\n    contexts: ChildrenOutletContexts|null, futurePath: ActivatedRouteSnapshot[], checks: Checks = {\n      canDeactivateChecks: [],\n      canActivateChecks: []\n    }): Checks {\n  const prevChildren = nodeChildrenAsMap(currNode);\n\n  // Process the children of the future route\n  futureNode.children.forEach(c => {\n    getRouteGuards(c, prevChildren[c.value.outlet], contexts, futurePath.concat([c.value]), checks);\n    delete prevChildren[c.value.outlet];\n  });\n\n  // Process any children left from the current route (not active for the future route)\n  Object.entries(prevChildren)\n      .forEach(\n          ([k, v]: [string, TreeNode<ActivatedRouteSnapshot>]) =>\n              deactivateRouteAndItsChildren(v, contexts!.getContext(k), checks));\n\n  return checks;\n}\n\nfunction getRouteGuards(\n    futureNode: TreeNode<ActivatedRouteSnapshot>, currNode: TreeNode<ActivatedRouteSnapshot>,\n    parentContexts: ChildrenOutletContexts|null, futurePath: ActivatedRouteSnapshot[],\n    checks: Checks = {\n      canDeactivateChecks: [],\n      canActivateChecks: []\n    }): Checks {\n  const future = futureNode.value;\n  const curr = currNode ? currNode.value : null;\n  const context = parentContexts ? parentContexts.getContext(futureNode.value.outlet) : null;\n\n  // reusing the node\n  if (curr && future.routeConfig === curr.routeConfig) {\n    const shouldRun =\n        shouldRunGuardsAndResolvers(curr, future, future.routeConfig!.runGuardsAndResolvers);\n    if (shouldRun) {\n      checks.canActivateChecks.push(new CanActivate(futurePath));\n    } else {\n      // we need to set the data\n      future.data = curr.data;\n      future._resolvedData = curr._resolvedData;\n    }\n\n    // If we have a component, we need to go through an outlet.\n    if (future.component) {\n      getChildRouteGuards(\n          futureNode, currNode, context ? context.children : null, futurePath, checks);\n\n      // if we have a componentless route, we recurse but keep the same outlet map.\n    } else {\n      getChildRouteGuards(futureNode, currNode, parentContexts, futurePath, checks);\n    }\n\n    if (shouldRun && context && context.outlet && context.outlet.isActivated) {\n      checks.canDeactivateChecks.push(new CanDeactivate(context.outlet.component, curr));\n    }\n  } else {\n    if (curr) {\n      deactivateRouteAndItsChildren(currNode, context, checks);\n    }\n\n    checks.canActivateChecks.push(new CanActivate(futurePath));\n    // If we have a component, we need to go through an outlet.\n    if (future.component) {\n      getChildRouteGuards(futureNode, null, context ? context.children : null, futurePath, checks);\n\n      // if we have a componentless route, we recurse but keep the same outlet map.\n    } else {\n      getChildRouteGuards(futureNode, null, parentContexts, futurePath, checks);\n    }\n  }\n\n  return checks;\n}\n\nfunction shouldRunGuardsAndResolvers(\n    curr: ActivatedRouteSnapshot, future: ActivatedRouteSnapshot,\n    mode: RunGuardsAndResolvers|undefined): boolean {\n  if (typeof mode === 'function') {\n    return mode(curr, future);\n  }\n  switch (mode) {\n    case 'pathParamsChange':\n      return !equalPath(curr.url, future.url);\n\n    case 'pathParamsOrQueryParamsChange':\n      return !equalPath(curr.url, future.url) ||\n          !shallowEqual(curr.queryParams, future.queryParams);\n\n    case 'always':\n      return true;\n\n    case 'paramsOrQueryParamsChange':\n      return !equalParamsAndUrlSegments(curr, future) ||\n          !shallowEqual(curr.queryParams, future.queryParams);\n\n    case 'paramsChange':\n    default:\n      return !equalParamsAndUrlSegments(curr, future);\n  }\n}\n\nfunction deactivateRouteAndItsChildren(\n    route: TreeNode<ActivatedRouteSnapshot>, context: OutletContext|null, checks: Checks): void {\n  const children = nodeChildrenAsMap(route);\n  const r = route.value;\n\n  Object.entries(children).forEach(([childName, node]) => {\n    if (!r.component) {\n      deactivateRouteAndItsChildren(node, context, checks);\n    } else if (context) {\n      deactivateRouteAndItsChildren(node, context.children.getContext(childName), checks);\n    } else {\n      deactivateRouteAndItsChildren(node, null, checks);\n    }\n  });\n\n  if (!r.component) {\n    checks.canDeactivateChecks.push(new CanDeactivate(null, r));\n  } else if (context && context.outlet && context.outlet.isActivated) {\n    checks.canDeactivateChecks.push(new CanDeactivate(context.outlet.component, r));\n  } else {\n    checks.canDeactivateChecks.push(new CanDeactivate(null, r));\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {EmptyError} from 'rxjs';\n\nimport {CanActivateChildFn, CanActivateFn, CanDeactivateFn, CanLoadFn, CanMatchFn} from '../models';\nimport {NAVIGATION_CANCELING_ERROR, NavigationCancelingError, RedirectingNavigationCancelingError} from '../navigation_canceling_error';\nimport {isUrlTree} from '../url_tree';\n\n/**\n * Simple function check, but generic so type inference will flow. Example:\n *\n * function product(a: number, b: number) {\n *   return a * b;\n * }\n *\n * if (isFunction<product>(fn)) {\n *   return fn(1, 2);\n * } else {\n *   throw \"Must provide the `product` function\";\n * }\n */\nexport function isFunction<T>(v: any): v is T {\n  return typeof v === 'function';\n}\n\nexport function isBoolean(v: any): v is boolean {\n  return typeof v === 'boolean';\n}\n\nexport function isCanLoad(guard: any): guard is {canLoad: CanLoadFn} {\n  return guard && isFunction<CanLoadFn>(guard.canLoad);\n}\n\nexport function isCanActivate(guard: any): guard is {canActivate: CanActivateFn} {\n  return guard && isFunction<CanActivateFn>(guard.canActivate);\n}\n\nexport function isCanActivateChild(guard: any): guard is {canActivateChild: CanActivateChildFn} {\n  return guard && isFunction<CanActivateChildFn>(guard.canActivateChild);\n}\n\nexport function isCanDeactivate<T>(guard: any): guard is {canDeactivate: CanDeactivateFn<T>} {\n  return guard && isFunction<CanDeactivateFn<T>>(guard.canDeactivate);\n}\nexport function isCanMatch(guard: any): guard is {canMatch: CanMatchFn} {\n  return guard && isFunction<CanMatchFn>(guard.canMatch);\n}\n\nexport function isRedirectingNavigationCancelingError(\n    error: unknown|\n    RedirectingNavigationCancelingError): error is RedirectingNavigationCancelingError {\n  return isNavigationCancelingError(error) && isUrlTree((error as any).url);\n}\n\nexport function isNavigationCancelingError(error: unknown): error is NavigationCancelingError {\n  return error && (error as any)[NAVIGATION_CANCELING_ERROR];\n}\n\nexport function isEmptyError(e: Error): e is EmptyError {\n  return e instanceof EmptyError || e?.name === 'EmptyError';\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {combineLatest, Observable, OperatorFunction} from 'rxjs';\nimport {filter, map, startWith, switchMap, take} from 'rxjs/operators';\n\nimport {UrlTree} from '../url_tree';\n\nconst INITIAL_VALUE = /* @__PURE__ */ Symbol('INITIAL_VALUE');\ndeclare type INTERIM_VALUES = typeof INITIAL_VALUE | boolean | UrlTree;\n\nexport function prioritizedGuardValue():\n    OperatorFunction<Observable<boolean|UrlTree>[], boolean|UrlTree> {\n  return switchMap(obs => {\n    return combineLatest(obs.map(o => o.pipe(take(1), startWith(INITIAL_VALUE as INTERIM_VALUES))))\n        .pipe(\n            map((results: INTERIM_VALUES[]) => {\n              for (const result of results) {\n                if (result === true) {\n                  // If result is true, check the next one\n                  continue;\n                } else if (result === INITIAL_VALUE) {\n                  // If guard has not finished, we need to stop processing.\n                  return INITIAL_VALUE;\n                } else if (result === false || result instanceof UrlTree) {\n                  // Result finished and was not true. Return the result.\n                  // Note that we only allow false/UrlTree. Other values are considered invalid and\n                  // ignored.\n                  return result;\n                }\n              }\n              // Everything resolved to true. Return true.\n              return true;\n            }),\n            filter((item): item is boolean|UrlTree => item !== INITIAL_VALUE),\n            take(1),\n        );\n  });\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {EnvironmentInjector, ProviderToken} from '@angular/core';\nimport {concat, defer, from, MonoTypeOperatorFunction, Observable, of, OperatorFunction, pipe} from 'rxjs';\nimport {concatMap, first, map, mergeMap, tap} from 'rxjs/operators';\n\nimport {ActivationStart, ChildActivationStart, Event} from '../events';\nimport {CanActivateChildFn, CanActivateFn, CanDeactivateFn, CanLoadFn, CanMatchFn, Route} from '../models';\nimport {redirectingNavigationError} from '../navigation_canceling_error';\nimport {NavigationTransition} from '../navigation_transition';\nimport {ActivatedRouteSnapshot, RouterStateSnapshot} from '../router_state';\nimport {isUrlTree, UrlSegment, UrlSerializer, UrlTree} from '../url_tree';\nimport {wrapIntoObservable} from '../utils/collection';\nimport {getClosestRouteInjector} from '../utils/config';\nimport {CanActivate, CanDeactivate, getCanActivateChild, getTokenOrFunctionIdentity} from '../utils/preactivation';\nimport {isBoolean, isCanActivate, isCanActivateChild, isCanDeactivate, isCanLoad, isCanMatch} from '../utils/type_guards';\n\nimport {prioritizedGuardValue} from './prioritized_guard_value';\n\nexport function checkGuards(injector: EnvironmentInjector, forwardEvent?: (evt: Event) => void):\n    MonoTypeOperatorFunction<NavigationTransition> {\n  return mergeMap(t => {\n    const {targetSnapshot, currentSnapshot, guards: {canActivateChecks, canDeactivateChecks}} = t;\n    if (canDeactivateChecks.length === 0 && canActivateChecks.length === 0) {\n      return of({...t, guardsResult: true});\n    }\n\n    return runCanDeactivateChecks(canDeactivateChecks, targetSnapshot!, currentSnapshot, injector)\n        .pipe(\n            mergeMap(canDeactivate => {\n              return canDeactivate && isBoolean(canDeactivate) ?\n                  runCanActivateChecks(targetSnapshot!, canActivateChecks, injector, forwardEvent) :\n                  of(canDeactivate);\n            }),\n            map(guardsResult => ({...t, guardsResult})));\n  });\n}\n\nfunction runCanDeactivateChecks(\n    checks: CanDeactivate[], futureRSS: RouterStateSnapshot, currRSS: RouterStateSnapshot,\n    injector: EnvironmentInjector) {\n  return from(checks).pipe(\n      mergeMap(\n          check => runCanDeactivate(check.component, check.route, currRSS, futureRSS, injector)),\n      first(result => {\n        return result !== true;\n      }, true as boolean | UrlTree));\n}\n\nfunction runCanActivateChecks(\n    futureSnapshot: RouterStateSnapshot, checks: CanActivate[], injector: EnvironmentInjector,\n    forwardEvent?: (evt: Event) => void) {\n  return from(checks).pipe(\n      concatMap((check: CanActivate) => {\n        return concat(\n            fireChildActivationStart(check.route.parent, forwardEvent),\n            fireActivationStart(check.route, forwardEvent),\n            runCanActivateChild(futureSnapshot, check.path, injector),\n            runCanActivate(futureSnapshot, check.route, injector));\n      }),\n      first(result => {\n        return result !== true;\n      }, true as boolean | UrlTree));\n}\n\n/**\n * This should fire off `ActivationStart` events for each route being activated at this\n * level.\n * In other words, if you're activating `a` and `b` below, `path` will contain the\n * `ActivatedRouteSnapshot`s for both and we will fire `ActivationStart` for both. Always\n * return\n * `true` so checks continue to run.\n */\nfunction fireActivationStart(\n    snapshot: ActivatedRouteSnapshot|null,\n    forwardEvent?: (evt: Event) => void): Observable<boolean> {\n  if (snapshot !== null && forwardEvent) {\n    forwardEvent(new ActivationStart(snapshot));\n  }\n  return of(true);\n}\n\n/**\n * This should fire off `ChildActivationStart` events for each route being activated at this\n * level.\n * In other words, if you're activating `a` and `b` below, `path` will contain the\n * `ActivatedRouteSnapshot`s for both and we will fire `ChildActivationStart` for both. Always\n * return\n * `true` so checks continue to run.\n */\nfunction fireChildActivationStart(\n    snapshot: ActivatedRouteSnapshot|null,\n    forwardEvent?: (evt: Event) => void): Observable<boolean> {\n  if (snapshot !== null && forwardEvent) {\n    forwardEvent(new ChildActivationStart(snapshot));\n  }\n  return of(true);\n}\n\nfunction runCanActivate(\n    futureRSS: RouterStateSnapshot, futureARS: ActivatedRouteSnapshot,\n    injector: EnvironmentInjector): Observable<boolean|UrlTree> {\n  const canActivate = futureARS.routeConfig ? futureARS.routeConfig.canActivate : null;\n  if (!canActivate || canActivate.length === 0) return of(true);\n\n  const canActivateObservables =\n      canActivate.map((canActivate: CanActivateFn|ProviderToken<unknown>) => {\n        return defer(() => {\n          const closestInjector = getClosestRouteInjector(futureARS) ?? injector;\n          const guard = getTokenOrFunctionIdentity<CanActivate>(canActivate, closestInjector);\n          const guardVal = isCanActivate(guard) ?\n              guard.canActivate(futureARS, futureRSS) :\n              closestInjector.runInContext(() => (guard as CanActivateFn)(futureARS, futureRSS));\n          return wrapIntoObservable(guardVal).pipe(first());\n        });\n      });\n  return of(canActivateObservables).pipe(prioritizedGuardValue());\n}\n\nfunction runCanActivateChild(\n    futureRSS: RouterStateSnapshot, path: ActivatedRouteSnapshot[],\n    injector: EnvironmentInjector): Observable<boolean|UrlTree> {\n  const futureARS = path[path.length - 1];\n\n  const canActivateChildGuards = path.slice(0, path.length - 1)\n                                     .reverse()\n                                     .map(p => getCanActivateChild(p))\n                                     .filter(_ => _ !== null);\n\n  const canActivateChildGuardsMapped = canActivateChildGuards.map((d: any) => {\n    return defer(() => {\n      const guardsMapped =\n          d.guards.map((canActivateChild: CanActivateChildFn|ProviderToken<unknown>) => {\n            const closestInjector = getClosestRouteInjector(d.node) ?? injector;\n            const guard = getTokenOrFunctionIdentity<{canActivateChild: CanActivateChildFn}>(\n                canActivateChild, closestInjector);\n            const guardVal = isCanActivateChild(guard) ?\n                guard.canActivateChild(futureARS, futureRSS) :\n                closestInjector.runInContext(\n                    () => (guard as CanActivateChildFn)(futureARS, futureRSS));\n            return wrapIntoObservable(guardVal).pipe(first());\n          });\n      return of(guardsMapped).pipe(prioritizedGuardValue());\n    });\n  });\n  return of(canActivateChildGuardsMapped).pipe(prioritizedGuardValue());\n}\n\nfunction runCanDeactivate(\n    component: Object|null, currARS: ActivatedRouteSnapshot, currRSS: RouterStateSnapshot,\n    futureRSS: RouterStateSnapshot, injector: EnvironmentInjector): Observable<boolean|UrlTree> {\n  const canDeactivate = currARS && currARS.routeConfig ? currARS.routeConfig.canDeactivate : null;\n  if (!canDeactivate || canDeactivate.length === 0) return of(true);\n  const canDeactivateObservables = canDeactivate.map((c: any) => {\n    const closestInjector = getClosestRouteInjector(currARS) ?? injector;\n    const guard = getTokenOrFunctionIdentity<any>(c, closestInjector);\n    const guardVal = isCanDeactivate(guard) ?\n        guard.canDeactivate(component, currARS, currRSS, futureRSS) :\n        closestInjector.runInContext(\n            () => (guard as CanDeactivateFn<any>)(component, currARS, currRSS, futureRSS));\n    return wrapIntoObservable(guardVal).pipe(first());\n  });\n  return of(canDeactivateObservables).pipe(prioritizedGuardValue());\n}\n\nexport function runCanLoadGuards(\n    injector: EnvironmentInjector, route: Route, segments: UrlSegment[],\n    urlSerializer: UrlSerializer): Observable<boolean> {\n  const canLoad = route.canLoad;\n  if (canLoad === undefined || canLoad.length === 0) {\n    return of(true);\n  }\n\n  const canLoadObservables = canLoad.map((injectionToken: any) => {\n    const guard = getTokenOrFunctionIdentity<any>(injectionToken, injector);\n    const guardVal = isCanLoad(guard) ?\n        guard.canLoad(route, segments) :\n        injector.runInContext(() => (guard as CanLoadFn)(route, segments));\n    return wrapIntoObservable(guardVal);\n  });\n\n  return of(canLoadObservables)\n      .pipe(\n          prioritizedGuardValue(),\n          redirectIfUrlTree(urlSerializer),\n      );\n}\n\nfunction redirectIfUrlTree(urlSerializer: UrlSerializer):\n    OperatorFunction<UrlTree|boolean, boolean> {\n  return pipe(\n      tap((result: UrlTree|boolean) => {\n        if (!isUrlTree(result)) return;\n\n        throw redirectingNavigationError(urlSerializer, result);\n      }),\n      map(result => result === true),\n  );\n}\n\nexport function runCanMatchGuards(\n    injector: EnvironmentInjector, route: Route, segments: UrlSegment[],\n    urlSerializer: UrlSerializer): Observable<boolean> {\n  const canMatch = route.canMatch;\n  if (!canMatch || canMatch.length === 0) return of(true);\n\n  const canMatchObservables = canMatch.map(injectionToken => {\n    const guard = getTokenOrFunctionIdentity(injectionToken, injector);\n    const guardVal = isCanMatch(guard) ?\n        guard.canMatch(route, segments) :\n        injector.runInContext(() => (guard as CanMatchFn)(route, segments));\n    return wrapIntoObservable(guardVal);\n  });\n\n  return of(canMatchObservables)\n      .pipe(\n          prioritizedGuardValue(),\n          redirectIfUrlTree(urlSerializer),\n      );\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ɵRuntimeError as RuntimeError} from '@angular/core';\nimport {Observable, of, throwError} from 'rxjs';\n\nimport {RuntimeErrorCode} from './errors';\nimport {NavigationCancellationCode} from './events';\nimport {LoadedRouterConfig, Route} from './models';\nimport {navigationCancelingError} from './navigation_canceling_error';\nimport {Params, PRIMARY_OUTLET} from './shared';\nimport {UrlSegment, UrlSegmentGroup, UrlSerializer, UrlTree} from './url_tree';\n\n\nexport class NoMatch {\n  public segmentGroup: UrlSegmentGroup|null;\n\n  constructor(segmentGroup?: UrlSegmentGroup) {\n    this.segmentGroup = segmentGroup || null;\n  }\n}\n\nexport class AbsoluteRedirect extends Error {\n  constructor(public urlTree: UrlTree) {\n    super();\n  }\n}\n\nexport function noMatch(segmentGroup: UrlSegmentGroup): Observable<any> {\n  return throwError(new NoMatch(segmentGroup));\n}\n\nexport function absoluteRedirect(newTree: UrlTree): Observable<any> {\n  return throwError(new AbsoluteRedirect(newTree));\n}\n\nexport function namedOutletsRedirect(redirectTo: string): Observable<any> {\n  return throwError(new RuntimeError(\n      RuntimeErrorCode.NAMED_OUTLET_REDIRECT,\n      (typeof ngDevMode === 'undefined' || ngDevMode) &&\n          `Only absolute redirects can have named outlets. redirectTo: '${redirectTo}'`));\n}\n\nexport function canLoadFails(route: Route): Observable<LoadedRouterConfig> {\n  return throwError(navigationCancelingError(\n      (typeof ngDevMode === 'undefined' || ngDevMode) &&\n          `Cannot load children because the guard of the route \"path: '${\n              route.path}'\" returned false`,\n      NavigationCancellationCode.GuardRejected));\n}\n\n\nexport class ApplyRedirects {\n  constructor(private urlSerializer: UrlSerializer, private urlTree: UrlTree) {}\n\n  noMatchError(e: NoMatch): any {\n    return new RuntimeError(\n        RuntimeErrorCode.NO_MATCH,\n        (typeof ngDevMode === 'undefined' || ngDevMode) &&\n            `Cannot match any routes. URL Segment: '${e.segmentGroup}'`);\n  }\n\n  lineralizeSegments(route: Route, urlTree: UrlTree): Observable<UrlSegment[]> {\n    let res: UrlSegment[] = [];\n    let c = urlTree.root;\n    while (true) {\n      res = res.concat(c.segments);\n      if (c.numberOfChildren === 0) {\n        return of(res);\n      }\n\n      if (c.numberOfChildren > 1 || !c.children[PRIMARY_OUTLET]) {\n        return namedOutletsRedirect(route.redirectTo!);\n      }\n\n      c = c.children[PRIMARY_OUTLET];\n    }\n  }\n\n  applyRedirectCommands(\n      segments: UrlSegment[], redirectTo: string, posParams: {[k: string]: UrlSegment}): UrlTree {\n    const newTree = this.applyRedirectCreateUrlTree(\n        redirectTo, this.urlSerializer.parse(redirectTo), segments, posParams);\n    if (redirectTo.startsWith('/')) {\n      throw new AbsoluteRedirect(newTree);\n    }\n    return newTree;\n  }\n\n  applyRedirectCreateUrlTree(\n      redirectTo: string, urlTree: UrlTree, segments: UrlSegment[],\n      posParams: {[k: string]: UrlSegment}): UrlTree {\n    const newRoot = this.createSegmentGroup(redirectTo, urlTree.root, segments, posParams);\n    return new UrlTree(\n        newRoot, this.createQueryParams(urlTree.queryParams, this.urlTree.queryParams),\n        urlTree.fragment);\n  }\n\n  createQueryParams(redirectToParams: Params, actualParams: Params): Params {\n    const res: Params = {};\n    Object.entries(redirectToParams).forEach(([k, v]) => {\n      const copySourceValue = typeof v === 'string' && v.startsWith(':');\n      if (copySourceValue) {\n        const sourceName = v.substring(1);\n        res[k] = actualParams[sourceName];\n      } else {\n        res[k] = v;\n      }\n    });\n    return res;\n  }\n\n  createSegmentGroup(\n      redirectTo: string, group: UrlSegmentGroup, segments: UrlSegment[],\n      posParams: {[k: string]: UrlSegment}): UrlSegmentGroup {\n    const updatedSegments = this.createSegments(redirectTo, group.segments, segments, posParams);\n\n    let children: {[n: string]: UrlSegmentGroup} = {};\n    Object.entries(group.children).forEach(([name, child]) => {\n      children[name] = this.createSegmentGroup(redirectTo, child, segments, posParams);\n    });\n\n    return new UrlSegmentGroup(updatedSegments, children);\n  }\n\n  createSegments(\n      redirectTo: string, redirectToSegments: UrlSegment[], actualSegments: UrlSegment[],\n      posParams: {[k: string]: UrlSegment}): UrlSegment[] {\n    return redirectToSegments.map(\n        s => s.path.startsWith(':') ? this.findPosParam(redirectTo, s, posParams) :\n                                      this.findOrReturn(s, actualSegments));\n  }\n\n  findPosParam(\n      redirectTo: string, redirectToUrlSegment: UrlSegment,\n      posParams: {[k: string]: UrlSegment}): UrlSegment {\n    const pos = posParams[redirectToUrlSegment.path.substring(1)];\n    if (!pos)\n      throw new RuntimeError(\n          RuntimeErrorCode.MISSING_REDIRECT,\n          (typeof ngDevMode === 'undefined' || ngDevMode) &&\n              `Cannot redirect to '${redirectTo}'. Cannot find '${redirectToUrlSegment.path}'.`);\n    return pos;\n  }\n\n  findOrReturn(redirectToUrlSegment: UrlSegment, actualSegments: UrlSegment[]): UrlSegment {\n    let idx = 0;\n    for (const s of actualSegments) {\n      if (s.path === redirectToUrlSegment.path) {\n        actualSegments.splice(idx);\n        return s;\n      }\n      idx++;\n    }\n    return redirectToUrlSegment;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {EnvironmentInjector} from '@angular/core';\nimport {Observable, of} from 'rxjs';\nimport {map} from 'rxjs/operators';\n\nimport {Route} from '../models';\nimport {runCanMatchGuards} from '../operators/check_guards';\nimport {defaultUrlMatcher, PRIMARY_OUTLET} from '../shared';\nimport {UrlSegment, UrlSegmentGroup, UrlSerializer} from '../url_tree';\n\nimport {getOrCreateRouteInjectorIfNeeded, getOutlet} from './config';\n\nexport interface MatchResult {\n  matched: boolean;\n  consumedSegments: UrlSegment[];\n  remainingSegments: UrlSegment[];\n  parameters: {[k: string]: string};\n  positionalParamSegments: {[k: string]: UrlSegment};\n}\n\nconst noMatch: MatchResult = {\n  matched: false,\n  consumedSegments: [],\n  remainingSegments: [],\n  parameters: {},\n  positionalParamSegments: {}\n};\n\nexport function matchWithChecks(\n    segmentGroup: UrlSegmentGroup, route: Route, segments: UrlSegment[],\n    injector: EnvironmentInjector, urlSerializer: UrlSerializer): Observable<MatchResult> {\n  const result = match(segmentGroup, route, segments);\n  if (!result.matched) {\n    return of(result);\n  }\n\n  // Only create the Route's `EnvironmentInjector` if it matches the attempted\n  // navigation\n  injector = getOrCreateRouteInjectorIfNeeded(route, injector);\n  return runCanMatchGuards(injector, route, segments, urlSerializer)\n      .pipe(\n          map((v) => v === true ? result : {...noMatch}),\n      );\n}\n\nexport function match(\n    segmentGroup: UrlSegmentGroup, route: Route, segments: UrlSegment[]): MatchResult {\n  if (route.path === '') {\n    if (route.pathMatch === 'full' && (segmentGroup.hasChildren() || segments.length > 0)) {\n      return {...noMatch};\n    }\n\n    return {\n      matched: true,\n      consumedSegments: [],\n      remainingSegments: segments,\n      parameters: {},\n      positionalParamSegments: {}\n    };\n  }\n\n  const matcher = route.matcher || defaultUrlMatcher;\n  const res = matcher(segments, segmentGroup, route);\n  if (!res) return {...noMatch};\n\n  const posParams: {[n: string]: string} = {};\n  Object.entries(res.posParams ?? {}).forEach(([k, v]) => {\n    posParams[k] = v.path;\n  });\n  const parameters = res.consumed.length > 0 ?\n      {...posParams, ...res.consumed[res.consumed.length - 1].parameters} :\n      posParams;\n\n  return {\n    matched: true,\n    consumedSegments: res.consumed,\n    remainingSegments: segments.slice(res.consumed.length),\n    // TODO(atscott): investigate combining parameters and positionalParamSegments\n    parameters,\n    positionalParamSegments: res.posParams ?? {}\n  };\n}\n\nexport function split(\n    segmentGroup: UrlSegmentGroup, consumedSegments: UrlSegment[], slicedSegments: UrlSegment[],\n    config: Route[]) {\n  if (slicedSegments.length > 0 &&\n      containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, config)) {\n    const s = new UrlSegmentGroup(\n        consumedSegments,\n        createChildrenForEmptyPaths(\n            config, new UrlSegmentGroup(slicedSegments, segmentGroup.children)));\n    return {segmentGroup: s, slicedSegments: []};\n  }\n\n  if (slicedSegments.length === 0 &&\n      containsEmptyPathMatches(segmentGroup, slicedSegments, config)) {\n    const s = new UrlSegmentGroup(\n        segmentGroup.segments,\n        addEmptyPathsToChildrenIfNeeded(\n            segmentGroup, consumedSegments, slicedSegments, config, segmentGroup.children));\n    return {segmentGroup: s, slicedSegments};\n  }\n\n  const s = new UrlSegmentGroup(segmentGroup.segments, segmentGroup.children);\n  return {segmentGroup: s, slicedSegments};\n}\n\nfunction addEmptyPathsToChildrenIfNeeded(\n    segmentGroup: UrlSegmentGroup, consumedSegments: UrlSegment[], slicedSegments: UrlSegment[],\n    routes: Route[],\n    children: {[name: string]: UrlSegmentGroup}): {[name: string]: UrlSegmentGroup} {\n  const res: {[name: string]: UrlSegmentGroup} = {};\n  for (const r of routes) {\n    if (emptyPathMatch(segmentGroup, slicedSegments, r) && !children[getOutlet(r)]) {\n      const s = new UrlSegmentGroup([], {});\n      res[getOutlet(r)] = s;\n    }\n  }\n  return {...children, ...res};\n}\n\nfunction createChildrenForEmptyPaths(\n    routes: Route[], primarySegment: UrlSegmentGroup): {[name: string]: UrlSegmentGroup} {\n  const res: {[name: string]: UrlSegmentGroup} = {};\n  res[PRIMARY_OUTLET] = primarySegment;\n\n  for (const r of routes) {\n    if (r.path === '' && getOutlet(r) !== PRIMARY_OUTLET) {\n      const s = new UrlSegmentGroup([], {});\n      res[getOutlet(r)] = s;\n    }\n  }\n  return res;\n}\n\nfunction containsEmptyPathMatchesWithNamedOutlets(\n    segmentGroup: UrlSegmentGroup, slicedSegments: UrlSegment[], routes: Route[]): boolean {\n  return routes.some(\n      r => emptyPathMatch(segmentGroup, slicedSegments, r) && getOutlet(r) !== PRIMARY_OUTLET);\n}\n\nfunction containsEmptyPathMatches(\n    segmentGroup: UrlSegmentGroup, slicedSegments: UrlSegment[], routes: Route[]): boolean {\n  return routes.some(r => emptyPathMatch(segmentGroup, slicedSegments, r));\n}\n\nfunction emptyPathMatch(\n    segmentGroup: UrlSegmentGroup, slicedSegments: UrlSegment[], r: Route): boolean {\n  if ((segmentGroup.hasChildren() || slicedSegments.length > 0) && r.pathMatch === 'full') {\n    return false;\n  }\n\n  return r.path === '';\n}\n\n/**\n * Determines if `route` is a path match for the `rawSegment`, `segments`, and `outlet` without\n * verifying that its children are a full match for the remainder of the `rawSegment` children as\n * well.\n */\nexport function isImmediateMatch(\n    route: Route, rawSegment: UrlSegmentGroup, segments: UrlSegment[], outlet: string): boolean {\n  // We allow matches to empty paths when the outlets differ so we can match a url like `/(b:b)` to\n  // a config like\n  // * `{path: '', children: [{path: 'b', outlet: 'b'}]}`\n  // or even\n  // * `{path: '', outlet: 'a', children: [{path: 'b', outlet: 'b'}]`\n  //\n  // The exception here is when the segment outlet is for the primary outlet. This would\n  // result in a match inside the named outlet because all children there are written as primary\n  // outlets. So we need to prevent child named outlet matches in a url like `/b` in a config like\n  // * `{path: '', outlet: 'x' children: [{path: 'b'}]}`\n  // This should only match if the url is `/(x:b)`.\n  if (getOutlet(route) !== outlet &&\n      (outlet === PRIMARY_OUTLET || !emptyPathMatch(rawSegment, segments, route))) {\n    return false;\n  }\n  if (route.path === '**') {\n    return true;\n  }\n  return match(rawSegment, route, segments).matched;\n}\n\nexport function noLeftoversInUrl(\n    segmentGroup: UrlSegmentGroup, segments: UrlSegment[], outlet: string): boolean {\n  return segments.length === 0 && !segmentGroup.children[outlet];\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {EnvironmentInjector, Type, ɵRuntimeError as RuntimeError} from '@angular/core';\nimport {from, Observable, of} from 'rxjs';\nimport {catchError, concatMap, defaultIfEmpty, first, last as rxjsLast, map, mergeMap, scan, switchMap, tap} from 'rxjs/operators';\n\nimport {AbsoluteRedirect, ApplyRedirects, canLoadFails, noMatch, NoMatch} from './apply_redirects';\nimport {createUrlTreeFromSnapshot} from './create_url_tree';\nimport {RuntimeErrorCode} from './errors';\nimport {Data, LoadedRouterConfig, ResolveData, Route, Routes} from './models';\nimport {runCanLoadGuards} from './operators/check_guards';\nimport {RouterConfigLoader} from './router_config_loader';\nimport {ActivatedRouteSnapshot, getInherited, ParamsInheritanceStrategy, RouterStateSnapshot} from './router_state';\nimport {PRIMARY_OUTLET} from './shared';\nimport {UrlSegment, UrlSegmentGroup, UrlSerializer, UrlTree} from './url_tree';\nimport {last} from './utils/collection';\nimport {getOutlet, sortByMatchingOutlets} from './utils/config';\nimport {isImmediateMatch, match, MatchResult, matchWithChecks, noLeftoversInUrl, split} from './utils/config_matching';\nimport {TreeNode} from './utils/tree';\nimport {isEmptyError} from './utils/type_guards';\n\n/**\n * Class used to indicate there were no additional route config matches but that all segments of\n * the URL were consumed during matching so the route was URL matched. When this happens, we still\n * try to match child configs in case there are empty path children.\n */\nclass NoLeftoversInUrl {}\n\nexport function recognize(\n    injector: EnvironmentInjector, configLoader: RouterConfigLoader,\n    rootComponentType: Type<any>|null, config: Routes, urlTree: UrlTree,\n    urlSerializer: UrlSerializer,\n    paramsInheritanceStrategy: ParamsInheritanceStrategy =\n        'emptyOnly'): Observable<{state: RouterStateSnapshot, tree: UrlTree}> {\n  return new Recognizer(\n             injector, configLoader, rootComponentType, config, urlTree, paramsInheritanceStrategy,\n             urlSerializer)\n      .recognize();\n}\n\nconst MAX_ALLOWED_REDIRECTS = 31;\n\nexport class Recognizer {\n  private applyRedirects = new ApplyRedirects(this.urlSerializer, this.urlTree);\n  private absoluteRedirectCount = 0;\n  allowRedirects = true;\n\n  constructor(\n      private injector: EnvironmentInjector, private configLoader: RouterConfigLoader,\n      private rootComponentType: Type<any>|null, private config: Routes, private urlTree: UrlTree,\n      private paramsInheritanceStrategy: ParamsInheritanceStrategy,\n      private readonly urlSerializer: UrlSerializer) {}\n\n  private noMatchError(e: NoMatch): any {\n    return new RuntimeError(\n        RuntimeErrorCode.NO_MATCH,\n        (typeof ngDevMode === 'undefined' || ngDevMode) &&\n            `Cannot match any routes. URL Segment: '${e.segmentGroup}'`);\n  }\n\n  recognize(): Observable<{state: RouterStateSnapshot, tree: UrlTree}> {\n    const rootSegmentGroup = split(this.urlTree.root, [], [], this.config).segmentGroup;\n\n    return this.match(rootSegmentGroup).pipe(map(children => {\n      // Use Object.freeze to prevent readers of the Router state from modifying it outside\n      // of a navigation, resulting in the router being out of sync with the browser.\n      const root = new ActivatedRouteSnapshot(\n          [], Object.freeze({}), Object.freeze({...this.urlTree.queryParams}),\n          this.urlTree.fragment, {}, PRIMARY_OUTLET, this.rootComponentType, null, {});\n\n      const rootNode = new TreeNode(root, children);\n      const routeState = new RouterStateSnapshot('', rootNode);\n      const tree =\n          createUrlTreeFromSnapshot(root, [], this.urlTree.queryParams, this.urlTree.fragment);\n      // https://github.com/angular/angular/issues/47307\n      // Creating the tree stringifies the query params\n      // We don't want to do this here so reassign them to the original.\n      tree.queryParams = this.urlTree.queryParams;\n      routeState.url = this.urlSerializer.serialize(tree);\n      this.inheritParamsAndData(routeState._root, null);\n      return {state: routeState, tree};\n    }));\n  }\n\n\n  private match(rootSegmentGroup: UrlSegmentGroup): Observable<TreeNode<ActivatedRouteSnapshot>[]> {\n    const expanded$ =\n        this.processSegmentGroup(this.injector, this.config, rootSegmentGroup, PRIMARY_OUTLET);\n    return expanded$.pipe(catchError((e: any) => {\n      if (e instanceof AbsoluteRedirect) {\n        this.urlTree = e.urlTree;\n        return this.match(e.urlTree.root);\n      }\n      if (e instanceof NoMatch) {\n        throw this.noMatchError(e);\n      }\n\n      throw e;\n    }));\n  }\n\n  inheritParamsAndData(\n      routeNode: TreeNode<ActivatedRouteSnapshot>, parent: ActivatedRouteSnapshot|null): void {\n    const route = routeNode.value;\n    const i = getInherited(route, parent, this.paramsInheritanceStrategy);\n\n    route.params = Object.freeze(i.params);\n    route.data = Object.freeze(i.data);\n\n    routeNode.children.forEach(n => this.inheritParamsAndData(n, route));\n  }\n\n  processSegmentGroup(\n      injector: EnvironmentInjector, config: Route[], segmentGroup: UrlSegmentGroup,\n      outlet: string): Observable<TreeNode<ActivatedRouteSnapshot>[]> {\n    if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n      return this.processChildren(injector, config, segmentGroup);\n    }\n\n    return this.processSegment(injector, config, segmentGroup, segmentGroup.segments, outlet, true)\n        .pipe(map(child => child instanceof TreeNode ? [child] : []));\n  }\n\n  /**\n   * Matches every child outlet in the `segmentGroup` to a `Route` in the config. Returns `null` if\n   * we cannot find a match for _any_ of the children.\n   *\n   * @param config - The `Routes` to match against\n   * @param segmentGroup - The `UrlSegmentGroup` whose children need to be matched against the\n   *     config.\n   */\n  processChildren(injector: EnvironmentInjector, config: Route[], segmentGroup: UrlSegmentGroup):\n      Observable<TreeNode<ActivatedRouteSnapshot>[]> {\n    // Expand outlets one at a time, starting with the primary outlet. We need to do it this way\n    // because an absolute redirect from the primary outlet takes precedence.\n    const childOutlets: string[] = [];\n    for (const child of Object.keys(segmentGroup.children)) {\n      if (child === 'primary') {\n        childOutlets.unshift(child);\n      } else {\n        childOutlets.push(child);\n      }\n    }\n    return from(childOutlets)\n        .pipe(\n            concatMap(childOutlet => {\n              const child = segmentGroup.children[childOutlet];\n              // Sort the config so that routes with outlets that match the one being activated\n              // appear first, followed by routes for other outlets, which might match if they have\n              // an empty path.\n              const sortedConfig = sortByMatchingOutlets(config, childOutlet);\n              return this.processSegmentGroup(injector, sortedConfig, child, childOutlet);\n            }),\n            scan((children, outletChildren) => {\n              children.push(...outletChildren);\n              return children;\n            }),\n            defaultIfEmpty(null as TreeNode<ActivatedRouteSnapshot>[] | null),\n            rxjsLast(),\n            mergeMap(children => {\n              if (children === null) return noMatch(segmentGroup);\n              // Because we may have matched two outlets to the same empty path segment, we can have\n              // multiple activated results for the same outlet. We should merge the children of\n              // these results so the final return value is only one `TreeNode` per outlet.\n              const mergedChildren = mergeEmptyPathMatches(children);\n              if (typeof ngDevMode === 'undefined' || ngDevMode) {\n                // This should really never happen - we are only taking the first match for each\n                // outlet and merge the empty path matches.\n                checkOutletNameUniqueness(mergedChildren);\n              }\n              sortActivatedRouteSnapshots(mergedChildren);\n              return of(mergedChildren);\n            }),\n        );\n  }\n\n  processSegment(\n      injector: EnvironmentInjector, routes: Route[], segmentGroup: UrlSegmentGroup,\n      segments: UrlSegment[], outlet: string,\n      allowRedirects: boolean): Observable<TreeNode<ActivatedRouteSnapshot>|NoLeftoversInUrl> {\n    return from(routes).pipe(\n        concatMap(r => {\n          return this\n              .processSegmentAgainstRoute(\n                  r._injector ?? injector, routes, r, segmentGroup, segments, outlet,\n                  allowRedirects)\n              .pipe(catchError((e: any) => {\n                if (e instanceof NoMatch) {\n                  return of(null);\n                }\n                throw e;\n              }));\n        }),\n        first((x): x is TreeNode<ActivatedRouteSnapshot>|NoLeftoversInUrl => !!x), catchError(e => {\n          if (isEmptyError(e)) {\n            if (noLeftoversInUrl(segmentGroup, segments, outlet)) {\n              return of(new NoLeftoversInUrl());\n            }\n            return noMatch(segmentGroup);\n          }\n          throw e;\n        }));\n  }\n\n  processSegmentAgainstRoute(\n      injector: EnvironmentInjector, routes: Route[], route: Route, rawSegment: UrlSegmentGroup,\n      segments: UrlSegment[], outlet: string,\n      allowRedirects: boolean): Observable<TreeNode<ActivatedRouteSnapshot>|NoLeftoversInUrl> {\n    if (!isImmediateMatch(route, rawSegment, segments, outlet)) return noMatch(rawSegment);\n\n    if (route.redirectTo === undefined) {\n      return this.matchSegmentAgainstRoute(injector, rawSegment, route, segments, outlet);\n    }\n\n    if (this.allowRedirects && allowRedirects) {\n      return this.expandSegmentAgainstRouteUsingRedirect(\n          injector, rawSegment, routes, route, segments, outlet);\n    }\n\n    return noMatch(rawSegment);\n  }\n\n  private expandSegmentAgainstRouteUsingRedirect(\n      injector: EnvironmentInjector, segmentGroup: UrlSegmentGroup, routes: Route[], route: Route,\n      segments: UrlSegment[],\n      outlet: string): Observable<TreeNode<ActivatedRouteSnapshot>|NoLeftoversInUrl> {\n    const {\n      matched,\n      consumedSegments,\n      positionalParamSegments,\n      remainingSegments,\n    } = route.path === '**' ? createWildcardMatchResult(segments) :\n                              match(segmentGroup, route, segments);\n    if (!matched) return noMatch(segmentGroup);\n\n    // TODO(atscott): Move all of this under an if(ngDevMode) as a breaking change and allow stack\n    // size exceeded in production\n    if (route.redirectTo!.startsWith('/')) {\n      this.absoluteRedirectCount++;\n      if (this.absoluteRedirectCount > MAX_ALLOWED_REDIRECTS) {\n        if (ngDevMode) {\n          throw new RuntimeError(\n              RuntimeErrorCode.INFINITE_REDIRECT,\n              `Detected possible infinite redirect when redirecting from '${this.urlTree}' to '${\n                  route.redirectTo}'.\\n` +\n                  `This is currently a dev mode only error but will become a` +\n                  ` call stack size exceeded error in production in a future major version.`);\n        }\n        this.allowRedirects = false;\n      }\n    }\n    const newTree = this.applyRedirects.applyRedirectCommands(\n        consumedSegments, route.redirectTo!, positionalParamSegments);\n\n    return this.applyRedirects.lineralizeSegments(route, newTree)\n        .pipe(mergeMap((newSegments: UrlSegment[]) => {\n          return this.processSegment(\n              injector, routes, segmentGroup, newSegments.concat(remainingSegments), outlet, false);\n        }));\n  }\n\n  matchSegmentAgainstRoute(\n      injector: EnvironmentInjector, rawSegment: UrlSegmentGroup, route: Route,\n      segments: UrlSegment[], outlet: string): Observable<TreeNode<ActivatedRouteSnapshot>> {\n    let matchResult: Observable<MatchResult>;\n\n    if (route.path === '**') {\n      matchResult = of(createWildcardMatchResult(segments));\n      // Prior versions of the route matching algorithm would stop matching at the wildcard route.\n      // We should investigate a better strategy for any existing children. Otherwise, these\n      // child segments are silently dropped from the navigation.\n      // https://github.com/angular/angular/issues/40089\n      rawSegment.children = {};\n    } else {\n      matchResult = matchWithChecks(rawSegment, route, segments, injector, this.urlSerializer);\n    }\n\n    return matchResult.pipe(switchMap((result) => {\n      if (!result.matched) {\n        return noMatch(rawSegment);\n      }\n\n      // If the route has an injector created from providers, we should start using that.\n      injector = route._injector ?? injector;\n      return this.getChildConfig(injector, route, segments)\n          .pipe(switchMap(({routes: childConfig}) => {\n            const childInjector = route._loadedInjector ?? injector;\n\n            const {consumedSegments, remainingSegments, parameters} = result;\n            const snapshot = new ActivatedRouteSnapshot(\n                consumedSegments, parameters, Object.freeze({...this.urlTree.queryParams}),\n                this.urlTree.fragment, getData(route), getOutlet(route),\n                route.component ?? route._loadedComponent ?? null, route, getResolve(route));\n\n            const {segmentGroup, slicedSegments} =\n                split(rawSegment, consumedSegments, remainingSegments, childConfig);\n\n            if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {\n              return this.processChildren(childInjector, childConfig, segmentGroup)\n                  .pipe(map(children => {\n                    if (children === null) {\n                      return null;\n                    }\n                    return new TreeNode(snapshot, children);\n                  }));\n            }\n\n            if (childConfig.length === 0 && slicedSegments.length === 0) {\n              return of(new TreeNode(snapshot, []));\n            }\n\n            const matchedOnOutlet = getOutlet(route) === outlet;\n            // If we matched a config due to empty path match on a different outlet, we need to\n            // continue passing the current outlet for the segment rather than switch to PRIMARY.\n            // Note that we switch to primary when we have a match because outlet configs look like\n            // this: {path: 'a', outlet: 'a', children: [\n            //  {path: 'b', component: B},\n            //  {path: 'c', component: C},\n            // ]}\n            // Notice that the children of the named outlet are configured with the primary outlet\n            return this\n                .processSegment(\n                    childInjector, childConfig, segmentGroup, slicedSegments,\n                    matchedOnOutlet ? PRIMARY_OUTLET : outlet, true)\n                .pipe(map(child => {\n                  return new TreeNode(snapshot, child instanceof TreeNode ? [child] : []);\n                }));\n          }));\n    }));\n  }\n  private getChildConfig(injector: EnvironmentInjector, route: Route, segments: UrlSegment[]):\n      Observable<LoadedRouterConfig> {\n    if (route.children) {\n      // The children belong to the same module\n      return of({routes: route.children, injector});\n    }\n\n    if (route.loadChildren) {\n      // lazy children belong to the loaded module\n      if (route._loadedRoutes !== undefined) {\n        return of({routes: route._loadedRoutes, injector: route._loadedInjector});\n      }\n\n      return runCanLoadGuards(injector, route, segments, this.urlSerializer)\n          .pipe(mergeMap((shouldLoadResult: boolean) => {\n            if (shouldLoadResult) {\n              return this.configLoader.loadChildren(injector, route)\n                  .pipe(tap((cfg: LoadedRouterConfig) => {\n                    route._loadedRoutes = cfg.routes;\n                    route._loadedInjector = cfg.injector;\n                  }));\n            }\n            return canLoadFails(route);\n          }));\n    }\n\n    return of({routes: [], injector});\n  }\n}\n\nfunction sortActivatedRouteSnapshots(nodes: TreeNode<ActivatedRouteSnapshot>[]): void {\n  nodes.sort((a, b) => {\n    if (a.value.outlet === PRIMARY_OUTLET) return -1;\n    if (b.value.outlet === PRIMARY_OUTLET) return 1;\n    return a.value.outlet.localeCompare(b.value.outlet);\n  });\n}\n\nfunction hasEmptyPathConfig(node: TreeNode<ActivatedRouteSnapshot>) {\n  const config = node.value.routeConfig;\n  return config && config.path === '';\n}\n\n/**\n * Finds `TreeNode`s with matching empty path route configs and merges them into `TreeNode` with\n * the children from each duplicate. This is necessary because different outlets can match a\n * single empty path route config and the results need to then be merged.\n */\nfunction mergeEmptyPathMatches(nodes: Array<TreeNode<ActivatedRouteSnapshot>>):\n    Array<TreeNode<ActivatedRouteSnapshot>> {\n  const result: Array<TreeNode<ActivatedRouteSnapshot>> = [];\n  // The set of nodes which contain children that were merged from two duplicate empty path nodes.\n  const mergedNodes: Set<TreeNode<ActivatedRouteSnapshot>> = new Set();\n\n  for (const node of nodes) {\n    if (!hasEmptyPathConfig(node)) {\n      result.push(node);\n      continue;\n    }\n\n    const duplicateEmptyPathNode =\n        result.find(resultNode => node.value.routeConfig === resultNode.value.routeConfig);\n    if (duplicateEmptyPathNode !== undefined) {\n      duplicateEmptyPathNode.children.push(...node.children);\n      mergedNodes.add(duplicateEmptyPathNode);\n    } else {\n      result.push(node);\n    }\n  }\n  // For each node which has children from multiple sources, we need to recompute a new `TreeNode`\n  // by also merging those children. This is necessary when there are multiple empty path configs\n  // in a row. Put another way: whenever we combine children of two nodes, we need to also check\n  // if any of those children can be combined into a single node as well.\n  for (const mergedNode of mergedNodes) {\n    const mergedChildren = mergeEmptyPathMatches(mergedNode.children);\n    result.push(new TreeNode(mergedNode.value, mergedChildren));\n  }\n  return result.filter(n => !mergedNodes.has(n));\n}\n\nfunction checkOutletNameUniqueness(nodes: TreeNode<ActivatedRouteSnapshot>[]): void {\n  const names: {[k: string]: ActivatedRouteSnapshot} = {};\n  nodes.forEach(n => {\n    const routeWithSameOutletName = names[n.value.outlet];\n    if (routeWithSameOutletName) {\n      const p = routeWithSameOutletName.url.map(s => s.toString()).join('/');\n      const c = n.value.url.map(s => s.toString()).join('/');\n      throw new RuntimeError(\n          RuntimeErrorCode.TWO_SEGMENTS_WITH_SAME_OUTLET,\n          (typeof ngDevMode === 'undefined' || ngDevMode) &&\n              `Two segments cannot have the same outlet name: '${p}' and '${c}'.`);\n    }\n    names[n.value.outlet] = n.value;\n  });\n}\n\nfunction getData(route: Route): Data {\n  return route.data || {};\n}\n\nfunction getResolve(route: Route): ResolveData {\n  return route.resolve || {};\n}\n\nfunction createWildcardMatchResult(segments: UrlSegment[]): MatchResult {\n  return {\n    matched: true,\n    parameters: segments.length > 0 ? last(segments)!.parameters : {},\n    consumedSegments: segments,\n    remainingSegments: [],\n    positionalParamSegments: {},\n  };\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {EnvironmentInjector, Type} from '@angular/core';\nimport {MonoTypeOperatorFunction} from 'rxjs';\nimport {map, mergeMap} from 'rxjs/operators';\n\nimport {Route} from '../models';\nimport {NavigationTransition} from '../navigation_transition';\nimport {recognize as recognizeFn} from '../recognize';\nimport {RouterConfigLoader} from '../router_config_loader';\nimport {UrlSerializer} from '../url_tree';\n\nexport function recognize(\n    injector: EnvironmentInjector, configLoader: RouterConfigLoader,\n    rootComponentType: Type<any>|null, config: Route[], serializer: UrlSerializer,\n    paramsInheritanceStrategy: 'emptyOnly'|\n    'always'): MonoTypeOperatorFunction<NavigationTransition> {\n  return mergeMap(\n      t => recognizeFn(\n               injector, configLoader, rootComponentType, config, t.extractedUrl, serializer,\n               paramsInheritanceStrategy)\n               .pipe(map(({state: targetSnapshot, tree: urlAfterRedirects}) => {\n                 return {...t, targetSnapshot, urlAfterRedirects};\n               })));\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {EnvironmentInjector, ProviderToken} from '@angular/core';\nimport {EMPTY, from, MonoTypeOperatorFunction, Observable, of, throwError} from 'rxjs';\nimport {catchError, concatMap, first, map, mapTo, mergeMap, takeLast, tap} from 'rxjs/operators';\n\nimport {ResolveData} from '../models';\nimport {NavigationTransition} from '../navigation_transition';\nimport {ActivatedRouteSnapshot, getInherited, hasStaticTitle, RouterStateSnapshot} from '../router_state';\nimport {RouteTitleKey} from '../shared';\nimport {getDataKeys, wrapIntoObservable} from '../utils/collection';\nimport {getClosestRouteInjector} from '../utils/config';\nimport {getTokenOrFunctionIdentity} from '../utils/preactivation';\nimport {isEmptyError} from '../utils/type_guards';\n\nexport function resolveData(\n    paramsInheritanceStrategy: 'emptyOnly'|'always',\n    injector: EnvironmentInjector): MonoTypeOperatorFunction<NavigationTransition> {\n  return mergeMap(t => {\n    const {targetSnapshot, guards: {canActivateChecks}} = t;\n\n    if (!canActivateChecks.length) {\n      return of(t);\n    }\n    const routesWithResolversToRun = canActivateChecks.map(check => check.route);\n    const routesWithResolversSet = new Set(routesWithResolversToRun);\n    const routesNeedingDataUpdates =\n        // List all ActivatedRoutes in an array, starting from the parent of the first route to run\n        // resolvers. We go from the parent because the first route might have siblings that also\n        // run resolvers.\n        flattenRouteTree(routesWithResolversToRun[0].parent!)\n            // Remove the parent from the list -- we do not need to recompute its inherited data\n            // because no resolvers at or above it run.\n            .slice(1);\n    let routesProcessed = 0;\n    return from(routesNeedingDataUpdates)\n        .pipe(\n            concatMap(route => {\n              if (routesWithResolversSet.has(route)) {\n                return runResolve(route, targetSnapshot!, paramsInheritanceStrategy, injector);\n              } else {\n                route.data = getInherited(route, route.parent, paramsInheritanceStrategy).resolve;\n                return of(void 0);\n              }\n            }),\n            tap(() => routesProcessed++),\n            takeLast(1),\n            mergeMap(_ => routesProcessed === routesNeedingDataUpdates.length ? of(t) : EMPTY),\n        );\n  });\n}\n\n/**\n *  Returns the `ActivatedRouteSnapshot` tree as an array, using DFS to traverse the route tree.\n */\nfunction flattenRouteTree(route: ActivatedRouteSnapshot): ActivatedRouteSnapshot[] {\n  const descendants = route.children.map(child => flattenRouteTree(child)).flat();\n  return [route, ...descendants];\n}\n\nfunction runResolve(\n    futureARS: ActivatedRouteSnapshot, futureRSS: RouterStateSnapshot,\n    paramsInheritanceStrategy: 'emptyOnly'|'always', injector: EnvironmentInjector) {\n  const config = futureARS.routeConfig;\n  const resolve = futureARS._resolve;\n  if (config?.title !== undefined && !hasStaticTitle(config)) {\n    resolve[RouteTitleKey] = config.title;\n  }\n  return resolveNode(resolve, futureARS, futureRSS, injector).pipe(map((resolvedData: any) => {\n    futureARS._resolvedData = resolvedData;\n    futureARS.data = getInherited(futureARS, futureARS.parent, paramsInheritanceStrategy).resolve;\n    return null;\n  }));\n}\n\nfunction resolveNode(\n    resolve: ResolveData, futureARS: ActivatedRouteSnapshot, futureRSS: RouterStateSnapshot,\n    injector: EnvironmentInjector): Observable<any> {\n  const keys = getDataKeys(resolve);\n  if (keys.length === 0) {\n    return of({});\n  }\n  const data: {[k: string|symbol]: any} = {};\n  return from(keys).pipe(\n      mergeMap(\n          key => getResolver(resolve[key], futureARS, futureRSS, injector)\n                     .pipe(first(), tap((value: any) => {\n                             data[key] = value;\n                           }))),\n      takeLast(1),\n      mapTo(data),\n      catchError((e: unknown) => isEmptyError(e as Error) ? EMPTY : throwError(e)),\n  );\n}\n\nfunction getResolver(\n    injectionToken: ProviderToken<any>|Function, futureARS: ActivatedRouteSnapshot,\n    futureRSS: RouterStateSnapshot, injector: EnvironmentInjector): Observable<any> {\n  const closestInjector = getClosestRouteInjector(futureARS) ?? injector;\n  const resolver = getTokenOrFunctionIdentity(injectionToken, closestInjector);\n  const resolverValue = resolver.resolve ?\n      resolver.resolve(futureARS, futureRSS) :\n      closestInjector.runInContext(() => resolver(futureARS, futureRSS));\n  return wrapIntoObservable(resolverValue);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {from, MonoTypeOperatorFunction, ObservableInput, of} from 'rxjs';\nimport {map, switchMap} from 'rxjs/operators';\n\n/**\n * Perform a side effect through a switchMap for every emission on the source Observable,\n * but return an Observable that is identical to the source. It's essentially the same as\n * the `tap` operator, but if the side effectful `next` function returns an ObservableInput,\n * it will wait before continuing with the original value.\n */\nexport function switchTap<T>(next: (x: T) => void|ObservableInput<any>):\n    MonoTypeOperatorFunction<T> {\n  return switchMap(v => {\n    const nextResult = next(v);\n    if (nextResult) {\n      return from(nextResult).pipe(map(() => v));\n    }\n    return of(v);\n  });\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {inject, Injectable} from '@angular/core';\nimport {Title} from '@angular/platform-browser';\n\nimport {ActivatedRouteSnapshot, RouterStateSnapshot} from './router_state';\nimport {PRIMARY_OUTLET, RouteTitleKey} from './shared';\n\n/**\n * Provides a strategy for setting the page title after a router navigation.\n *\n * The built-in implementation traverses the router state snapshot and finds the deepest primary\n * outlet with `title` property. Given the `Routes` below, navigating to\n * `/base/child(popup:aux)` would result in the document title being set to \"child\".\n * ```\n * [\n *   {path: 'base', title: 'base', children: [\n *     {path: 'child', title: 'child'},\n *   ],\n *   {path: 'aux', outlet: 'popup', title: 'popupTitle'}\n * ]\n * ```\n *\n * This class can be used as a base class for custom title strategies. That is, you can create your\n * own class that extends the `TitleStrategy`. Note that in the above example, the `title`\n * from the named outlet is never used. However, a custom strategy might be implemented to\n * incorporate titles in named outlets.\n *\n * @publicApi\n * @see [Page title guide](guide/router#setting-the-page-title)\n */\n@Injectable({providedIn: 'root', useFactory: () => inject(DefaultTitleStrategy)})\nexport abstract class TitleStrategy {\n  /** Performs the application title update. */\n  abstract updateTitle(snapshot: RouterStateSnapshot): void;\n\n  /**\n   * @returns The `title` of the deepest primary route.\n   */\n  buildTitle(snapshot: RouterStateSnapshot): string|undefined {\n    let pageTitle: string|undefined;\n    let route: ActivatedRouteSnapshot|undefined = snapshot.root;\n    while (route !== undefined) {\n      pageTitle = this.getResolvedTitleForRoute(route) ?? pageTitle;\n      route = route.children.find(child => child.outlet === PRIMARY_OUTLET);\n    }\n    return pageTitle;\n  }\n\n  /**\n   * Given an `ActivatedRouteSnapshot`, returns the final value of the\n   * `Route.title` property, which can either be a static string or a resolved value.\n   */\n  getResolvedTitleForRoute(snapshot: ActivatedRouteSnapshot) {\n    return snapshot.data[RouteTitleKey];\n  }\n}\n\n/**\n * The default `TitleStrategy` used by the router that updates the title using the `Title` service.\n */\n@Injectable({providedIn: 'root'})\nexport class DefaultTitleStrategy extends TitleStrategy {\n  constructor(readonly title: Title) {\n    super();\n  }\n\n  /**\n   * Sets the title of the browser to the given value.\n   *\n   * @param title The `pageTitle` from the deepest primary route.\n   */\n  override updateTitle(snapshot: RouterStateSnapshot): void {\n    const title = this.buildTitle(snapshot);\n    if (title !== undefined) {\n      this.title.setTitle(title);\n    }\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {InjectionToken} from '@angular/core';\n\nimport {OnSameUrlNavigation} from './models';\nimport {UrlSerializer, UrlTree} from './url_tree';\n\n\n/**\n * Error handler that is invoked when a navigation error occurs.\n *\n * If the handler returns a value, the navigation Promise is resolved with this value.\n * If the handler throws an exception, the navigation Promise is rejected with\n * the exception.\n *\n * @publicApi\n * @deprecated Subscribe to the `Router` events and watch for `NavigationError` instead.\n */\nexport type ErrorHandler = (error: any) => any;\n\n/**\n * Allowed values in an `ExtraOptions` object that configure\n * when the router performs the initial navigation operation.\n *\n * * 'enabledNonBlocking' - (default) The initial navigation starts after the\n * root component has been created. The bootstrap is not blocked on the completion of the initial\n * navigation.\n * * 'enabledBlocking' - The initial navigation starts before the root component is created.\n * The bootstrap is blocked until the initial navigation is complete. This value is required\n * for [server-side rendering](guide/ssr) to work.\n * * 'disabled' - The initial navigation is not performed. The location listener is set up before\n * the root component gets created. Use if there is a reason to have\n * more control over when the router starts its initial navigation due to some complex\n * initialization logic.\n *\n * @see {@link forRoot()}\n *\n * @publicApi\n */\nexport type InitialNavigation = 'disabled'|'enabledBlocking'|'enabledNonBlocking';\n\n/**\n * Extra configuration options that can be used with the `withRouterConfig` function.\n *\n * @publicApi\n */\nexport interface RouterConfigOptions {\n  /**\n   * Configures how the Router attempts to restore state when a navigation is cancelled.\n   *\n   * 'replace' - Always uses `location.replaceState` to set the browser state to the state of the\n   * router before the navigation started. This means that if the URL of the browser is updated\n   * _before_ the navigation is canceled, the Router will simply replace the item in history rather\n   * than trying to restore to the previous location in the session history. This happens most\n   * frequently with `urlUpdateStrategy: 'eager'` and navigations with the browser back/forward\n   * buttons.\n   *\n   * 'computed' - Will attempt to return to the same index in the session history that corresponds\n   * to the Angular route when the navigation gets cancelled. For example, if the browser back\n   * button is clicked and the navigation is cancelled, the Router will trigger a forward navigation\n   * and vice versa.\n   *\n   * Note: the 'computed' option is incompatible with any `UrlHandlingStrategy` which only\n   * handles a portion of the URL because the history restoration navigates to the previous place in\n   * the browser history rather than simply resetting a portion of the URL.\n   *\n   * The default value is `replace` when not set.\n   */\n  canceledNavigationResolution?: 'replace'|'computed';\n\n  /**\n   * Configures the default for handling a navigation request to the current URL.\n   *\n   * If unset, the `Router` will use `'ignore'`.\n   *\n   * @see {@link OnSameUrlNavigation}\n   */\n  onSameUrlNavigation?: OnSameUrlNavigation;\n\n  /**\n   * Defines how the router merges parameters, data, and resolved data from parent to child\n   * routes.\n   *\n   * By default ('emptyOnly'), a route inherits the parent route's parameters when the route itself\n   * has an empty path (meaning its configured with path: '') or when the parent route doesn't have\n   * any component set.\n   *\n   * Set to 'always' to enable unconditional inheritance of parent parameters.\n   *\n   * Note that when dealing with matrix parameters, \"parent\" refers to the parent `Route`\n   * config which does not necessarily mean the \"URL segment to the left\". When the `Route` `path`\n   * contains multiple segments, the matrix parameters must appear on the last segment. For example,\n   * matrix parameters for `{path: 'a/b', component: MyComp}` should appear as `a/b;foo=bar` and not\n   * `a;foo=bar/b`.\n   *\n   */\n  paramsInheritanceStrategy?: 'emptyOnly'|'always';\n\n  /**\n   * Defines when the router updates the browser URL. By default ('deferred'),\n   * update after successful navigation.\n   * Set to 'eager' if prefer to update the URL at the beginning of navigation.\n   * Updating the URL early allows you to handle a failure of navigation by\n   * showing an error message with the URL that failed.\n   */\n  urlUpdateStrategy?: 'deferred'|'eager';\n}\n\n/**\n * Configuration options for the scrolling feature which can be used with `withInMemoryScrolling`\n * function.\n *\n * @publicApi\n */\nexport interface InMemoryScrollingOptions {\n  /**\n   * When set to 'enabled', scrolls to the anchor element when the URL has a fragment.\n   * Anchor scrolling is disabled by default.\n   *\n   * Anchor scrolling does not happen on 'popstate'. Instead, we restore the position\n   * that we stored or scroll to the top.\n   */\n  anchorScrolling?: 'disabled'|'enabled';\n\n  /**\n   * Configures if the scroll position needs to be restored when navigating back.\n   *\n   * * 'disabled'- (Default) Does nothing. Scroll position is maintained on navigation.\n   * * 'top'- Sets the scroll position to x = 0, y = 0 on all navigation.\n   * * 'enabled'- Restores the previous scroll position on backward navigation, else sets the\n   * position to the anchor if one is provided, or sets the scroll position to [0, 0] (forward\n   * navigation). This option will be the default in the future.\n   *\n   * You can implement custom scroll restoration behavior by adapting the enabled behavior as\n   * in the following example.\n   *\n   * ```typescript\n   * class AppComponent {\n   *   movieData: any;\n   *\n   *   constructor(private router: Router, private viewportScroller: ViewportScroller,\n   * changeDetectorRef: ChangeDetectorRef) {\n   *   router.events.pipe(filter((event: Event): event is Scroll => event instanceof Scroll)\n   *     ).subscribe(e => {\n   *       fetch('http://example.com/movies.json').then(response => {\n   *         this.movieData = response.json();\n   *         // update the template with the data before restoring scroll\n   *         changeDetectorRef.detectChanges();\n   *\n   *         if (e.position) {\n   *           viewportScroller.scrollToPosition(e.position);\n   *         }\n   *       });\n   *     });\n   *   }\n   * }\n   * ```\n   */\n  scrollPositionRestoration?: 'disabled'|'enabled'|'top';\n}\n\n/**\n * A set of configuration options for a router module, provided in the\n * `forRoot()` method.\n *\n * @see {@link forRoot()}\n *\n *\n * @publicApi\n */\nexport interface ExtraOptions extends InMemoryScrollingOptions, RouterConfigOptions {\n  /**\n   * When true, log all internal navigation events to the console.\n   * Use for debugging.\n   */\n  enableTracing?: boolean;\n\n  /**\n   * When true, enable the location strategy that uses the URL fragment\n   * instead of the history API.\n   */\n  useHash?: boolean;\n\n  /**\n   * One of `enabled`, `enabledBlocking`, `enabledNonBlocking` or `disabled`.\n   * When set to `enabled` or `enabledBlocking`, the initial navigation starts before the root\n   * component is created. The bootstrap is blocked until the initial navigation is complete. This\n   * value is required for [server-side rendering](guide/ssr) to work. When set to\n   * `enabledNonBlocking`, the initial navigation starts after the root component has been created.\n   * The bootstrap is not blocked on the completion of the initial navigation. When set to\n   * `disabled`, the initial navigation is not performed. The location listener is set up before the\n   * root component gets created. Use if there is a reason to have more control over when the router\n   * starts its initial navigation due to some complex initialization logic.\n   */\n  initialNavigation?: InitialNavigation;\n\n  /**\n   * When true, enables binding information from the `Router` state directly to the inputs of the\n   * component in `Route` configurations.\n   */\n  bindToComponentInputs?: boolean;\n\n  /**\n   * When true, enables view transitions in the Router by running the route activation and\n   * deactivation inside of `document.startViewTransition`.\n   *\n   * @see https://developer.chrome.com/docs/web-platform/view-transitions/\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/View_Transitions_API\n   * @experimental\n   */\n  enableViewTransitions?: boolean;\n\n  /**\n   * A custom error handler for failed navigations.\n   * If the handler returns a value, the navigation Promise is resolved with this value.\n   * If the handler throws an exception, the navigation Promise is rejected with the exception.\n   *\n   * @deprecated Subscribe to the `Router` events and watch for `NavigationError` instead.\n   */\n  errorHandler?: (error: any) => any;\n\n  /**\n   * Configures a preloading strategy.\n   * One of `PreloadAllModules` or `NoPreloading` (the default).\n   */\n  preloadingStrategy?: any;\n\n  /**\n   * Configures the scroll offset the router will use when scrolling to an element.\n   *\n   * When given a tuple with x and y position value,\n   * the router uses that offset each time it scrolls.\n   * When given a function, the router invokes the function every time\n   * it restores scroll position.\n   */\n  scrollOffset?: [number, number]|(() => [number, number]);\n}\n\n/**\n * A [DI token](guide/glossary/#di-token) for the router service.\n *\n * @publicApi\n */\nexport const ROUTER_CONFIGURATION = new InjectionToken<ExtraOptions>(\n    (typeof ngDevMode === 'undefined' || ngDevMode) ? 'router config' : '', {\n      providedIn: 'root',\n      factory: () => ({}),\n    });\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Compiler, EnvironmentInjector, inject, Injectable, InjectFlags, InjectionToken, Injector, NgModuleFactory, Type} from '@angular/core';\nimport {ConnectableObservable, from, Observable, of, Subject} from 'rxjs';\nimport {finalize, map, mergeMap, refCount, tap} from 'rxjs/operators';\n\nimport {DefaultExport, LoadChildren, LoadChildrenCallback, LoadedRouterConfig, Route, Routes} from './models';\nimport {wrapIntoObservable} from './utils/collection';\nimport {assertStandalone, standardizeConfig, validateConfig} from './utils/config';\n\n\n\n/**\n * The [DI token](guide/glossary/#di-token) for a router configuration.\n *\n * `ROUTES` is a low level API for router configuration via dependency injection.\n *\n * We recommend that in almost all cases to use higher level APIs such as `RouterModule.forRoot()`,\n * `provideRouter`, or `Router.resetConfig()`.\n *\n * @publicApi\n */\nexport const ROUTES = new InjectionToken<Route[][]>('ROUTES');\n\ntype ComponentLoader = Observable<Type<unknown>>;\n\n@Injectable({providedIn: 'root'})\nexport class RouterConfigLoader {\n  private componentLoaders = new WeakMap<Route, ComponentLoader>();\n  private childrenLoaders = new WeakMap<Route, Observable<LoadedRouterConfig>>();\n  onLoadStartListener?: (r: Route) => void;\n  onLoadEndListener?: (r: Route) => void;\n  private readonly compiler = inject(Compiler);\n\n  loadComponent(route: Route): Observable<Type<unknown>> {\n    if (this.componentLoaders.get(route)) {\n      return this.componentLoaders.get(route)!;\n    } else if (route._loadedComponent) {\n      return of(route._loadedComponent);\n    }\n\n    if (this.onLoadStartListener) {\n      this.onLoadStartListener(route);\n    }\n    const loadRunner = wrapIntoObservable(route.loadComponent!())\n                           .pipe(\n                               map(maybeUnwrapDefaultExport),\n                               tap(component => {\n                                 if (this.onLoadEndListener) {\n                                   this.onLoadEndListener(route);\n                                 }\n                                 (typeof ngDevMode === 'undefined' || ngDevMode) &&\n                                     assertStandalone(route.path ?? '', component);\n                                 route._loadedComponent = component;\n                               }),\n                               finalize(() => {\n                                 this.componentLoaders.delete(route);\n                               }),\n                           );\n    // Use custom ConnectableObservable as share in runners pipe increasing the bundle size too much\n    const loader =\n        new ConnectableObservable(loadRunner, () => new Subject<Type<unknown>>()).pipe(refCount());\n    this.componentLoaders.set(route, loader);\n    return loader;\n  }\n\n  loadChildren(parentInjector: Injector, route: Route): Observable<LoadedRouterConfig> {\n    if (this.childrenLoaders.get(route)) {\n      return this.childrenLoaders.get(route)!;\n    } else if (route._loadedRoutes) {\n      return of({routes: route._loadedRoutes, injector: route._loadedInjector});\n    }\n\n    if (this.onLoadStartListener) {\n      this.onLoadStartListener(route);\n    }\n    const moduleFactoryOrRoutes$ =\n        loadChildren(route, this.compiler, parentInjector, this.onLoadEndListener);\n    const loadRunner = moduleFactoryOrRoutes$.pipe(\n        finalize(() => {\n          this.childrenLoaders.delete(route);\n        }),\n    );\n    // Use custom ConnectableObservable as share in runners pipe increasing the bundle size too much\n    const loader = new ConnectableObservable(loadRunner, () => new Subject<LoadedRouterConfig>())\n                       .pipe(refCount());\n    this.childrenLoaders.set(route, loader);\n    return loader;\n  }\n}\n\n/**\n * Executes a `route.loadChildren` callback and converts the result to an array of child routes and\n * an injector if that callback returned a module.\n *\n * This function is used for the route discovery during prerendering\n * in @angular-devkit/build-angular. If there are any updates to the contract here, it will require\n * an update to the extractor.\n */\nexport function loadChildren(\n    route: Route, compiler: Compiler, parentInjector: Injector,\n    onLoadEndListener?: (r: Route) => void): Observable<LoadedRouterConfig> {\n  return wrapIntoObservable(route.loadChildren!())\n      .pipe(\n          map(maybeUnwrapDefaultExport),\n          mergeMap((t) => {\n            if (t instanceof NgModuleFactory || Array.isArray(t)) {\n              return of(t);\n            } else {\n              return from(compiler.compileModuleAsync(t));\n            }\n          }),\n          map((factoryOrRoutes: NgModuleFactory<any>|Routes) => {\n            if (onLoadEndListener) {\n              onLoadEndListener(route);\n            }\n            // This injector comes from the `NgModuleRef` when lazy loading an `NgModule`. There is\n            // no injector associated with lazy loading a `Route` array.\n            let injector: EnvironmentInjector|undefined;\n            let rawRoutes: Route[];\n            let requireStandaloneComponents = false;\n            if (Array.isArray(factoryOrRoutes)) {\n              rawRoutes = factoryOrRoutes;\n              requireStandaloneComponents = true;\n            } else {\n              injector = factoryOrRoutes.create(parentInjector).injector;\n              // When loading a module that doesn't provide `RouterModule.forChild()` preloader\n              // will get stuck in an infinite loop. The child module's Injector will look to\n              // its parent `Injector` when it doesn't find any ROUTES so it will return routes\n              // for it's parent module instead.\n              rawRoutes = injector.get(ROUTES, [], {optional: true, self: true}).flat();\n            }\n            const routes = rawRoutes.map(standardizeConfig);\n            (typeof ngDevMode === 'undefined' || ngDevMode) &&\n                validateConfig(routes, route.path, requireStandaloneComponents);\n            return {routes, injector};\n          }),\n      );\n}\n\nfunction isWrappedDefaultExport<T>(value: T|DefaultExport<T>): value is DefaultExport<T> {\n  // We use `in` here with a string key `'default'`, because we expect `DefaultExport` objects to be\n  // dynamically imported ES modules with a spec-mandated `default` key. Thus we don't expect that\n  // `default` will be a renamed property.\n  return value && typeof value === 'object' && 'default' in value;\n}\n\nfunction maybeUnwrapDefaultExport<T>(input: T|DefaultExport<T>): T {\n  // As per `isWrappedDefaultExport`, the `default` key here is generated by the browser and not\n  // subject to property renaming, so we reference it with bracket access.\n  return isWrappedDefaultExport(input) ? input['default'] : input;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {inject, Injectable} from '@angular/core';\n\nimport {UrlTree} from './url_tree';\n\n/**\n * @description\n *\n * Provides a way to migrate AngularJS applications to Angular.\n *\n * @publicApi\n */\n@Injectable({providedIn: 'root', useFactory: () => inject(DefaultUrlHandlingStrategy)})\nexport abstract class UrlHandlingStrategy {\n  /**\n   * Tells the router if this URL should be processed.\n   *\n   * When it returns true, the router will execute the regular navigation.\n   * When it returns false, the router will set the router state to an empty state.\n   * As a result, all the active components will be destroyed.\n   *\n   */\n  abstract shouldProcessUrl(url: UrlTree): boolean;\n\n  /**\n   * Extracts the part of the URL that should be handled by the router.\n   * The rest of the URL will remain untouched.\n   */\n  abstract extract(url: UrlTree): UrlTree;\n\n  /**\n   * Merges the URL fragment with the rest of the URL.\n   */\n  abstract merge(newUrlPart: UrlTree, rawUrl: UrlTree): UrlTree;\n}\n\n/**\n * @publicApi\n */\n@Injectable({providedIn: 'root'})\nexport class DefaultUrlHandlingStrategy implements UrlHandlingStrategy {\n  shouldProcessUrl(url: UrlTree): boolean {\n    return true;\n  }\n  extract(url: UrlTree): UrlTree {\n    return url;\n  }\n  merge(newUrlPart: UrlTree, wholeUrl: UrlTree): UrlTree {\n    return newUrlPart;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/// <reference types=\"@types/dom-view-transitions\" />\n\nimport {DOCUMENT} from '@angular/common';\nimport {afterNextRender, InjectionToken, Injector, NgZone, runInInjectionContext} from '@angular/core';\n\nimport {ActivatedRouteSnapshot} from '../router_state';\n\nexport const CREATE_VIEW_TRANSITION =\n    new InjectionToken<typeof createViewTransition>(ngDevMode ? 'view transition helper' : '');\nexport const VIEW_TRANSITION_OPTIONS =\n    new InjectionToken<ViewTransitionsFeatureOptions&{skipNextTransition: boolean}>(\n        ngDevMode ? 'view transition options' : '');\n\n/**\n * Options to configure the View Transitions integration in the Router.\n *\n * @experimental\n * @publicApi\n * @see withViewTransitions\n */\nexport interface ViewTransitionsFeatureOptions {\n  /**\n   * Skips the very first call to `startViewTransition`. This can be useful for disabling the\n   * animation during the application's initial loading phase.\n   */\n  skipInitialTransition?: boolean;\n\n  /**\n   * A function to run after the `ViewTransition` is created.\n   *\n   * This function is run in an injection context and can use `inject`.\n   */\n  onViewTransitionCreated?: (transitionInfo: ViewTransitionInfo) => void;\n}\n\n/**\n * The information passed to the `onViewTransitionCreated` function provided in the\n * `withViewTransitions` feature options.\n *\n * @publicApi\n * @experimental\n */\nexport interface ViewTransitionInfo {\n  // TODO(atscott): This type can/should be the built-in `ViewTransition` type\n  // from @types/dom-view-transitions but exporting that type from the public API is currently not\n  // supported by tooling.\n  /**\n   * The `ViewTransition` returned by the call to `startViewTransition`.\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/ViewTransition\n   */\n  transition: {\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/ViewTransition/finished\n     */\n    finished: Promise<void>,\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/ViewTransition/ready\n     */\n    ready: Promise<void>,\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/ViewTransition/updateCallbackDone\n     */\n    updateCallbackDone: Promise<void>,\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/ViewTransition/skipTransition\n     */\n    skipTransition(): void,\n  };\n  /**\n   * The `ActivatedRouteSnapshot` that the navigation is transitioning from.\n   */\n  from: ActivatedRouteSnapshot;\n  /**\n   * The `ActivatedRouteSnapshot` that the navigation is transitioning to.\n   */\n  to: ActivatedRouteSnapshot;\n}\n\n/**\n * A helper function for using browser view transitions. This function skips the call to\n * `startViewTransition` if the browser does not support it.\n *\n * @returns A Promise that resolves when the view transition callback begins.\n */\nexport function createViewTransition(\n    injector: Injector, from: ActivatedRouteSnapshot, to: ActivatedRouteSnapshot): Promise<void> {\n  const transitionOptions = injector.get(VIEW_TRANSITION_OPTIONS);\n  const document = injector.get(DOCUMENT);\n  // Create promises outside the Angular zone to avoid causing extra change detections\n  return injector.get(NgZone).runOutsideAngular(() => {\n    if (!document.startViewTransition || transitionOptions.skipNextTransition) {\n      transitionOptions.skipNextTransition = false;\n      return Promise.resolve();\n    }\n\n    let resolveViewTransitionStarted: () => void;\n    const viewTransitionStarted = new Promise<void>((resolve) => {\n      resolveViewTransitionStarted = resolve;\n    });\n    const transition = document.startViewTransition(() => {\n      resolveViewTransitionStarted();\n      // We don't actually update dom within the transition callback. The resolving of the above\n      // promise unblocks the Router navigation, which synchronously activates and deactivates\n      // routes (the DOM update). This view transition waits for the next change detection to\n      // complete (below), which includes the update phase of the routed components.\n      return createRenderPromise(injector);\n    });\n    const {onViewTransitionCreated} = transitionOptions;\n    if (onViewTransitionCreated) {\n      runInInjectionContext(injector, () => onViewTransitionCreated({transition, from, to}));\n    }\n    return viewTransitionStarted;\n  });\n}\n\n/**\n * Creates a promise that resolves after next render.\n */\nfunction createRenderPromise(injector: Injector) {\n  return new Promise<void>(resolve => {\n    afterNextRender(resolve, {injector});\n  });\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Location} from '@angular/common';\nimport {EnvironmentInjector, inject, Injectable, Type} from '@angular/core';\nimport {BehaviorSubject, combineLatest, EMPTY, from, Observable, of, Subject} from 'rxjs';\nimport {catchError, defaultIfEmpty, filter, finalize, map, switchMap, take, takeUntil, tap} from 'rxjs/operators';\n\nimport {createRouterState} from './create_router_state';\nimport {INPUT_BINDER} from './directives/router_outlet';\nimport {BeforeActivateRoutes, Event, GuardsCheckEnd, GuardsCheckStart, IMPERATIVE_NAVIGATION, NavigationCancel, NavigationCancellationCode, NavigationEnd, NavigationError, NavigationSkipped, NavigationSkippedCode, NavigationStart, NavigationTrigger, RedirectRequest, ResolveEnd, ResolveStart, RouteConfigLoadEnd, RouteConfigLoadStart, RoutesRecognized} from './events';\nimport {NavigationBehaviorOptions, QueryParamsHandling, Route, Routes} from './models';\nimport {isNavigationCancelingError, isRedirectingNavigationCancelingError, redirectingNavigationError} from './navigation_canceling_error';\nimport {activateRoutes} from './operators/activate_routes';\nimport {checkGuards} from './operators/check_guards';\nimport {recognize} from './operators/recognize';\nimport {resolveData} from './operators/resolve_data';\nimport {switchTap} from './operators/switch_tap';\nimport {TitleStrategy} from './page_title_strategy';\nimport {RouteReuseStrategy} from './route_reuse_strategy';\nimport {ROUTER_CONFIGURATION} from './router_config';\nimport {RouterConfigLoader} from './router_config_loader';\nimport {ChildrenOutletContexts} from './router_outlet_context';\nimport {ActivatedRoute, ActivatedRouteSnapshot, createEmptyState, RouterState, RouterStateSnapshot} from './router_state';\nimport {Params} from './shared';\nimport {UrlHandlingStrategy} from './url_handling_strategy';\nimport {isUrlTree, UrlSerializer, UrlTree} from './url_tree';\nimport {Checks, getAllRouteGuards} from './utils/preactivation';\nimport {CREATE_VIEW_TRANSITION} from './utils/view_transition';\n\n\n\n/**\n * @description\n *\n * Options that modify the `Router` URL.\n * Supply an object containing any of these properties to a `Router` navigation function to\n * control how the target URL should be constructed.\n *\n * @see {@link Router#navigate}\n * @see {@link Router#createUrlTree}\n * @see [Routing and Navigation guide](guide/router)\n *\n * @publicApi\n */\nexport interface UrlCreationOptions {\n  /**\n   * Specifies a root URI to use for relative navigation.\n   *\n   * For example, consider the following route configuration where the parent route\n   * has two children.\n   *\n   * ```\n   * [{\n   *   path: 'parent',\n   *   component: ParentComponent,\n   *   children: [{\n   *     path: 'list',\n   *     component: ListComponent\n   *   },{\n   *     path: 'child',\n   *     component: ChildComponent\n   *   }]\n   * }]\n   * ```\n   *\n   * The following `go()` function navigates to the `list` route by\n   * interpreting the destination URI as relative to the activated `child`  route\n   *\n   * ```\n   *  @Component({...})\n   *  class ChildComponent {\n   *    constructor(private router: Router, private route: ActivatedRoute) {}\n   *\n   *    go() {\n   *      router.navigate(['../list'], { relativeTo: this.route });\n   *    }\n   *  }\n   * ```\n   *\n   * A value of `null` or `undefined` indicates that the navigation commands should be applied\n   * relative to the root.\n   */\n  relativeTo?: ActivatedRoute|null;\n\n  /**\n   * Sets query parameters to the URL.\n   *\n   * ```\n   * // Navigate to /results?page=1\n   * router.navigate(['/results'], { queryParams: { page: 1 } });\n   * ```\n   */\n  queryParams?: Params|null;\n\n  /**\n   * Sets the hash fragment for the URL.\n   *\n   * ```\n   * // Navigate to /results#top\n   * router.navigate(['/results'], { fragment: 'top' });\n   * ```\n   */\n  fragment?: string;\n\n  /**\n   * How to handle query parameters in the router link for the next navigation.\n   * One of:\n   * * `preserve` : Preserve current parameters.\n   * * `merge` : Merge new with current parameters.\n   *\n   * The \"preserve\" option discards any new query params:\n   * ```\n   * // from /view1?page=1 to/view2?page=1\n   * router.navigate(['/view2'], { queryParams: { page: 2 },  queryParamsHandling: \"preserve\"\n   * });\n   * ```\n   * The \"merge\" option appends new query params to the params from the current URL:\n   * ```\n   * // from /view1?page=1 to/view2?page=1&otherKey=2\n   * router.navigate(['/view2'], { queryParams: { otherKey: 2 },  queryParamsHandling: \"merge\"\n   * });\n   * ```\n   * In case of a key collision between current parameters and those in the `queryParams` object,\n   * the new value is used.\n   *\n   */\n  queryParamsHandling?: QueryParamsHandling|null;\n\n  /**\n   * When true, preserves the URL fragment for the next navigation\n   *\n   * ```\n   * // Preserve fragment from /results#top to /view#top\n   * router.navigate(['/view'], { preserveFragment: true });\n   * ```\n   */\n  preserveFragment?: boolean;\n}\n\n/**\n * @description\n *\n * Options that modify the `Router` navigation strategy.\n * Supply an object containing any of these properties to a `Router` navigation function to\n * control how the target URL should be constructed or interpreted.\n *\n * @see {@link Router#navigate}\n * @see {@link Router#navigateByUrl}\n * @see {@link Router#createurltree}\n * @see [Routing and Navigation guide](guide/router)\n * @see {@link UrlCreationOptions}\n * @see {@link NavigationBehaviorOptions}\n *\n * @publicApi\n */\nexport interface NavigationExtras extends UrlCreationOptions, NavigationBehaviorOptions {}\n\nexport type RestoredState = {\n  [k: string]: any,\n  // TODO(#27607): Remove `navigationId` and `ɵrouterPageId` and move to `ng` or `ɵ` namespace.\n  navigationId: number,\n  // The `ɵ` prefix is there to reduce the chance of colliding with any existing user properties on\n  // the history state.\n  ɵrouterPageId?: number,\n};\n\n/**\n * Information about a navigation operation.\n * Retrieve the most recent navigation object with the\n * [Router.getCurrentNavigation() method](api/router/Router#getcurrentnavigation) .\n *\n * * *id* : The unique identifier of the current navigation.\n * * *initialUrl* : The target URL passed into the `Router#navigateByUrl()` call before navigation.\n * This is the value before the router has parsed or applied redirects to it.\n * * *extractedUrl* : The initial target URL after being parsed with `UrlSerializer.extract()`.\n * * *finalUrl* : The extracted URL after redirects have been applied.\n * This URL may not be available immediately, therefore this property can be `undefined`.\n * It is guaranteed to be set after the `RoutesRecognized` event fires.\n * * *trigger* : Identifies how this navigation was triggered.\n * -- 'imperative'--Triggered by `router.navigateByUrl` or `router.navigate`.\n * -- 'popstate'--Triggered by a popstate event.\n * -- 'hashchange'--Triggered by a hashchange event.\n * * *extras* : A `NavigationExtras` options object that controlled the strategy used for this\n * navigation.\n * * *previousNavigation* : The previously successful `Navigation` object. Only one previous\n * navigation is available, therefore this previous `Navigation` object has a `null` value for its\n * own `previousNavigation`.\n *\n * @publicApi\n */\nexport interface Navigation {\n  /**\n   * The unique identifier of the current navigation.\n   */\n  id: number;\n  /**\n   * The target URL passed into the `Router#navigateByUrl()` call before navigation. This is\n   * the value before the router has parsed or applied redirects to it.\n   */\n  initialUrl: UrlTree;\n  /**\n   * The initial target URL after being parsed with `UrlHandlingStrategy.extract()`.\n   */\n  extractedUrl: UrlTree;\n  /**\n   * The extracted URL after redirects have been applied.\n   * This URL may not be available immediately, therefore this property can be `undefined`.\n   * It is guaranteed to be set after the `RoutesRecognized` event fires.\n   */\n  finalUrl?: UrlTree;\n  /**\n   * TODO(atscott): If we want to make StateManager public, they will need access to this. Note that\n   * it's already eventually exposed through router.routerState.\n   * @internal\n   */\n  targetRouterState?: RouterState;\n  /**\n   * Identifies how this navigation was triggered.\n   *\n   * * 'imperative'--Triggered by `router.navigateByUrl` or `router.navigate`.\n   * * 'popstate'--Triggered by a popstate event.\n   * * 'hashchange'--Triggered by a hashchange event.\n   */\n  trigger: 'imperative'|'popstate'|'hashchange';\n  /**\n   * Options that controlled the strategy used for this navigation.\n   * See `NavigationExtras`.\n   */\n  extras: NavigationExtras;\n  /**\n   * The previously successful `Navigation` object. Only one previous navigation\n   * is available, therefore this previous `Navigation` object has a `null` value\n   * for its own `previousNavigation`.\n   */\n  previousNavigation: Navigation|null;\n}\n\nexport interface NavigationTransition {\n  id: number;\n  currentUrlTree: UrlTree;\n  extractedUrl: UrlTree;\n  currentRawUrl: UrlTree;\n  urlAfterRedirects?: UrlTree;\n  rawUrl: UrlTree;\n  extras: NavigationExtras;\n  resolve: any;\n  reject: any;\n  promise: Promise<boolean>;\n  source: NavigationTrigger;\n  restoredState: RestoredState|null;\n  currentSnapshot: RouterStateSnapshot;\n  targetSnapshot: RouterStateSnapshot|null;\n  currentRouterState: RouterState;\n  targetRouterState: RouterState|null;\n  guards: Checks;\n  guardsResult: boolean|UrlTree|null;\n}\n\n/**\n * The interface from the Router needed by the transitions. Used to avoid a circular dependency on\n * Router. This interface should be whittled down with future refactors. For example, we do not need\n * to get `UrlSerializer` from the Router. We can instead inject it in `NavigationTransitions`\n * directly.\n */\ninterface InternalRouterInterface {\n  config: Routes;\n  // All of these are public API of router interface and can change during runtime because they are\n  // writeable. Ideally, these would be removed and the values retrieved instead from the values\n  // available in DI.\n  errorHandler: (error: any) => any;\n  navigated: boolean;\n  routeReuseStrategy: RouteReuseStrategy;\n  onSameUrlNavigation: 'reload'|'ignore';\n}\n\n@Injectable({providedIn: 'root'})\nexport class NavigationTransitions {\n  currentNavigation: Navigation|null = null;\n  currentTransition: NavigationTransition|null = null;\n  lastSuccessfulNavigation: Navigation|null = null;\n  /**\n   * These events are used to communicate back to the Router about the state of the transition. The\n   * Router wants to respond to these events in various ways. Because the `NavigationTransition`\n   * class is not public, this event subject is not publicly exposed.\n   */\n  readonly events = new Subject<Event|BeforeActivateRoutes|RedirectRequest>();\n  /**\n   * Used to abort the current transition with an error.\n   */\n  readonly transitionAbortSubject = new Subject<Error>();\n  private readonly configLoader = inject(RouterConfigLoader);\n  private readonly environmentInjector = inject(EnvironmentInjector);\n  private readonly urlSerializer = inject(UrlSerializer);\n  private readonly rootContexts = inject(ChildrenOutletContexts);\n  private readonly location = inject(Location);\n  private readonly inputBindingEnabled = inject(INPUT_BINDER, {optional: true}) !== null;\n  private readonly titleStrategy?: TitleStrategy = inject(TitleStrategy);\n  private readonly options = inject(ROUTER_CONFIGURATION, {optional: true}) || {};\n  private readonly paramsInheritanceStrategy =\n      this.options.paramsInheritanceStrategy || 'emptyOnly';\n  private readonly urlHandlingStrategy = inject(UrlHandlingStrategy);\n  private readonly createViewTransition = inject(CREATE_VIEW_TRANSITION, {optional: true});\n\n  navigationId = 0;\n  get hasRequestedNavigation() {\n    return this.navigationId !== 0;\n  }\n  private transitions?: BehaviorSubject<NavigationTransition>;\n  /**\n   * Hook that enables you to pause navigation after the preactivation phase.\n   * Used by `RouterModule`.\n   *\n   * @internal\n   */\n  afterPreactivation: () => Observable<void> = () => of(void 0);\n  /** @internal */\n  rootComponentType: Type<any>|null = null;\n\n  constructor() {\n    const onLoadStart = (r: Route) => this.events.next(new RouteConfigLoadStart(r));\n    const onLoadEnd = (r: Route) => this.events.next(new RouteConfigLoadEnd(r));\n    this.configLoader.onLoadEndListener = onLoadEnd;\n    this.configLoader.onLoadStartListener = onLoadStart;\n  }\n\n  complete() {\n    this.transitions?.complete();\n  }\n\n  handleNavigationRequest(\n      request: Pick<\n          NavigationTransition,\n          'source'|'restoredState'|'currentUrlTree'|'currentRawUrl'|'rawUrl'|'extras'|'resolve'|\n          'reject'|'promise'|'currentSnapshot'|'currentRouterState'>) {\n    const id = ++this.navigationId;\n    this.transitions?.next({...this.transitions.value, ...request, id});\n  }\n\n  setupNavigations(\n      router: InternalRouterInterface, initialUrlTree: UrlTree,\n      initialRouterState: RouterState): Observable<NavigationTransition> {\n    this.transitions = new BehaviorSubject<NavigationTransition>({\n      id: 0,\n      currentUrlTree: initialUrlTree,\n      currentRawUrl: initialUrlTree,\n      extractedUrl: this.urlHandlingStrategy.extract(initialUrlTree),\n      urlAfterRedirects: this.urlHandlingStrategy.extract(initialUrlTree),\n      rawUrl: initialUrlTree,\n      extras: {},\n      resolve: null,\n      reject: null,\n      promise: Promise.resolve(true),\n      source: IMPERATIVE_NAVIGATION,\n      restoredState: null,\n      currentSnapshot: initialRouterState.snapshot,\n      targetSnapshot: null,\n      currentRouterState: initialRouterState,\n      targetRouterState: null,\n      guards: {canActivateChecks: [], canDeactivateChecks: []},\n      guardsResult: null,\n    });\n    return this.transitions.pipe(\n               filter(t => t.id !== 0),\n\n               // Extract URL\n               map(t =>\n                       ({...t, extractedUrl: this.urlHandlingStrategy.extract(t.rawUrl)} as\n                        NavigationTransition)),\n\n               // Using switchMap so we cancel executing navigations when a new one comes in\n               switchMap(overallTransitionState => {\n                 this.currentTransition = overallTransitionState;\n                 let completed = false;\n                 let errored = false;\n                 return of(overallTransitionState)\n                     .pipe(\n                         // Store the Navigation object\n                         tap(t => {\n                           this.currentNavigation = {\n                             id: t.id,\n                             initialUrl: t.rawUrl,\n                             extractedUrl: t.extractedUrl,\n                             trigger: t.source,\n                             extras: t.extras,\n                             previousNavigation: !this.lastSuccessfulNavigation ? null : {\n                               ...this.lastSuccessfulNavigation,\n                               previousNavigation: null,\n                             },\n                           };\n                         }),\n                         switchMap(t => {\n                           const urlTransition = !router.navigated ||\n                               this.isUpdatingInternalState() || this.isUpdatedBrowserUrl();\n\n                           const onSameUrlNavigation =\n                               t.extras.onSameUrlNavigation ?? router.onSameUrlNavigation;\n                           if (!urlTransition && onSameUrlNavigation !== 'reload') {\n                             const reason = (typeof ngDevMode === 'undefined' || ngDevMode) ?\n                                 `Navigation to ${\n                                     t.rawUrl} was ignored because it is the same as the current Router URL.` :\n                                 '';\n                             this.events.next(new NavigationSkipped(\n                                 t.id, this.urlSerializer.serialize(t.rawUrl), reason,\n                                 NavigationSkippedCode.IgnoredSameUrlNavigation));\n                             t.resolve(null);\n                             return EMPTY;\n                           }\n\n                           if (this.urlHandlingStrategy.shouldProcessUrl(t.rawUrl)) {\n                             return of(t).pipe(\n                                 // Fire NavigationStart event\n                                 switchMap(t => {\n                                   const transition = this.transitions?.getValue();\n                                   this.events.next(new NavigationStart(\n                                       t.id, this.urlSerializer.serialize(t.extractedUrl), t.source,\n                                       t.restoredState));\n                                   if (transition !== this.transitions?.getValue()) {\n                                     return EMPTY;\n                                   }\n\n                                   // This delay is required to match old behavior that forced\n                                   // navigation to always be async\n                                   return Promise.resolve(t);\n                                 }),\n\n                                 // Recognize\n                                 recognize(\n                                     this.environmentInjector, this.configLoader,\n                                     this.rootComponentType, router.config, this.urlSerializer,\n                                     this.paramsInheritanceStrategy),\n\n                                 // Update URL if in `eager` update mode\n                                 tap(t => {\n                                   overallTransitionState.targetSnapshot = t.targetSnapshot;\n                                   overallTransitionState.urlAfterRedirects = t.urlAfterRedirects;\n                                   this.currentNavigation = {\n                                     ...this.currentNavigation!,\n                                     finalUrl: t.urlAfterRedirects\n                                   };\n\n                                   // Fire RoutesRecognized\n                                   const routesRecognized = new RoutesRecognized(\n                                       t.id, this.urlSerializer.serialize(t.extractedUrl),\n                                       this.urlSerializer.serialize(t.urlAfterRedirects!),\n                                       t.targetSnapshot!);\n                                   this.events.next(routesRecognized);\n                                 }));\n                           } else if (\n                               urlTransition &&\n                               this.urlHandlingStrategy.shouldProcessUrl(t.currentRawUrl)) {\n                             /* When the current URL shouldn't be processed, but the previous one\n                              * was, we handle this \"error condition\" by navigating to the\n                              * previously successful URL, but leaving the URL intact.*/\n                             const {id, extractedUrl, source, restoredState, extras} = t;\n                             const navStart = new NavigationStart(\n                                 id, this.urlSerializer.serialize(extractedUrl), source,\n                                 restoredState);\n                             this.events.next(navStart);\n                             const targetSnapshot =\n                                 createEmptyState(extractedUrl, this.rootComponentType).snapshot;\n\n                             this.currentTransition = overallTransitionState = {\n                               ...t,\n                               targetSnapshot,\n                               urlAfterRedirects: extractedUrl,\n                               extras: {...extras, skipLocationChange: false, replaceUrl: false},\n                             };\n                             this.currentNavigation!.finalUrl = extractedUrl;\n                             return of(overallTransitionState);\n                           } else {\n                             /* When neither the current or previous URL can be processed, do\n                              * nothing other than update router's internal reference to the\n                              * current \"settled\" URL. This way the next navigation will be coming\n                              * from the current URL in the browser.\n                              */\n                             const reason = (typeof ngDevMode === 'undefined' || ngDevMode) ?\n                                 `Navigation was ignored because the UrlHandlingStrategy` +\n                                     ` indicated neither the current URL ${\n                                         t.currentRawUrl} nor target URL ${\n                                         t.rawUrl} should be processed.` :\n                                 '';\n                             this.events.next(new NavigationSkipped(\n                                 t.id, this.urlSerializer.serialize(t.extractedUrl), reason,\n                                 NavigationSkippedCode.IgnoredByUrlHandlingStrategy));\n                             t.resolve(null);\n                             return EMPTY;\n                           }\n                         }),\n\n                         // --- GUARDS ---\n                         tap(t => {\n                           const guardsStart = new GuardsCheckStart(\n                               t.id, this.urlSerializer.serialize(t.extractedUrl),\n                               this.urlSerializer.serialize(t.urlAfterRedirects!),\n                               t.targetSnapshot!);\n                           this.events.next(guardsStart);\n                         }),\n\n                         map(t => {\n                           this.currentTransition = overallTransitionState = {\n                             ...t,\n                             guards: getAllRouteGuards(\n                                 t.targetSnapshot!, t.currentSnapshot, this.rootContexts)\n                           };\n                           return overallTransitionState;\n                         }),\n\n                         checkGuards(\n                             this.environmentInjector, (evt: Event) => this.events.next(evt)),\n                         tap(t => {\n                           overallTransitionState.guardsResult = t.guardsResult;\n                           if (isUrlTree(t.guardsResult)) {\n                             throw redirectingNavigationError(this.urlSerializer, t.guardsResult);\n                           }\n\n                           const guardsEnd = new GuardsCheckEnd(\n                               t.id, this.urlSerializer.serialize(t.extractedUrl),\n                               this.urlSerializer.serialize(t.urlAfterRedirects!),\n                               t.targetSnapshot!, !!t.guardsResult);\n                           this.events.next(guardsEnd);\n                         }),\n\n                         filter(t => {\n                           if (!t.guardsResult) {\n                             this.cancelNavigationTransition(\n                                 t, '', NavigationCancellationCode.GuardRejected);\n                             return false;\n                           }\n                           return true;\n                         }),\n\n                         // --- RESOLVE ---\n                         switchTap(t => {\n                           if (t.guards.canActivateChecks.length) {\n                             return of(t).pipe(\n                                 tap(t => {\n                                   const resolveStart = new ResolveStart(\n                                       t.id, this.urlSerializer.serialize(t.extractedUrl),\n                                       this.urlSerializer.serialize(t.urlAfterRedirects!),\n                                       t.targetSnapshot!);\n                                   this.events.next(resolveStart);\n                                 }),\n                                 switchMap(t => {\n                                   let dataResolved = false;\n                                   return of(t).pipe(\n                                       resolveData(\n                                           this.paramsInheritanceStrategy,\n                                           this.environmentInjector),\n                                       tap({\n                                         next: () => dataResolved = true,\n                                         complete: () => {\n                                           if (!dataResolved) {\n                                             this.cancelNavigationTransition(\n                                                 t,\n                                                 (typeof ngDevMode === 'undefined' || ngDevMode) ?\n                                                     `At least one route resolver didn't emit any value.` :\n                                                     '',\n                                                 NavigationCancellationCode.NoDataFromResolver);\n                                           }\n                                         }\n                                       }),\n                                   );\n                                 }),\n                                 tap(t => {\n                                   const resolveEnd = new ResolveEnd(\n                                       t.id, this.urlSerializer.serialize(t.extractedUrl),\n                                       this.urlSerializer.serialize(t.urlAfterRedirects!),\n                                       t.targetSnapshot!);\n                                   this.events.next(resolveEnd);\n                                 }));\n                           }\n                           return undefined;\n                         }),\n\n                         // --- LOAD COMPONENTS ---\n                         switchTap((t: NavigationTransition) => {\n                           const loadComponents =\n                               (route: ActivatedRouteSnapshot): Array<Observable<void>> => {\n                                 const loaders: Array<Observable<void>> = [];\n                                 if (route.routeConfig?.loadComponent &&\n                                     !route.routeConfig._loadedComponent) {\n                                   loaders.push(this.configLoader.loadComponent(route.routeConfig)\n                                                    .pipe(\n                                                        tap(loadedComponent => {\n                                                          route.component = loadedComponent;\n                                                        }),\n                                                        map(() => void 0),\n                                                        ));\n                                 }\n                                 for (const child of route.children) {\n                                   loaders.push(...loadComponents(child));\n                                 }\n                                 return loaders;\n                               };\n                           return combineLatest(loadComponents(t.targetSnapshot!.root))\n                               .pipe(defaultIfEmpty(), take(1));\n                         }),\n\n                         switchTap(() => this.afterPreactivation()),\n\n                         switchMap(() => {\n                           const {currentSnapshot, targetSnapshot} = overallTransitionState;\n                           const viewTransitionStarted = this.createViewTransition?.(\n                               this.environmentInjector, currentSnapshot.root,\n                               targetSnapshot!.root);\n\n                           // If view transitions are enabled, block the navigation until the view\n                           // transition callback starts. Otherwise, continue immediately.\n                           return viewTransitionStarted ?\n                               from(viewTransitionStarted).pipe(map(() => overallTransitionState)) :\n                               of(overallTransitionState);\n                         }),\n\n                         map((t: NavigationTransition) => {\n                           const targetRouterState = createRouterState(\n                               router.routeReuseStrategy, t.targetSnapshot!, t.currentRouterState);\n                           this.currentTransition =\n                               overallTransitionState = {...t, targetRouterState};\n                           this.currentNavigation!.targetRouterState = targetRouterState;\n                           return overallTransitionState;\n                         }),\n\n                         tap(() => {\n                           this.events.next(new BeforeActivateRoutes());\n                         }),\n\n                         activateRoutes(\n                             this.rootContexts, router.routeReuseStrategy,\n                             (evt: Event) => this.events.next(evt), this.inputBindingEnabled),\n\n                         // Ensure that if some observable used to drive the transition doesn't\n                         // complete, the navigation still finalizes This should never happen, but\n                         // this is done as a safety measure to avoid surfacing this error (#49567).\n                         take(1),\n\n                         tap({\n                           next: (t: NavigationTransition) => {\n                             completed = true;\n                             this.lastSuccessfulNavigation = this.currentNavigation;\n                             this.events.next(new NavigationEnd(\n                                 t.id, this.urlSerializer.serialize(t.extractedUrl),\n                                 this.urlSerializer.serialize(t.urlAfterRedirects!)));\n                             this.titleStrategy?.updateTitle(t.targetRouterState!.snapshot);\n                             t.resolve(true);\n                           },\n                           complete: () => {\n                             completed = true;\n                           }\n                         }),\n\n                         // There used to be a lot more logic happening directly within the\n                         // transition Observable. Some of this logic has been refactored out to\n                         // other places but there may still be errors that happen there. This gives\n                         // us a way to cancel the transition from the outside. This may also be\n                         // required in the future to support something like the abort signal of the\n                         // Navigation API where the navigation gets aborted from outside the\n                         // transition.\n                         takeUntil(this.transitionAbortSubject.pipe(tap(err => {\n                           throw err;\n                         }))),\n\n                         finalize(() => {\n                           /* When the navigation stream finishes either through error or success,\n                            * we set the `completed` or `errored` flag. However, there are some\n                            * situations where we could get here without either of those being set.\n                            * For instance, a redirect during NavigationStart. Therefore, this is a\n                            * catch-all to make sure the NavigationCancel event is fired when a\n                            * navigation gets cancelled but not caught by other means. */\n                           if (!completed && !errored) {\n                             const cancelationReason =\n                                 (typeof ngDevMode === 'undefined' || ngDevMode) ?\n                                 `Navigation ID ${\n                                     overallTransitionState\n                                         .id} is not equal to the current navigation id ${\n                                     this.navigationId}` :\n                                 '';\n                             this.cancelNavigationTransition(\n                                 overallTransitionState, cancelationReason,\n                                 NavigationCancellationCode.SupersededByNewNavigation);\n                           }\n                           // Only clear current navigation if it is still set to the one that\n                           // finalized.\n                           if (this.currentNavigation?.id === overallTransitionState.id) {\n                             this.currentNavigation = null;\n                           }\n                         }),\n                         catchError((e) => {\n                           errored = true;\n                           /* This error type is issued during Redirect, and is handled as a\n                            * cancellation rather than an error. */\n                           if (isNavigationCancelingError(e)) {\n                             this.events.next(new NavigationCancel(\n                                 overallTransitionState.id,\n                                 this.urlSerializer.serialize(overallTransitionState.extractedUrl),\n                                 e.message, e.cancellationCode));\n\n                             // When redirecting, we need to delay resolving the navigation\n                             // promise and push it to the redirect navigation\n                             if (!isRedirectingNavigationCancelingError(e)) {\n                               overallTransitionState.resolve(false);\n                             } else {\n                               this.events.next(new RedirectRequest(e.url));\n                             }\n\n                             /* All other errors should reset to the router's internal URL reference\n                              * to the pre-error state. */\n                           } else {\n                             this.events.next(new NavigationError(\n                                 overallTransitionState.id,\n                                 this.urlSerializer.serialize(overallTransitionState.extractedUrl),\n                                 e, overallTransitionState.targetSnapshot ?? undefined));\n                             try {\n                               overallTransitionState.resolve(router.errorHandler(e));\n                             } catch (ee) {\n                               overallTransitionState.reject(ee);\n                             }\n                           }\n                           return EMPTY;\n                         }));\n                 // casting because `pipe` returns observable({}) when called with 8+ arguments\n               })) as Observable<NavigationTransition>;\n  }\n\n  private cancelNavigationTransition(\n      t: NavigationTransition, reason: string, code: NavigationCancellationCode) {\n    const navCancel =\n        new NavigationCancel(t.id, this.urlSerializer.serialize(t.extractedUrl), reason, code);\n    this.events.next(navCancel);\n    t.resolve(false);\n  }\n\n  /**\n   * @returns Whether we're navigating to somewhere that is not what the Router is\n   * currently set to.\n   */\n  private isUpdatingInternalState() {\n    // TODO(atscott): The serializer should likely be used instead of\n    // `UrlTree.toString()`. Custom serializers are often written to handle\n    // things better than the default one (objects, for example will be\n    // [Object object] with the custom serializer and be \"the same\" when they\n    // aren't).\n    // (Same for isUpdatedBrowserUrl)\n    return this.currentTransition?.extractedUrl.toString() !==\n        this.currentTransition?.currentUrlTree.toString();\n  }\n\n  /**\n   * @returns Whether we're updating the browser URL to something new (navigation is going\n   * to somewhere not displayed in the URL bar and we will update the URL\n   * bar if navigation succeeds).\n   */\n  private isUpdatedBrowserUrl() {\n    // The extracted URL is the part of the URL that this application cares about. `extract` may\n    // return only part of the browser URL and that part may have not changed even if some other\n    // portion of the URL did.\n    const extractedBrowserUrl =\n        this.urlHandlingStrategy.extract(this.urlSerializer.parse(this.location.path(true)));\n    return extractedBrowserUrl.toString() !== this.currentTransition?.extractedUrl.toString() &&\n        !this.currentTransition?.extras.skipLocationChange;\n  }\n}\n\nexport function isBrowserTriggeredNavigation(source: NavigationTrigger) {\n  return source !== IMPERATIVE_NAVIGATION;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ComponentRef, inject, Injectable} from '@angular/core';\n\nimport {OutletContext} from './router_outlet_context';\nimport {ActivatedRoute, ActivatedRouteSnapshot} from './router_state';\nimport {TreeNode} from './utils/tree';\n\n/**\n * @description\n *\n * Represents the detached route tree.\n *\n * This is an opaque value the router will give to a custom route reuse strategy\n * to store and retrieve later on.\n *\n * @publicApi\n */\nexport type DetachedRouteHandle = {};\n\n/** @internal */\nexport type DetachedRouteHandleInternal = {\n  contexts: Map<string, OutletContext>,\n  componentRef: ComponentRef<any>,\n  route: TreeNode<ActivatedRoute>,\n};\n\n/**\n * @description\n *\n * Provides a way to customize when activated routes get reused.\n *\n * @publicApi\n */\n@Injectable({providedIn: 'root', useFactory: () => inject(DefaultRouteReuseStrategy)})\nexport abstract class RouteReuseStrategy {\n  /** Determines if this route (and its subtree) should be detached to be reused later */\n  abstract shouldDetach(route: ActivatedRouteSnapshot): boolean;\n\n  /**\n   * Stores the detached route.\n   *\n   * Storing a `null` value should erase the previously stored value.\n   */\n  abstract store(route: ActivatedRouteSnapshot, handle: DetachedRouteHandle|null): void;\n\n  /** Determines if this route (and its subtree) should be reattached */\n  abstract shouldAttach(route: ActivatedRouteSnapshot): boolean;\n\n  /** Retrieves the previously stored route */\n  abstract retrieve(route: ActivatedRouteSnapshot): DetachedRouteHandle|null;\n\n  /** Determines if a route should be reused */\n  abstract shouldReuseRoute(future: ActivatedRouteSnapshot, curr: ActivatedRouteSnapshot): boolean;\n}\n\n/**\n * @description\n *\n * This base route reuse strategy only reuses routes when the matched router configs are\n * identical. This prevents components from being destroyed and recreated\n * when just the route parameters, query parameters or fragment change\n * (that is, the existing component is _reused_).\n *\n * This strategy does not store any routes for later reuse.\n *\n * Angular uses this strategy by default.\n *\n *\n * It can be used as a base class for custom route reuse strategies, i.e. you can create your own\n * class that extends the `BaseRouteReuseStrategy` one.\n * @publicApi\n */\nexport abstract class BaseRouteReuseStrategy implements RouteReuseStrategy {\n  /**\n   * Whether the given route should detach for later reuse.\n   * Always returns false for `BaseRouteReuseStrategy`.\n   * */\n  shouldDetach(route: ActivatedRouteSnapshot): boolean {\n    return false;\n  }\n\n  /**\n   * A no-op; the route is never stored since this strategy never detaches routes for later re-use.\n   */\n  store(route: ActivatedRouteSnapshot, detachedTree: DetachedRouteHandle): void {}\n\n  /** Returns `false`, meaning the route (and its subtree) is never reattached */\n  shouldAttach(route: ActivatedRouteSnapshot): boolean {\n    return false;\n  }\n\n  /** Returns `null` because this strategy does not store routes for later re-use. */\n  retrieve(route: ActivatedRouteSnapshot): DetachedRouteHandle|null {\n    return null;\n  }\n\n  /**\n   * Determines if a route should be reused.\n   * This strategy returns `true` when the future route config and current route config are\n   * identical.\n   */\n  shouldReuseRoute(future: ActivatedRouteSnapshot, curr: ActivatedRouteSnapshot): boolean {\n    return future.routeConfig === curr.routeConfig;\n  }\n}\n\n@Injectable({providedIn: 'root'})\nexport class DefaultRouteReuseStrategy extends BaseRouteReuseStrategy {\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Location} from '@angular/common';\nimport {inject, Injectable} from '@angular/core';\nimport {SubscriptionLike} from 'rxjs';\n\nimport {BeforeActivateRoutes, Event, NavigationCancel, NavigationCancellationCode, NavigationEnd, NavigationError, NavigationSkipped, NavigationStart, PrivateRouterEvents, RoutesRecognized,} from '../events';\nimport {Navigation, RestoredState} from '../navigation_transition';\nimport {ROUTER_CONFIGURATION} from '../router_config';\nimport {createEmptyState, RouterState} from '../router_state';\nimport {UrlHandlingStrategy} from '../url_handling_strategy';\nimport {UrlSerializer, UrlTree} from '../url_tree';\n\n@Injectable({providedIn: 'root', useFactory: () => inject(HistoryStateManager)})\nexport abstract class StateManager {\n  /**\n   * Returns the currently activated `UrlTree`.\n   *\n   * This `UrlTree` shows only URLs that the `Router` is configured to handle (through\n   * `UrlHandlingStrategy`).\n   *\n   * The value is set after finding the route config tree to activate but before activating the\n   * route.\n   */\n  abstract getCurrentUrlTree(): UrlTree;\n\n  /**\n   * Returns a `UrlTree` that is represents what the browser is actually showing.\n   *\n   * In the life of a navigation transition:\n   * 1. When a navigation begins, the raw `UrlTree` is updated to the full URL that's being\n   * navigated to.\n   * 2. During a navigation, redirects are applied, which might only apply to _part_ of the URL (due\n   * to `UrlHandlingStrategy`).\n   * 3. Just before activation, the raw `UrlTree` is updated to include the redirects on top of the\n   * original raw URL.\n   *\n   * Note that this is _only_ here to support `UrlHandlingStrategy.extract` and\n   * `UrlHandlingStrategy.shouldProcessUrl`. Without those APIs, the current `UrlTree` would not\n   * deviated from the raw `UrlTree`.\n   *\n   * For `extract`, a raw `UrlTree` is needed because `extract` may only return part\n   * of the navigation URL. Thus, the current `UrlTree` may only represent _part_ of the browser\n   * URL. When a navigation gets cancelled and the router needs to reset the URL or a new navigation\n   * occurs, it needs to know the _whole_ browser URL, not just the part handled by\n   * `UrlHandlingStrategy`.\n   * For `shouldProcessUrl`, when the return is `false`, the router ignores the navigation but\n   * still updates the raw `UrlTree` with the assumption that the navigation was caused by the\n   * location change listener due to a URL update by the AngularJS router. In this case, the router\n   * still need to know what the browser's URL is for future navigations.\n   */\n  abstract getRawUrlTree(): UrlTree;\n\n  /** Returns the current state stored by the browser for the current history entry. */\n  abstract restoredState(): RestoredState|null|undefined;\n\n  /** Returns the current RouterState. */\n  abstract getRouterState(): RouterState;\n\n  /**\n   * Registers a listener that is called whenever the current history entry changes by some API\n   * outside the Router. This includes user-activated changes like back buttons and link clicks, but\n   * also includes programmatic APIs called by non-Router JavaScript.\n   */\n  abstract registerNonRouterCurrentEntryChangeListener(\n      listener: (url: string, state: RestoredState|null|undefined) => void): SubscriptionLike;\n\n  /**\n   * Handles a navigation event sent from the Router. These are typically events that indicate a\n   * navigation has started, progressed, been cancelled, or finished.\n   */\n  abstract handleRouterEvent(e: Event|PrivateRouterEvents, currentTransition: Navigation): void;\n}\n\n@Injectable({providedIn: 'root'})\nexport class HistoryStateManager extends StateManager {\n  private readonly location = inject(Location);\n  private readonly urlSerializer = inject(UrlSerializer);\n  private readonly options = inject(ROUTER_CONFIGURATION, {optional: true}) || {};\n  private readonly canceledNavigationResolution =\n      this.options.canceledNavigationResolution || 'replace';\n\n  private urlHandlingStrategy = inject(UrlHandlingStrategy);\n  private urlUpdateStrategy = this.options.urlUpdateStrategy || 'deferred';\n\n  private currentUrlTree = new UrlTree();\n\n  override getCurrentUrlTree() {\n    return this.currentUrlTree;\n  }\n\n  private rawUrlTree = this.currentUrlTree;\n\n  override getRawUrlTree() {\n    return this.rawUrlTree;\n  }\n\n  /**\n   * The id of the currently active page in the router.\n   * Updated to the transition's target id on a successful navigation.\n   *\n   * This is used to track what page the router last activated. When an attempted navigation fails,\n   * the router can then use this to compute how to restore the state back to the previously active\n   * page.\n   */\n  private currentPageId: number = 0;\n  private lastSuccessfulId: number = -1;\n\n  override restoredState(): RestoredState|null|undefined {\n    return this.location.getState() as RestoredState | null | undefined;\n  }\n\n  /**\n   * The ɵrouterPageId of whatever page is currently active in the browser history. This is\n   * important for computing the target page id for new navigations because we need to ensure each\n   * page id in the browser history is 1 more than the previous entry.\n   */\n  private get browserPageId(): number {\n    if (this.canceledNavigationResolution !== 'computed') {\n      return this.currentPageId;\n    }\n    return this.restoredState()?.ɵrouterPageId ?? this.currentPageId;\n  }\n\n  private routerState = createEmptyState(this.currentUrlTree, null);\n\n  override getRouterState() {\n    return this.routerState;\n  }\n\n  private stateMemento = this.createStateMemento();\n\n  private createStateMemento() {\n    return {\n      rawUrlTree: this.rawUrlTree,\n      currentUrlTree: this.currentUrlTree,\n      routerState: this.routerState,\n    };\n  }\n\n  override registerNonRouterCurrentEntryChangeListener(\n      listener: (url: string, state: RestoredState|null|undefined) => void): SubscriptionLike {\n    return this.location.subscribe(event => {\n      if (event['type'] === 'popstate') {\n        listener(event['url']!, event.state as RestoredState | null | undefined);\n      }\n    });\n  }\n\n  override handleRouterEvent(e: Event|PrivateRouterEvents, currentTransition: Navigation) {\n    if (e instanceof NavigationStart) {\n      this.stateMemento = this.createStateMemento();\n    } else if (e instanceof NavigationSkipped) {\n      this.rawUrlTree = currentTransition.initialUrl;\n    } else if (e instanceof RoutesRecognized) {\n      if (this.urlUpdateStrategy === 'eager') {\n        if (!currentTransition.extras.skipLocationChange) {\n          const rawUrl = this.urlHandlingStrategy.merge(\n              currentTransition.finalUrl!, currentTransition.initialUrl);\n          this.setBrowserUrl(rawUrl, currentTransition);\n        }\n      }\n    } else if (e instanceof BeforeActivateRoutes) {\n      this.currentUrlTree = currentTransition.finalUrl!;\n      this.rawUrlTree =\n          this.urlHandlingStrategy.merge(currentTransition.finalUrl!, currentTransition.initialUrl);\n      this.routerState = currentTransition.targetRouterState!;\n      if (this.urlUpdateStrategy === 'deferred') {\n        if (!currentTransition.extras.skipLocationChange) {\n          this.setBrowserUrl(this.rawUrlTree, currentTransition);\n        }\n      }\n    } else if (\n        e instanceof NavigationCancel &&\n        (e.code === NavigationCancellationCode.GuardRejected ||\n         e.code === NavigationCancellationCode.NoDataFromResolver)) {\n      this.restoreHistory(currentTransition);\n    } else if (e instanceof NavigationError) {\n      this.restoreHistory(currentTransition, true);\n    } else if (e instanceof NavigationEnd) {\n      this.lastSuccessfulId = e.id;\n      this.currentPageId = this.browserPageId;\n    }\n  }\n\n  private setBrowserUrl(url: UrlTree, transition: Navigation) {\n    const path = this.urlSerializer.serialize(url);\n    if (this.location.isCurrentPathEqualTo(path) || !!transition.extras.replaceUrl) {\n      // replacements do not update the target page\n      const currentBrowserPageId = this.browserPageId;\n      const state = {\n        ...transition.extras.state,\n        ...this.generateNgRouterState(transition.id, currentBrowserPageId)\n      };\n      this.location.replaceState(path, '', state);\n    } else {\n      const state = {\n        ...transition.extras.state,\n        ...this.generateNgRouterState(transition.id, this.browserPageId + 1)\n      };\n      this.location.go(path, '', state);\n    }\n  }\n\n  /**\n   * Performs the necessary rollback action to restore the browser URL to the\n   * state before the transition.\n   */\n  private restoreHistory(navigation: Navigation, restoringFromCaughtError = false) {\n    if (this.canceledNavigationResolution === 'computed') {\n      const currentBrowserPageId = this.browserPageId;\n      const targetPagePosition = this.currentPageId - currentBrowserPageId;\n      if (targetPagePosition !== 0) {\n        this.location.historyGo(targetPagePosition);\n      } else if (this.currentUrlTree === navigation.finalUrl && targetPagePosition === 0) {\n        // We got to the activation stage (where currentUrlTree is set to the navigation's\n        // finalUrl), but we weren't moving anywhere in history (skipLocationChange or replaceUrl).\n        // We still need to reset the router state back to what it was when the navigation started.\n        this.resetState(navigation);\n        this.resetUrlToCurrentUrlTree();\n      } else {\n        // The browser URL and router state was not updated before the navigation cancelled so\n        // there's no restoration needed.\n      }\n    } else if (this.canceledNavigationResolution === 'replace') {\n      // TODO(atscott): It seems like we should _always_ reset the state here. It would be a no-op\n      // for `deferred` navigations that haven't change the internal state yet because guards\n      // reject. For 'eager' navigations, it seems like we also really should reset the state\n      // because the navigation was cancelled. Investigate if this can be done by running TGP.\n      if (restoringFromCaughtError) {\n        this.resetState(navigation);\n      }\n      this.resetUrlToCurrentUrlTree();\n    }\n  }\n\n  private resetState(navigation: Navigation): void {\n    this.routerState = this.stateMemento.routerState;\n    this.currentUrlTree = this.stateMemento.currentUrlTree;\n    // Note here that we use the urlHandlingStrategy to get the reset `rawUrlTree` because it may be\n    // configured to handle only part of the navigation URL. This means we would only want to reset\n    // the part of the navigation handled by the Angular router rather than the whole URL. In\n    // addition, the URLHandlingStrategy may be configured to specifically preserve parts of the URL\n    // when merging, such as the query params so they are not lost on a refresh.\n    this.rawUrlTree =\n        this.urlHandlingStrategy.merge(this.currentUrlTree, navigation.finalUrl ?? this.rawUrlTree);\n  }\n\n  private resetUrlToCurrentUrlTree(): void {\n    this.location.replaceState(\n        this.urlSerializer.serialize(this.rawUrlTree), '',\n        this.generateNgRouterState(this.lastSuccessfulId, this.currentPageId));\n  }\n\n  private generateNgRouterState(navigationId: number, routerPageId: number) {\n    if (this.canceledNavigationResolution === 'computed') {\n      return {navigationId, ɵrouterPageId: routerPageId};\n    }\n    return {navigationId};\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Observable} from 'rxjs';\nimport {filter, map, take} from 'rxjs/operators';\n\nimport {Event, NavigationCancel, NavigationCancellationCode, NavigationEnd, NavigationError, NavigationSkipped} from '../events';\n\nenum NavigationResult {\n  COMPLETE,\n  FAILED,\n  REDIRECTING,\n}\n\n/**\n * Performs the given action once the router finishes its next/current navigation.\n *\n * The navigation is considered complete under the following conditions:\n * - `NavigationCancel` event emits and the code is not `NavigationCancellationCode.Redirect` or\n * `NavigationCancellationCode.SupersededByNewNavigation`. In these cases, the\n * redirecting/superseding navigation must finish.\n * - `NavigationError`, `NavigationEnd`, or `NavigationSkipped` event emits\n */\nexport function afterNextNavigation(router: {events: Observable<Event>}, action: () => void) {\n  router.events\n      .pipe(\n          filter(\n              (e): e is NavigationEnd|NavigationCancel|NavigationError|NavigationSkipped =>\n                  e instanceof NavigationEnd || e instanceof NavigationCancel ||\n                  e instanceof NavigationError || e instanceof NavigationSkipped),\n          map(e => {\n            if (e instanceof NavigationEnd || e instanceof NavigationSkipped) {\n              return NavigationResult.COMPLETE;\n            }\n            const redirecting = e instanceof NavigationCancel ?\n                (e.code === NavigationCancellationCode.Redirect ||\n                 e.code === NavigationCancellationCode.SupersededByNewNavigation) :\n                false;\n            return redirecting ? NavigationResult.REDIRECTING : NavigationResult.FAILED;\n          }),\n          filter(\n              (result): result is NavigationResult.COMPLETE|NavigationResult.FAILED =>\n                  result !== NavigationResult.REDIRECTING),\n          take(1),\n          )\n      .subscribe(() => {\n        action();\n      });\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Location} from '@angular/common';\nimport {inject, Injectable, NgZone, Type, ɵConsole as Console, ɵInitialRenderPendingTasks as InitialRenderPendingTasks, ɵRuntimeError as RuntimeError, ɵWritable as Writable} from '@angular/core';\nimport {Observable, Subject, Subscription, SubscriptionLike} from 'rxjs';\n\nimport {createSegmentGroupFromRoute, createUrlTreeFromSegmentGroup} from './create_url_tree';\nimport {INPUT_BINDER} from './directives/router_outlet';\nimport {RuntimeErrorCode} from './errors';\nimport {BeforeActivateRoutes, Event, IMPERATIVE_NAVIGATION, NavigationCancel, NavigationCancellationCode, NavigationEnd, NavigationTrigger, PrivateRouterEvents, RedirectRequest} from './events';\nimport {NavigationBehaviorOptions, OnSameUrlNavigation, Routes} from './models';\nimport {isBrowserTriggeredNavigation, Navigation, NavigationExtras, NavigationTransitions, RestoredState, UrlCreationOptions} from './navigation_transition';\nimport {RouteReuseStrategy} from './route_reuse_strategy';\nimport {ROUTER_CONFIGURATION} from './router_config';\nimport {ROUTES} from './router_config_loader';\nimport {Params} from './shared';\nimport {StateManager} from './statemanager/state_manager';\nimport {UrlHandlingStrategy} from './url_handling_strategy';\nimport {containsTree, IsActiveMatchOptions, isUrlTree, UrlSegmentGroup, UrlSerializer, UrlTree} from './url_tree';\nimport {standardizeConfig, validateConfig} from './utils/config';\nimport {afterNextNavigation} from './utils/navigations';\n\n\n\nfunction defaultErrorHandler(error: any): never {\n  throw error;\n}\n\n/**\n * The equivalent `IsActiveMatchOptions` options for `Router.isActive` is called with `true`\n * (exact = true).\n */\nexport const exactMatchOptions: IsActiveMatchOptions = {\n  paths: 'exact',\n  fragment: 'ignored',\n  matrixParams: 'ignored',\n  queryParams: 'exact'\n};\n\n/**\n * The equivalent `IsActiveMatchOptions` options for `Router.isActive` is called with `false`\n * (exact = false).\n */\nexport const subsetMatchOptions: IsActiveMatchOptions = {\n  paths: 'subset',\n  fragment: 'ignored',\n  matrixParams: 'ignored',\n  queryParams: 'subset'\n};\n\n/**\n * @description\n *\n * A service that provides navigation among views and URL manipulation capabilities.\n *\n * @see {@link Route}\n * @see [Routing and Navigation Guide](guide/router).\n *\n * @ngModule RouterModule\n *\n * @publicApi\n */\n@Injectable({providedIn: 'root'})\nexport class Router {\n  private get currentUrlTree() {\n    return this.stateManager.getCurrentUrlTree();\n  }\n  private get rawUrlTree() {\n    return this.stateManager.getRawUrlTree();\n  }\n  private disposed = false;\n  private nonRouterCurrentEntryChangeSubscription?: SubscriptionLike;\n  private isNgZoneEnabled = false;\n\n  private readonly console = inject(Console);\n  private readonly stateManager = inject(StateManager);\n  private readonly options = inject(ROUTER_CONFIGURATION, {optional: true}) || {};\n  private readonly pendingTasks = inject(InitialRenderPendingTasks);\n  private readonly urlUpdateStrategy = this.options.urlUpdateStrategy || 'deferred';\n  private readonly navigationTransitions = inject(NavigationTransitions);\n  private readonly urlSerializer = inject(UrlSerializer);\n  private readonly location = inject(Location);\n  private readonly urlHandlingStrategy = inject(UrlHandlingStrategy);\n\n  /**\n   * The private `Subject` type for the public events exposed in the getter. This is used internally\n   * to push events to. The separate field allows us to expose separate types in the public API\n   * (i.e., an Observable rather than the Subject).\n   */\n  private _events = new Subject<Event>();\n  /**\n   * An event stream for routing events.\n   */\n  public get events(): Observable<Event> {\n    // TODO(atscott): This _should_ be events.asObservable(). However, this change requires internal\n    // cleanup: tests are doing `(route.events as Subject<Event>).next(...)`. This isn't\n    // allowed/supported but we still have to fix these or file bugs against the teams before making\n    // the change.\n    return this._events;\n  }\n  /**\n   * The current state of routing in this NgModule.\n   */\n  get routerState() {\n    return this.stateManager.getRouterState();\n  }\n\n  /**\n   * A handler for navigation errors in this NgModule.\n   *\n   * @deprecated Subscribe to the `Router` events and watch for `NavigationError` instead.\n   *   `provideRouter` has the `withNavigationErrorHandler` feature to make this easier.\n   * @see {@link withNavigationErrorHandler}\n   */\n  errorHandler: (error: any) => any = this.options.errorHandler || defaultErrorHandler;\n\n  /**\n   * True if at least one navigation event has occurred,\n   * false otherwise.\n   */\n  navigated: boolean = false;\n\n  /**\n   * A strategy for re-using routes.\n   *\n   * @deprecated Configure using `providers` instead:\n   *   `{provide: RouteReuseStrategy, useClass: MyStrategy}`.\n   */\n  routeReuseStrategy: RouteReuseStrategy = inject(RouteReuseStrategy);\n\n  /**\n   * How to handle a navigation request to the current URL.\n   *\n   *\n   * @deprecated Configure this through `provideRouter` or `RouterModule.forRoot` instead.\n   * @see {@link withRouterConfig}\n   * @see {@link provideRouter}\n   * @see {@link RouterModule}\n   */\n  onSameUrlNavigation: OnSameUrlNavigation = this.options.onSameUrlNavigation || 'ignore';\n\n  config: Routes = inject(ROUTES, {optional: true})?.flat() ?? [];\n\n  /**\n   * Indicates whether the application has opted in to binding Router data to component inputs.\n   *\n   * This option is enabled by the `withComponentInputBinding` feature of `provideRouter` or\n   * `bindToComponentInputs` in the `ExtraOptions` of `RouterModule.forRoot`.\n   */\n  readonly componentInputBindingEnabled: boolean = !!inject(INPUT_BINDER, {optional: true});\n\n  constructor() {\n    this.isNgZoneEnabled = inject(NgZone) instanceof NgZone && NgZone.isInAngularZone();\n\n    this.resetConfig(this.config);\n\n    this.navigationTransitions.setupNavigations(this, this.currentUrlTree, this.routerState)\n        .subscribe({\n          error: (e) => {\n            this.console.warn(ngDevMode ? `Unhandled Navigation Error: ${e}` : e);\n          }\n        });\n    this.subscribeToNavigationEvents();\n  }\n\n\n  private eventsSubscription = new Subscription();\n  private subscribeToNavigationEvents() {\n    const subscription = this.navigationTransitions.events.subscribe(e => {\n      try {\n        const currentTransition = this.navigationTransitions.currentTransition;\n        const currentNavigation = this.navigationTransitions.currentNavigation;\n        if (currentTransition !== null && currentNavigation !== null) {\n          this.stateManager.handleRouterEvent(e, currentNavigation);\n          if (e instanceof NavigationCancel && e.code !== NavigationCancellationCode.Redirect &&\n              e.code !== NavigationCancellationCode.SupersededByNewNavigation) {\n            // It seems weird that `navigated` is set to `true` when the navigation is rejected,\n            // however it's how things were written initially. Investigation would need to be done\n            // to determine if this can be removed.\n            this.navigated = true;\n          } else if (e instanceof NavigationEnd) {\n            this.navigated = true;\n          } else if (e instanceof RedirectRequest) {\n            const mergedTree =\n                this.urlHandlingStrategy.merge(e.url, currentTransition.currentRawUrl);\n            const extras = {\n              skipLocationChange: currentTransition.extras.skipLocationChange,\n              // The URL is already updated at this point if we have 'eager' URL\n              // updates or if the navigation was triggered by the browser (back\n              // button, URL bar, etc). We want to replace that item in history\n              // if the navigation is rejected.\n              replaceUrl: this.urlUpdateStrategy === 'eager' ||\n                  isBrowserTriggeredNavigation(currentTransition.source)\n            };\n\n            this.scheduleNavigation(mergedTree, IMPERATIVE_NAVIGATION, null, extras, {\n              resolve: currentTransition.resolve,\n              reject: currentTransition.reject,\n              promise: currentTransition.promise\n            });\n          }\n        }\n        // Note that it's important to have the Router process the events _before_ the event is\n        // pushed through the public observable. This ensures the correct router state is in place\n        // before applications observe the events.\n        if (isPublicRouterEvent(e)) {\n          this._events.next(e);\n        }\n      } catch (e: unknown) {\n        this.navigationTransitions.transitionAbortSubject.next(e as Error);\n      }\n    });\n    this.eventsSubscription.add(subscription);\n  }\n\n  /** @internal */\n  resetRootComponentType(rootComponentType: Type<any>): void {\n    // TODO: vsavkin router 4.0 should make the root component set to null\n    // this will simplify the lifecycle of the router.\n    this.routerState.root.component = rootComponentType;\n    this.navigationTransitions.rootComponentType = rootComponentType;\n  }\n\n  /**\n   * Sets up the location change listener and performs the initial navigation.\n   */\n  initialNavigation(): void {\n    this.setUpLocationChangeListener();\n    if (!this.navigationTransitions.hasRequestedNavigation) {\n      this.navigateToSyncWithBrowser(\n          this.location.path(true), IMPERATIVE_NAVIGATION, this.stateManager.restoredState());\n    }\n  }\n\n  /**\n   * Sets up the location change listener. This listener detects navigations triggered from outside\n   * the Router (the browser back/forward buttons, for example) and schedules a corresponding Router\n   * navigation so that the correct events, guards, etc. are triggered.\n   */\n  setUpLocationChangeListener(): void {\n    // Don't need to use Zone.wrap any more, because zone.js\n    // already patch onPopState, so location change callback will\n    // run into ngZone\n    if (!this.nonRouterCurrentEntryChangeSubscription) {\n      this.nonRouterCurrentEntryChangeSubscription =\n          this.stateManager.registerNonRouterCurrentEntryChangeListener((url, state) => {\n            // The `setTimeout` was added in #12160 and is likely to support Angular/AngularJS\n            // hybrid apps.\n            setTimeout(() => {\n              this.navigateToSyncWithBrowser(url, 'popstate', state);\n            }, 0);\n          });\n    }\n  }\n\n  /**\n   * Schedules a router navigation to synchronize Router state with the browser state.\n   *\n   * This is done as a response to a popstate event and the initial navigation. These\n   * two scenarios represent times when the browser URL/state has been updated and\n   * the Router needs to respond to ensure its internal state matches.\n   */\n  private navigateToSyncWithBrowser(\n      url: string, source: NavigationTrigger, state: RestoredState|null|undefined) {\n    const extras: NavigationExtras = {replaceUrl: true};\n\n    // TODO: restoredState should always include the entire state, regardless\n    // of navigationId. This requires a breaking change to update the type on\n    // NavigationStart’s restoredState, which currently requires navigationId\n    // to always be present. The Router used to only restore history state if\n    // a navigationId was present.\n\n    // The stored navigationId is used by the RouterScroller to retrieve the scroll\n    // position for the page.\n    const restoredState = state?.navigationId ? state : null;\n\n    // Separate to NavigationStart.restoredState, we must also restore the state to\n    // history.state and generate a new navigationId, since it will be overwritten\n    if (state) {\n      const stateCopy = {...state} as Partial<RestoredState>;\n      delete stateCopy.navigationId;\n      delete stateCopy.ɵrouterPageId;\n      if (Object.keys(stateCopy).length !== 0) {\n        extras.state = stateCopy;\n      }\n    }\n\n    const urlTree = this.parseUrl(url);\n    this.scheduleNavigation(urlTree, source, restoredState, extras);\n  }\n\n  /** The current URL. */\n  get url(): string {\n    return this.serializeUrl(this.currentUrlTree);\n  }\n\n  /**\n   * Returns the current `Navigation` object when the router is navigating,\n   * and `null` when idle.\n   */\n  getCurrentNavigation(): Navigation|null {\n    return this.navigationTransitions.currentNavigation;\n  }\n\n  /**\n   * The `Navigation` object of the most recent navigation to succeed and `null` if there\n   *     has not been a successful navigation yet.\n   */\n  get lastSuccessfulNavigation(): Navigation|null {\n    return this.navigationTransitions.lastSuccessfulNavigation;\n  }\n\n  /**\n   * Resets the route configuration used for navigation and generating links.\n   *\n   * @param config The route array for the new configuration.\n   *\n   * @usageNotes\n   *\n   * ```\n   * router.resetConfig([\n   *  { path: 'team/:id', component: TeamCmp, children: [\n   *    { path: 'simple', component: SimpleCmp },\n   *    { path: 'user/:name', component: UserCmp }\n   *  ]}\n   * ]);\n   * ```\n   */\n  resetConfig(config: Routes): void {\n    (typeof ngDevMode === 'undefined' || ngDevMode) && validateConfig(config);\n    this.config = config.map(standardizeConfig);\n    this.navigated = false;\n  }\n\n  /** @nodoc */\n  ngOnDestroy(): void {\n    this.dispose();\n  }\n\n  /** Disposes of the router. */\n  dispose(): void {\n    this.navigationTransitions.complete();\n    if (this.nonRouterCurrentEntryChangeSubscription) {\n      this.nonRouterCurrentEntryChangeSubscription.unsubscribe();\n      this.nonRouterCurrentEntryChangeSubscription = undefined;\n    }\n    this.disposed = true;\n    this.eventsSubscription.unsubscribe();\n  }\n\n  /**\n   * Appends URL segments to the current URL tree to create a new URL tree.\n   *\n   * @param commands An array of URL fragments with which to construct the new URL tree.\n   * If the path is static, can be the literal URL string. For a dynamic path, pass an array of path\n   * segments, followed by the parameters for each segment.\n   * The fragments are applied to the current URL tree or the one provided  in the `relativeTo`\n   * property of the options object, if supplied.\n   * @param navigationExtras Options that control the navigation strategy.\n   * @returns The new URL tree.\n   *\n   * @usageNotes\n   *\n   * ```\n   * // create /team/33/user/11\n   * router.createUrlTree(['/team', 33, 'user', 11]);\n   *\n   * // create /team/33;expand=true/user/11\n   * router.createUrlTree(['/team', 33, {expand: true}, 'user', 11]);\n   *\n   * // you can collapse static segments like this (this works only with the first passed-in value):\n   * router.createUrlTree(['/team/33/user', userId]);\n   *\n   * // If the first segment can contain slashes, and you do not want the router to split it,\n   * // you can do the following:\n   * router.createUrlTree([{segmentPath: '/one/two'}]);\n   *\n   * // create /team/33/(user/11//right:chat)\n   * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: 'chat'}}]);\n   *\n   * // remove the right secondary node\n   * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: null}}]);\n   *\n   * // assuming the current url is `/team/33/user/11` and the route points to `user/11`\n   *\n   * // navigate to /team/33/user/11/details\n   * router.createUrlTree(['details'], {relativeTo: route});\n   *\n   * // navigate to /team/33/user/22\n   * router.createUrlTree(['../22'], {relativeTo: route});\n   *\n   * // navigate to /team/44/user/22\n   * router.createUrlTree(['../../team/44/user/22'], {relativeTo: route});\n   *\n   * Note that a value of `null` or `undefined` for `relativeTo` indicates that the\n   * tree should be created relative to the root.\n   * ```\n   */\n  createUrlTree(commands: any[], navigationExtras: UrlCreationOptions = {}): UrlTree {\n    const {relativeTo, queryParams, fragment, queryParamsHandling, preserveFragment} =\n        navigationExtras;\n    const f = preserveFragment ? this.currentUrlTree.fragment : fragment;\n    let q: Params|null = null;\n    switch (queryParamsHandling) {\n      case 'merge':\n        q = {...this.currentUrlTree.queryParams, ...queryParams};\n        break;\n      case 'preserve':\n        q = this.currentUrlTree.queryParams;\n        break;\n      default:\n        q = queryParams || null;\n    }\n    if (q !== null) {\n      q = this.removeEmptyProps(q);\n    }\n\n    let relativeToUrlSegmentGroup: UrlSegmentGroup|undefined;\n    try {\n      const relativeToSnapshot = relativeTo ? relativeTo.snapshot : this.routerState.snapshot.root;\n      relativeToUrlSegmentGroup = createSegmentGroupFromRoute(relativeToSnapshot);\n    } catch (e: unknown) {\n      // This is strictly for backwards compatibility with tests that create\n      // invalid `ActivatedRoute` mocks.\n      // Note: the difference between having this fallback for invalid `ActivatedRoute` setups and\n      // just throwing is ~500 test failures. Fixing all of those tests by hand is not feasible at\n      // the moment.\n      if (typeof commands[0] !== 'string' || !commands[0].startsWith('/')) {\n        // Navigations that were absolute in the old way of creating UrlTrees\n        // would still work because they wouldn't attempt to match the\n        // segments in the `ActivatedRoute` to the `currentUrlTree` but\n        // instead just replace the root segment with the navigation result.\n        // Non-absolute navigations would fail to apply the commands because\n        // the logic could not find the segment to replace (so they'd act like there were no\n        // commands).\n        commands = [];\n      }\n      relativeToUrlSegmentGroup = this.currentUrlTree.root;\n    }\n    return createUrlTreeFromSegmentGroup(relativeToUrlSegmentGroup, commands, q, f ?? null);\n  }\n\n  /**\n   * Navigates to a view using an absolute route path.\n   *\n   * @param url An absolute path for a defined route. The function does not apply any delta to the\n   *     current URL.\n   * @param extras An object containing properties that modify the navigation strategy.\n   *\n   * @returns A Promise that resolves to 'true' when navigation succeeds,\n   * to 'false' when navigation fails, or is rejected on error.\n   *\n   * @usageNotes\n   *\n   * The following calls request navigation to an absolute path.\n   *\n   * ```\n   * router.navigateByUrl(\"/team/33/user/11\");\n   *\n   * // Navigate without updating the URL\n   * router.navigateByUrl(\"/team/33/user/11\", { skipLocationChange: true });\n   * ```\n   *\n   * @see [Routing and Navigation guide](guide/router)\n   *\n   */\n  navigateByUrl(url: string|UrlTree, extras: NavigationBehaviorOptions = {\n    skipLocationChange: false\n  }): Promise<boolean> {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      if (this.isNgZoneEnabled && !NgZone.isInAngularZone()) {\n        this.console.warn(\n            `Navigation triggered outside Angular zone, did you forget to call 'ngZone.run()'?`);\n      }\n    }\n\n    const urlTree = isUrlTree(url) ? url : this.parseUrl(url);\n    const mergedTree = this.urlHandlingStrategy.merge(urlTree, this.rawUrlTree);\n\n    return this.scheduleNavigation(mergedTree, IMPERATIVE_NAVIGATION, null, extras);\n  }\n\n  /**\n   * Navigate based on the provided array of commands and a starting point.\n   * If no starting route is provided, the navigation is absolute.\n   *\n   * @param commands An array of URL fragments with which to construct the target URL.\n   * If the path is static, can be the literal URL string. For a dynamic path, pass an array of path\n   * segments, followed by the parameters for each segment.\n   * The fragments are applied to the current URL or the one provided  in the `relativeTo` property\n   * of the options object, if supplied.\n   * @param extras An options object that determines how the URL should be constructed or\n   *     interpreted.\n   *\n   * @returns A Promise that resolves to `true` when navigation succeeds, to `false` when navigation\n   *     fails,\n   * or is rejected on error.\n   *\n   * @usageNotes\n   *\n   * The following calls request navigation to a dynamic route path relative to the current URL.\n   *\n   * ```\n   * router.navigate(['team', 33, 'user', 11], {relativeTo: route});\n   *\n   * // Navigate without updating the URL, overriding the default behavior\n   * router.navigate(['team', 33, 'user', 11], {relativeTo: route, skipLocationChange: true});\n   * ```\n   *\n   * @see [Routing and Navigation guide](guide/router)\n   *\n   */\n  navigate(commands: any[], extras: NavigationExtras = {skipLocationChange: false}):\n      Promise<boolean> {\n    validateCommands(commands);\n    return this.navigateByUrl(this.createUrlTree(commands, extras), extras);\n  }\n\n  /** Serializes a `UrlTree` into a string */\n  serializeUrl(url: UrlTree): string {\n    return this.urlSerializer.serialize(url);\n  }\n\n  /** Parses a string into a `UrlTree` */\n  parseUrl(url: string): UrlTree {\n    try {\n      return this.urlSerializer.parse(url);\n    } catch {\n      return this.urlSerializer.parse('/');\n    }\n  }\n\n  /**\n   * Returns whether the url is activated.\n   *\n   * @deprecated\n   * Use `IsActiveMatchOptions` instead.\n   *\n   * - The equivalent `IsActiveMatchOptions` for `true` is\n   * `{paths: 'exact', queryParams: 'exact', fragment: 'ignored', matrixParams: 'ignored'}`.\n   * - The equivalent for `false` is\n   * `{paths: 'subset', queryParams: 'subset', fragment: 'ignored', matrixParams: 'ignored'}`.\n   */\n  isActive(url: string|UrlTree, exact: boolean): boolean;\n  /**\n   * Returns whether the url is activated.\n   */\n  isActive(url: string|UrlTree, matchOptions: IsActiveMatchOptions): boolean;\n  /** @internal */\n  isActive(url: string|UrlTree, matchOptions: boolean|IsActiveMatchOptions): boolean;\n  isActive(url: string|UrlTree, matchOptions: boolean|IsActiveMatchOptions): boolean {\n    let options: IsActiveMatchOptions;\n    if (matchOptions === true) {\n      options = {...exactMatchOptions};\n    } else if (matchOptions === false) {\n      options = {...subsetMatchOptions};\n    } else {\n      options = matchOptions;\n    }\n    if (isUrlTree(url)) {\n      return containsTree(this.currentUrlTree, url, options);\n    }\n\n    const urlTree = this.parseUrl(url);\n    return containsTree(this.currentUrlTree, urlTree, options);\n  }\n\n  private removeEmptyProps(params: Params): Params {\n    return Object.keys(params).reduce((result: Params, key: string) => {\n      const value: any = params[key];\n      if (value !== null && value !== undefined) {\n        result[key] = value;\n      }\n      return result;\n    }, {});\n  }\n\n  private scheduleNavigation(\n      rawUrl: UrlTree, source: NavigationTrigger, restoredState: RestoredState|null,\n      extras: NavigationExtras,\n      priorPromise?: {resolve: any, reject: any, promise: Promise<boolean>}): Promise<boolean> {\n    if (this.disposed) {\n      return Promise.resolve(false);\n    }\n\n    let resolve: any;\n    let reject: any;\n    let promise: Promise<boolean>;\n    if (priorPromise) {\n      resolve = priorPromise.resolve;\n      reject = priorPromise.reject;\n      promise = priorPromise.promise;\n    } else {\n      promise = new Promise<boolean>((res, rej) => {\n        resolve = res;\n        reject = rej;\n      });\n    }\n\n    // Indicate that the navigation is happening.\n    const taskId = this.pendingTasks.add();\n    afterNextNavigation(this, () => {\n      // Remove pending task in a microtask to allow for cancelled\n      // initial navigations and redirects within the same task.\n      queueMicrotask(() => this.pendingTasks.remove(taskId));\n    });\n\n    this.navigationTransitions.handleNavigationRequest({\n      source,\n      restoredState,\n      currentUrlTree: this.currentUrlTree,\n      currentRawUrl: this.currentUrlTree,\n      rawUrl,\n      extras,\n      resolve,\n      reject,\n      promise,\n      currentSnapshot: this.routerState.snapshot,\n      currentRouterState: this.routerState\n    });\n\n    // Make sure that the error is propagated even though `processNavigations` catch\n    // handler does not rethrow\n    return promise.catch((e: any) => {\n      return Promise.reject(e);\n    });\n  }\n}\n\nfunction validateCommands(commands: string[]): void {\n  for (let i = 0; i < commands.length; i++) {\n    const cmd = commands[i];\n    if (cmd == null) {\n      throw new RuntimeError(\n          RuntimeErrorCode.NULLISH_COMMAND,\n          (typeof ngDevMode === 'undefined' || ngDevMode) &&\n              `The requested path contains ${cmd} segment at index ${i}`);\n    }\n  }\n}\n\nfunction isPublicRouterEvent(e: Event|PrivateRouterEvents): e is Event {\n  return (!(e instanceof BeforeActivateRoutes) && !(e instanceof RedirectRequest));\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {LocationStrategy} from '@angular/common';\nimport {Attribute, booleanAttribute, Directive, ElementRef, HostBinding, HostListener, Input, OnChanges, OnDestroy, Renderer2, SimpleChanges, ɵɵsanitizeUrlOrResourceUrl} from '@angular/core';\nimport {Subject, Subscription} from 'rxjs';\n\nimport {Event, NavigationEnd} from '../events';\nimport {QueryParamsHandling} from '../models';\nimport {Router} from '../router';\nimport {ActivatedRoute} from '../router_state';\nimport {Params} from '../shared';\nimport {UrlTree} from '../url_tree';\n\n\n/**\n * @description\n *\n * When applied to an element in a template, makes that element a link\n * that initiates navigation to a route. Navigation opens one or more routed components\n * in one or more `<router-outlet>` locations on the page.\n *\n * Given a route configuration `[{ path: 'user/:name', component: UserCmp }]`,\n * the following creates a static link to the route:\n * `<a routerLink=\"/user/bob\">link to user component</a>`\n *\n * You can use dynamic values to generate the link.\n * For a dynamic link, pass an array of path segments,\n * followed by the params for each segment.\n * For example, `['/team', teamId, 'user', userName, {details: true}]`\n * generates a link to `/team/11/user/bob;details=true`.\n *\n * Multiple static segments can be merged into one term and combined with dynamic segments.\n * For example, `['/team/11/user', userName, {details: true}]`\n *\n * The input that you provide to the link is treated as a delta to the current URL.\n * For instance, suppose the current URL is `/user/(box//aux:team)`.\n * The link `<a [routerLink]=\"['/user/jim']\">Jim</a>` creates the URL\n * `/user/(jim//aux:team)`.\n * See {@link Router#createUrlTree} for more information.\n *\n * @usageNotes\n *\n * You can use absolute or relative paths in a link, set query parameters,\n * control how parameters are handled, and keep a history of navigation states.\n *\n * ### Relative link paths\n *\n * The first segment name can be prepended with `/`, `./`, or `../`.\n * * If the first segment begins with `/`, the router looks up the route from the root of the\n *   app.\n * * If the first segment begins with `./`, or doesn't begin with a slash, the router\n *   looks in the children of the current activated route.\n * * If the first segment begins with `../`, the router goes up one level in the route tree.\n *\n * ### Setting and handling query params and fragments\n *\n * The following link adds a query parameter and a fragment to the generated URL:\n *\n * ```\n * <a [routerLink]=\"['/user/bob']\" [queryParams]=\"{debug: true}\" fragment=\"education\">\n *   link to user component\n * </a>\n * ```\n * By default, the directive constructs the new URL using the given query parameters.\n * The example generates the link: `/user/bob?debug=true#education`.\n *\n * You can instruct the directive to handle query parameters differently\n * by specifying the `queryParamsHandling` option in the link.\n * Allowed values are:\n *\n *  - `'merge'`: Merge the given `queryParams` into the current query params.\n *  - `'preserve'`: Preserve the current query params.\n *\n * For example:\n *\n * ```\n * <a [routerLink]=\"['/user/bob']\" [queryParams]=\"{debug: true}\" queryParamsHandling=\"merge\">\n *   link to user component\n * </a>\n * ```\n *\n * See {@link UrlCreationOptions#queryParamsHandling}.\n *\n * ### Preserving navigation history\n *\n * You can provide a `state` value to be persisted to the browser's\n * [`History.state` property](https://developer.mozilla.org/en-US/docs/Web/API/History#Properties).\n * For example:\n *\n * ```\n * <a [routerLink]=\"['/user/bob']\" [state]=\"{tracingId: 123}\">\n *   link to user component\n * </a>\n * ```\n *\n * Use {@link Router#getCurrentNavigation} to retrieve a saved\n * navigation-state value. For example, to capture the `tracingId` during the `NavigationStart`\n * event:\n *\n * ```\n * // Get NavigationStart events\n * router.events.pipe(filter(e => e instanceof NavigationStart)).subscribe(e => {\n *   const navigation = router.getCurrentNavigation();\n *   tracingService.trace({id: navigation.extras.state.tracingId});\n * });\n * ```\n *\n * @ngModule RouterModule\n *\n * @publicApi\n */\n@Directive({\n  selector: '[routerLink]',\n  standalone: true,\n})\nexport class RouterLink implements OnChanges, OnDestroy {\n  /**\n   * Represents an `href` attribute value applied to a host element,\n   * when a host element is `<a>`. For other tags, the value is `null`.\n   */\n  href: string|null = null;\n\n  /**\n   * Represents the `target` attribute on a host element.\n   * This is only used when the host element is an `<a>` tag.\n   */\n  @HostBinding('attr.target') @Input() target?: string;\n\n  /**\n   * Passed to {@link Router#createUrlTree} as part of the\n   * `UrlCreationOptions`.\n   * @see {@link UrlCreationOptions#queryParams}\n   * @see {@link Router#createUrlTree}\n   */\n  @Input() queryParams?: Params|null;\n  /**\n   * Passed to {@link Router#createUrlTree} as part of the\n   * `UrlCreationOptions`.\n   * @see {@link UrlCreationOptions#fragment}\n   * @see {@link Router#createUrlTree}\n   */\n  @Input() fragment?: string;\n  /**\n   * Passed to {@link Router#createUrlTree} as part of the\n   * `UrlCreationOptions`.\n   * @see {@link UrlCreationOptions#queryParamsHandling}\n   * @see {@link Router#createUrlTree}\n   */\n  @Input() queryParamsHandling?: QueryParamsHandling|null;\n  /**\n   * Passed to {@link Router#navigateByUrl} as part of the\n   * `NavigationBehaviorOptions`.\n   * @see {@link NavigationBehaviorOptions#state}\n   * @see {@link Router#navigateByUrl}\n   */\n  @Input() state?: {[k: string]: any};\n  /**\n   * Passed to {@link Router#createUrlTree} as part of the\n   * `UrlCreationOptions`.\n   * Specify a value here when you do not want to use the default value\n   * for `routerLink`, which is the current activated route.\n   * Note that a value of `undefined` here will use the `routerLink` default.\n   * @see {@link UrlCreationOptions#relativeTo}\n   * @see {@link Router#createUrlTree}\n   */\n  @Input() relativeTo?: ActivatedRoute|null;\n\n  private commands: any[]|null = null;\n\n  /** Whether a host element is an `<a>` tag. */\n  private isAnchorElement: boolean;\n\n  private subscription?: Subscription;\n\n  /** @internal */\n  onChanges = new Subject<RouterLink>();\n\n  constructor(\n      private router: Router, private route: ActivatedRoute,\n      @Attribute('tabindex') private readonly tabIndexAttribute: string|null|undefined,\n      private readonly renderer: Renderer2, private readonly el: ElementRef,\n      private locationStrategy?: LocationStrategy) {\n    const tagName = el.nativeElement.tagName?.toLowerCase();\n    this.isAnchorElement = tagName === 'a' || tagName === 'area';\n\n    if (this.isAnchorElement) {\n      this.subscription = router.events.subscribe((s: Event) => {\n        if (s instanceof NavigationEnd) {\n          this.updateHref();\n        }\n      });\n    } else {\n      this.setTabIndexIfNotOnNativeEl('0');\n    }\n  }\n\n  /**\n   * Passed to {@link Router#createUrlTree} as part of the\n   * `UrlCreationOptions`.\n   * @see {@link UrlCreationOptions#preserveFragment}\n   * @see {@link Router#createUrlTree}\n   */\n  @Input({transform: booleanAttribute}) preserveFragment: boolean = false;\n\n  /**\n   * Passed to {@link Router#navigateByUrl} as part of the\n   * `NavigationBehaviorOptions`.\n   * @see {@link NavigationBehaviorOptions#skipLocationChange}\n   * @see {@link Router#navigateByUrl}\n   */\n  @Input({transform: booleanAttribute}) skipLocationChange: boolean = false;\n\n  /**\n   * Passed to {@link Router#navigateByUrl} as part of the\n   * `NavigationBehaviorOptions`.\n   * @see {@link NavigationBehaviorOptions#replaceUrl}\n   * @see {@link Router#navigateByUrl}\n   */\n  @Input({transform: booleanAttribute}) replaceUrl: boolean = false;\n\n  /**\n   * Modifies the tab index if there was not a tabindex attribute on the element during\n   * instantiation.\n   */\n  private setTabIndexIfNotOnNativeEl(newTabIndex: string|null) {\n    if (this.tabIndexAttribute != null /* both `null` and `undefined` */ || this.isAnchorElement) {\n      return;\n    }\n    this.applyAttributeValue('tabindex', newTabIndex);\n  }\n\n  /** @nodoc */\n  ngOnChanges(changes: SimpleChanges) {\n    if (this.isAnchorElement) {\n      this.updateHref();\n    }\n    // This is subscribed to by `RouterLinkActive` so that it knows to update when there are changes\n    // to the RouterLinks it's tracking.\n    this.onChanges.next(this);\n  }\n\n  /**\n   * Commands to pass to {@link Router#createUrlTree}.\n   *   - **array**: commands to pass to {@link Router#createUrlTree}.\n   *   - **string**: shorthand for array of commands with just the string, i.e. `['/route']`\n   *   - **null|undefined**: effectively disables the `routerLink`\n   * @see {@link Router#createUrlTree}\n   */\n  @Input()\n  set routerLink(commands: any[]|string|null|undefined) {\n    if (commands != null) {\n      this.commands = Array.isArray(commands) ? commands : [commands];\n      this.setTabIndexIfNotOnNativeEl('0');\n    } else {\n      this.commands = null;\n      this.setTabIndexIfNotOnNativeEl(null);\n    }\n  }\n\n  /** @nodoc */\n  @HostListener(\n      'click',\n      ['$event.button', '$event.ctrlKey', '$event.shiftKey', '$event.altKey', '$event.metaKey'])\n  onClick(button: number, ctrlKey: boolean, shiftKey: boolean, altKey: boolean, metaKey: boolean):\n      boolean {\n    if (this.urlTree === null) {\n      return true;\n    }\n\n    if (this.isAnchorElement) {\n      if (button !== 0 || ctrlKey || shiftKey || altKey || metaKey) {\n        return true;\n      }\n\n      if (typeof this.target === 'string' && this.target != '_self') {\n        return true;\n      }\n    }\n\n    const extras = {\n      skipLocationChange: this.skipLocationChange,\n      replaceUrl: this.replaceUrl,\n      state: this.state,\n    };\n    this.router.navigateByUrl(this.urlTree, extras);\n\n    // Return `false` for `<a>` elements to prevent default action\n    // and cancel the native behavior, since the navigation is handled\n    // by the Router.\n    return !this.isAnchorElement;\n  }\n\n  /** @nodoc */\n  ngOnDestroy(): any {\n    this.subscription?.unsubscribe();\n  }\n\n  private updateHref(): void {\n    this.href = this.urlTree !== null && this.locationStrategy ?\n        this.locationStrategy?.prepareExternalUrl(this.router.serializeUrl(this.urlTree)) :\n        null;\n\n    const sanitizedValue = this.href === null ?\n        null :\n        // This class represents a directive that can be added to both `<a>` elements,\n        // as well as other elements. As a result, we can't define security context at\n        // compile time. So the security context is deferred to runtime.\n        // The `ɵɵsanitizeUrlOrResourceUrl` selects the necessary sanitizer function\n        // based on the tag and property names. The logic mimics the one from\n        // `packages/compiler/src/schema/dom_security_schema.ts`, which is used at compile time.\n        //\n        // Note: we should investigate whether we can switch to using `@HostBinding('attr.href')`\n        // instead of applying a value via a renderer, after a final merge of the\n        // `RouterLinkWithHref` directive.\n        ɵɵsanitizeUrlOrResourceUrl(this.href, this.el.nativeElement.tagName.toLowerCase(), 'href');\n    this.applyAttributeValue('href', sanitizedValue);\n  }\n\n  private applyAttributeValue(attrName: string, attrValue: string|null) {\n    const renderer = this.renderer;\n    const nativeElement = this.el.nativeElement;\n    if (attrValue !== null) {\n      renderer.setAttribute(nativeElement, attrName, attrValue);\n    } else {\n      renderer.removeAttribute(nativeElement, attrName);\n    }\n  }\n\n  get urlTree(): UrlTree|null {\n    if (this.commands === null) {\n      return null;\n    }\n    return this.router.createUrlTree(this.commands, {\n      // If the `relativeTo` input is not defined, we want to use `this.route` by default.\n      // Otherwise, we should use the value provided by the user in the input.\n      relativeTo: this.relativeTo !== undefined ? this.relativeTo : this.route,\n      queryParams: this.queryParams,\n      fragment: this.fragment,\n      queryParamsHandling: this.queryParamsHandling,\n      preserveFragment: this.preserveFragment,\n    });\n  }\n}\n\n/**\n * @description\n * An alias for the `RouterLink` directive.\n * Deprecated since v15, use `RouterLink` directive instead.\n *\n * @deprecated use `RouterLink` directive instead.\n * @publicApi\n */\nexport {RouterLink as RouterLinkWithHref};\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AfterContentInit, ChangeDetectorRef, ContentChildren, Directive, ElementRef, EventEmitter, Input, OnChanges, OnDestroy, Optional, Output, QueryList, Renderer2, SimpleChanges} from '@angular/core';\nimport {from, of, Subscription} from 'rxjs';\nimport {mergeAll} from 'rxjs/operators';\n\nimport {Event, NavigationEnd} from '../events';\nimport {Router} from '../router';\nimport {IsActiveMatchOptions} from '../url_tree';\n\nimport {RouterLink} from './router_link';\n\n\n/**\n *\n * @description\n *\n * Tracks whether the linked route of an element is currently active, and allows you\n * to specify one or more CSS classes to add to the element when the linked route\n * is active.\n *\n * Use this directive to create a visual distinction for elements associated with an active route.\n * For example, the following code highlights the word \"Bob\" when the router\n * activates the associated route:\n *\n * ```\n * <a routerLink=\"/user/bob\" routerLinkActive=\"active-link\">Bob</a>\n * ```\n *\n * Whenever the URL is either '/user' or '/user/bob', the \"active-link\" class is\n * added to the anchor tag. If the URL changes, the class is removed.\n *\n * You can set more than one class using a space-separated string or an array.\n * For example:\n *\n * ```\n * <a routerLink=\"/user/bob\" routerLinkActive=\"class1 class2\">Bob</a>\n * <a routerLink=\"/user/bob\" [routerLinkActive]=\"['class1', 'class2']\">Bob</a>\n * ```\n *\n * To add the classes only when the URL matches the link exactly, add the option `exact: true`:\n *\n * ```\n * <a routerLink=\"/user/bob\" routerLinkActive=\"active-link\" [routerLinkActiveOptions]=\"{exact:\n * true}\">Bob</a>\n * ```\n *\n * To directly check the `isActive` status of the link, assign the `RouterLinkActive`\n * instance to a template variable.\n * For example, the following checks the status without assigning any CSS classes:\n *\n * ```\n * <a routerLink=\"/user/bob\" routerLinkActive #rla=\"routerLinkActive\">\n *   Bob {{ rla.isActive ? '(already open)' : ''}}\n * </a>\n * ```\n *\n * You can apply the `RouterLinkActive` directive to an ancestor of linked elements.\n * For example, the following sets the active-link class on the `<div>`  parent tag\n * when the URL is either '/user/jim' or '/user/bob'.\n *\n * ```\n * <div routerLinkActive=\"active-link\" [routerLinkActiveOptions]=\"{exact: true}\">\n *   <a routerLink=\"/user/jim\">Jim</a>\n *   <a routerLink=\"/user/bob\">Bob</a>\n * </div>\n * ```\n *\n * The `RouterLinkActive` directive can also be used to set the aria-current attribute\n * to provide an alternative distinction for active elements to visually impaired users.\n *\n * For example, the following code adds the 'active' class to the Home Page link when it is\n * indeed active and in such case also sets its aria-current attribute to 'page':\n *\n * ```\n * <a routerLink=\"/\" routerLinkActive=\"active\" ariaCurrentWhenActive=\"page\">Home Page</a>\n * ```\n *\n * @ngModule RouterModule\n *\n * @publicApi\n */\n@Directive({\n  selector: '[routerLinkActive]',\n  exportAs: 'routerLinkActive',\n  standalone: true,\n})\nexport class RouterLinkActive implements OnChanges, OnDestroy, AfterContentInit {\n  @ContentChildren(RouterLink, {descendants: true}) links!: QueryList<RouterLink>;\n\n  private classes: string[] = [];\n  private routerEventsSubscription: Subscription;\n  private linkInputChangesSubscription?: Subscription;\n  private _isActive = false;\n\n  get isActive() {\n    return this._isActive;\n  }\n\n  /**\n   * Options to configure how to determine if the router link is active.\n   *\n   * These options are passed to the `Router.isActive()` function.\n   *\n   * @see {@link Router#isActive}\n   */\n  @Input() routerLinkActiveOptions: {exact: boolean}|IsActiveMatchOptions = {exact: false};\n\n\n  /**\n   * Aria-current attribute to apply when the router link is active.\n   *\n   * Possible values: `'page'` | `'step'` | `'location'` | `'date'` | `'time'` | `true` | `false`.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-current}\n   */\n  @Input() ariaCurrentWhenActive?: 'page'|'step'|'location'|'date'|'time'|true|false;\n\n  /**\n   *\n   * You can use the output `isActiveChange` to get notified each time the link becomes\n   * active or inactive.\n   *\n   * Emits:\n   * true  -> Route is active\n   * false -> Route is inactive\n   *\n   * ```\n   * <a\n   *  routerLink=\"/user/bob\"\n   *  routerLinkActive=\"active-link\"\n   *  (isActiveChange)=\"this.onRouterLinkActive($event)\">Bob</a>\n   * ```\n   */\n  @Output() readonly isActiveChange: EventEmitter<boolean> = new EventEmitter();\n\n  constructor(\n      private router: Router, private element: ElementRef, private renderer: Renderer2,\n      private readonly cdr: ChangeDetectorRef, @Optional() private link?: RouterLink) {\n    this.routerEventsSubscription = router.events.subscribe((s: Event) => {\n      if (s instanceof NavigationEnd) {\n        this.update();\n      }\n    });\n  }\n\n  /** @nodoc */\n  ngAfterContentInit(): void {\n    // `of(null)` is used to force subscribe body to execute once immediately (like `startWith`).\n    of(this.links.changes, of(null)).pipe(mergeAll()).subscribe(_ => {\n      this.update();\n      this.subscribeToEachLinkOnChanges();\n    });\n  }\n\n  private subscribeToEachLinkOnChanges() {\n    this.linkInputChangesSubscription?.unsubscribe();\n    const allLinkChanges = [...this.links.toArray(), this.link]\n                               .filter((link): link is RouterLink => !!link)\n                               .map(link => link.onChanges);\n    this.linkInputChangesSubscription = from(allLinkChanges).pipe(mergeAll()).subscribe(link => {\n      if (this._isActive !== this.isLinkActive(this.router)(link)) {\n        this.update();\n      }\n    });\n  }\n\n  @Input()\n  set routerLinkActive(data: string[]|string) {\n    const classes = Array.isArray(data) ? data : data.split(' ');\n    this.classes = classes.filter(c => !!c);\n  }\n\n  /** @nodoc */\n  ngOnChanges(changes: SimpleChanges): void {\n    this.update();\n  }\n  /** @nodoc */\n  ngOnDestroy(): void {\n    this.routerEventsSubscription.unsubscribe();\n    this.linkInputChangesSubscription?.unsubscribe();\n  }\n\n  private update(): void {\n    if (!this.links || !this.router.navigated) return;\n    queueMicrotask(() => {\n      const hasActiveLinks = this.hasActiveLinks();\n      if (this._isActive !== hasActiveLinks) {\n        this._isActive = hasActiveLinks;\n        this.cdr.markForCheck();\n        this.classes.forEach((c) => {\n          if (hasActiveLinks) {\n            this.renderer.addClass(this.element.nativeElement, c);\n          } else {\n            this.renderer.removeClass(this.element.nativeElement, c);\n          }\n        });\n        if (hasActiveLinks && this.ariaCurrentWhenActive !== undefined) {\n          this.renderer.setAttribute(\n              this.element.nativeElement, 'aria-current', this.ariaCurrentWhenActive.toString());\n        } else {\n          this.renderer.removeAttribute(this.element.nativeElement, 'aria-current');\n        }\n\n        // Emit on isActiveChange after classes are updated\n        this.isActiveChange.emit(hasActiveLinks);\n      }\n    });\n  }\n\n  private isLinkActive(router: Router): (link: RouterLink) => boolean {\n    const options: boolean|IsActiveMatchOptions =\n        isActiveMatchOptions(this.routerLinkActiveOptions) ?\n        this.routerLinkActiveOptions :\n        // While the types should disallow `undefined` here, it's possible without strict inputs\n        (this.routerLinkActiveOptions.exact || false);\n    return (link: RouterLink) => link.urlTree ? router.isActive(link.urlTree, options) : false;\n  }\n\n  private hasActiveLinks(): boolean {\n    const isActiveCheckFn = this.isLinkActive(this.router);\n    return this.link && isActiveCheckFn(this.link) || this.links.some(isActiveCheckFn);\n  }\n}\n\n/**\n * Use instead of `'paths' in options` to be compatible with property renaming\n */\nfunction isActiveMatchOptions(options: {exact: boolean}|\n                              IsActiveMatchOptions): options is IsActiveMatchOptions {\n  return !!(options as IsActiveMatchOptions).paths;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Compiler, createEnvironmentInjector, EnvironmentInjector, Injectable, OnDestroy} from '@angular/core';\nimport {from, Observable, of, Subscription} from 'rxjs';\nimport {catchError, concatMap, filter, mergeAll, mergeMap} from 'rxjs/operators';\n\nimport {Event, NavigationEnd} from './events';\nimport {LoadedRouterConfig, Route, Routes} from './models';\nimport {Router} from './router';\nimport {RouterConfigLoader} from './router_config_loader';\n\n\n/**\n * @description\n *\n * Provides a preloading strategy.\n *\n * @publicApi\n */\nexport abstract class PreloadingStrategy {\n  abstract preload(route: Route, fn: () => Observable<any>): Observable<any>;\n}\n\n/**\n * @description\n *\n * Provides a preloading strategy that preloads all modules as quickly as possible.\n *\n * ```\n * RouterModule.forRoot(ROUTES, {preloadingStrategy: PreloadAllModules})\n * ```\n *\n * @publicApi\n */\n@Injectable({providedIn: 'root'})\nexport class PreloadAllModules implements PreloadingStrategy {\n  preload(route: Route, fn: () => Observable<any>): Observable<any> {\n    return fn().pipe(catchError(() => of(null)));\n  }\n}\n\n/**\n * @description\n *\n * Provides a preloading strategy that does not preload any modules.\n *\n * This strategy is enabled by default.\n *\n * @publicApi\n */\n@Injectable({providedIn: 'root'})\nexport class NoPreloading implements PreloadingStrategy {\n  preload(route: Route, fn: () => Observable<any>): Observable<any> {\n    return of(null);\n  }\n}\n\n/**\n * The preloader optimistically loads all router configurations to\n * make navigations into lazily-loaded sections of the application faster.\n *\n * The preloader runs in the background. When the router bootstraps, the preloader\n * starts listening to all navigation events. After every such event, the preloader\n * will check if any configurations can be loaded lazily.\n *\n * If a route is protected by `canLoad` guards, the preloaded will not load it.\n *\n * @publicApi\n */\n@Injectable({providedIn: 'root'})\nexport class RouterPreloader implements OnDestroy {\n  private subscription?: Subscription;\n\n  constructor(\n      private router: Router, compiler: Compiler, private injector: EnvironmentInjector,\n      private preloadingStrategy: PreloadingStrategy, private loader: RouterConfigLoader) {}\n\n  setUpPreloading(): void {\n    this.subscription =\n        this.router.events\n            .pipe(filter((e: Event) => e instanceof NavigationEnd), concatMap(() => this.preload()))\n            .subscribe(() => {});\n  }\n\n  preload(): Observable<any> {\n    return this.processRoutes(this.injector, this.router.config);\n  }\n\n  /** @nodoc */\n  ngOnDestroy(): void {\n    if (this.subscription) {\n      this.subscription.unsubscribe();\n    }\n  }\n\n  private processRoutes(injector: EnvironmentInjector, routes: Routes): Observable<void> {\n    const res: Observable<any>[] = [];\n    for (const route of routes) {\n      if (route.providers && !route._injector) {\n        route._injector =\n            createEnvironmentInjector(route.providers, injector, `Route: ${route.path}`);\n      }\n\n      const injectorForCurrentRoute = route._injector ?? injector;\n      const injectorForChildren = route._loadedInjector ?? injectorForCurrentRoute;\n\n      // Note that `canLoad` is only checked as a condition that prevents `loadChildren` and not\n      // `loadComponent`. `canLoad` guards only block loading of child routes by design. This\n      // happens as a consequence of needing to descend into children for route matching immediately\n      // while component loading is deferred until route activation. Because `canLoad` guards can\n      // have side effects, we cannot execute them here so we instead skip preloading altogether\n      // when present. Lastly, it remains to be decided whether `canLoad` should behave this way\n      // at all. Code splitting and lazy loading is separate from client-side authorization checks\n      // and should not be used as a security measure to prevent loading of code.\n      if ((route.loadChildren && !route._loadedRoutes && route.canLoad === undefined) ||\n          (route.loadComponent && !route._loadedComponent)) {\n        res.push(this.preloadConfig(injectorForCurrentRoute, route));\n      }\n      if (route.children || route._loadedRoutes) {\n        res.push(this.processRoutes(injectorForChildren, (route.children ?? route._loadedRoutes)!));\n      }\n    }\n    return from(res).pipe(mergeAll());\n  }\n\n  private preloadConfig(injector: EnvironmentInjector, route: Route): Observable<void> {\n    return this.preloadingStrategy.preload(route, () => {\n      let loadedChildren$: Observable<LoadedRouterConfig|null>;\n      if (route.loadChildren && route.canLoad === undefined) {\n        loadedChildren$ = this.loader.loadChildren(injector, route);\n      } else {\n        loadedChildren$ = of(null);\n      }\n\n      const recursiveLoadChildren$ =\n          loadedChildren$.pipe(mergeMap((config: LoadedRouterConfig|null) => {\n            if (config === null) {\n              return of(void 0);\n            }\n            route._loadedRoutes = config.routes;\n            route._loadedInjector = config.injector;\n            // If the loaded config was a module, use that as the module/module injector going\n            // forward. Otherwise, continue using the current module/module injector.\n            return this.processRoutes(config.injector ?? injector, config.routes);\n          }));\n      if (route.loadComponent && !route._loadedComponent) {\n        const loadComponent$ = this.loader.loadComponent(route);\n        return from([recursiveLoadChildren$, loadComponent$]).pipe(mergeAll());\n      } else {\n        return recursiveLoadChildren$;\n      }\n    });\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ViewportScroller} from '@angular/common';\nimport {Injectable, InjectionToken, NgZone, OnDestroy} from '@angular/core';\nimport {Unsubscribable} from 'rxjs';\n\nimport {NavigationEnd, NavigationSkipped, NavigationSkippedCode, NavigationStart, Scroll} from './events';\nimport {NavigationTransitions} from './navigation_transition';\nimport {UrlSerializer} from './url_tree';\n\nexport const ROUTER_SCROLLER = new InjectionToken<RouterScroller>('');\n\n@Injectable()\nexport class RouterScroller implements OnDestroy {\n  private routerEventsSubscription?: Unsubscribable;\n  private scrollEventsSubscription?: Unsubscribable;\n\n  private lastId = 0;\n  private lastSource: 'imperative'|'popstate'|'hashchange'|undefined = 'imperative';\n  private restoredId = 0;\n  private store: {[key: string]: [number, number]} = {};\n\n  /** @nodoc */\n  constructor(\n      readonly urlSerializer: UrlSerializer, private transitions: NavigationTransitions,\n      public readonly viewportScroller: ViewportScroller, private readonly zone: NgZone,\n      private options: {\n        scrollPositionRestoration?: 'disabled'|'enabled'|'top',\n        anchorScrolling?: 'disabled'|'enabled'\n      } = {}) {\n    // Default both options to 'disabled'\n    options.scrollPositionRestoration = options.scrollPositionRestoration || 'disabled';\n    options.anchorScrolling = options.anchorScrolling || 'disabled';\n  }\n\n  init(): void {\n    // we want to disable the automatic scrolling because having two places\n    // responsible for scrolling results race conditions, especially given\n    // that browser don't implement this behavior consistently\n    if (this.options.scrollPositionRestoration !== 'disabled') {\n      this.viewportScroller.setHistoryScrollRestoration('manual');\n    }\n    this.routerEventsSubscription = this.createScrollEvents();\n    this.scrollEventsSubscription = this.consumeScrollEvents();\n  }\n\n  private createScrollEvents() {\n    return this.transitions.events.subscribe(e => {\n      if (e instanceof NavigationStart) {\n        // store the scroll position of the current stable navigations.\n        this.store[this.lastId] = this.viewportScroller.getScrollPosition();\n        this.lastSource = e.navigationTrigger;\n        this.restoredId = e.restoredState ? e.restoredState.navigationId : 0;\n      } else if (e instanceof NavigationEnd) {\n        this.lastId = e.id;\n        this.scheduleScrollEvent(e, this.urlSerializer.parse(e.urlAfterRedirects).fragment);\n      } else if (\n          e instanceof NavigationSkipped &&\n          e.code === NavigationSkippedCode.IgnoredSameUrlNavigation) {\n        this.lastSource = undefined;\n        this.restoredId = 0;\n        this.scheduleScrollEvent(e, this.urlSerializer.parse(e.url).fragment);\n      }\n    });\n  }\n\n  private consumeScrollEvents() {\n    return this.transitions.events.subscribe(e => {\n      if (!(e instanceof Scroll)) return;\n      // a popstate event. The pop state event will always ignore anchor scrolling.\n      if (e.position) {\n        if (this.options.scrollPositionRestoration === 'top') {\n          this.viewportScroller.scrollToPosition([0, 0]);\n        } else if (this.options.scrollPositionRestoration === 'enabled') {\n          this.viewportScroller.scrollToPosition(e.position);\n        }\n        // imperative navigation \"forward\"\n      } else {\n        if (e.anchor && this.options.anchorScrolling === 'enabled') {\n          this.viewportScroller.scrollToAnchor(e.anchor);\n        } else if (this.options.scrollPositionRestoration !== 'disabled') {\n          this.viewportScroller.scrollToPosition([0, 0]);\n        }\n      }\n    });\n  }\n\n  private scheduleScrollEvent(routerEvent: NavigationEnd|NavigationSkipped, anchor: string|null):\n      void {\n    this.zone.runOutsideAngular(() => {\n      // The scroll event needs to be delayed until after change detection. Otherwise, we may\n      // attempt to restore the scroll position before the router outlet has fully rendered the\n      // component by executing its update block of the template function.\n      setTimeout(() => {\n        this.zone.run(() => {\n          this.transitions.events.next(new Scroll(\n              routerEvent, this.lastSource === 'popstate' ? this.store[this.restoredId] : null,\n              anchor));\n        });\n      }, 0);\n    });\n  }\n\n  /** @nodoc */\n  ngOnDestroy() {\n    this.routerEventsSubscription?.unsubscribe();\n    this.scrollEventsSubscription?.unsubscribe();\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {HashLocationStrategy, LOCATION_INITIALIZED, LocationStrategy, ViewportScroller} from '@angular/common';\nimport {APP_BOOTSTRAP_LISTENER, APP_INITIALIZER, ApplicationRef, Component, ComponentRef, ENVIRONMENT_INITIALIZER, EnvironmentInjector, EnvironmentProviders, inject, InjectFlags, InjectionToken, Injector, makeEnvironmentProviders, NgZone, Provider, Type} from '@angular/core';\nimport {of, Subject} from 'rxjs';\n\nimport {INPUT_BINDER, RoutedComponentInputBinder} from './directives/router_outlet';\nimport {Event, NavigationError, stringifyEvent} from './events';\nimport {Routes} from './models';\nimport {NavigationTransitions} from './navigation_transition';\nimport {Router} from './router';\nimport {InMemoryScrollingOptions, ROUTER_CONFIGURATION, RouterConfigOptions} from './router_config';\nimport {ROUTES} from './router_config_loader';\nimport {PreloadingStrategy, RouterPreloader} from './router_preloader';\nimport {ROUTER_SCROLLER, RouterScroller} from './router_scroller';\nimport {ActivatedRoute} from './router_state';\nimport {UrlSerializer} from './url_tree';\nimport {afterNextNavigation} from './utils/navigations';\nimport {CREATE_VIEW_TRANSITION, createViewTransition, VIEW_TRANSITION_OPTIONS, ViewTransitionsFeatureOptions} from './utils/view_transition';\n\n\n/**\n * Sets up providers necessary to enable `Router` functionality for the application.\n * Allows to configure a set of routes as well as extra features that should be enabled.\n *\n * @usageNotes\n *\n * Basic example of how you can add a Router to your application:\n * ```\n * const appRoutes: Routes = [];\n * bootstrapApplication(AppComponent, {\n *   providers: [provideRouter(appRoutes)]\n * });\n * ```\n *\n * You can also enable optional features in the Router by adding functions from the `RouterFeatures`\n * type:\n * ```\n * const appRoutes: Routes = [];\n * bootstrapApplication(AppComponent,\n *   {\n *     providers: [\n *       provideRouter(appRoutes,\n *         withDebugTracing(),\n *         withRouterConfig({paramsInheritanceStrategy: 'always'}))\n *     ]\n *   }\n * );\n * ```\n *\n * @see {@link RouterFeatures}\n *\n * @publicApi\n * @param routes A set of `Route`s to use for the application routing table.\n * @param features Optional features to configure additional router behaviors.\n * @returns A set of providers to setup a Router.\n */\nexport function provideRouter(routes: Routes, ...features: RouterFeatures[]): EnvironmentProviders {\n  return makeEnvironmentProviders([\n    {provide: ROUTES, multi: true, useValue: routes},\n    (typeof ngDevMode === 'undefined' || ngDevMode) ?\n        {provide: ROUTER_IS_PROVIDED, useValue: true} :\n        [],\n    {provide: ActivatedRoute, useFactory: rootRoute, deps: [Router]},\n    {provide: APP_BOOTSTRAP_LISTENER, multi: true, useFactory: getBootstrapListener},\n    features.map(feature => feature.ɵproviders),\n  ]);\n}\n\nexport function rootRoute(router: Router): ActivatedRoute {\n  return router.routerState.root;\n}\n\n/**\n * Helper type to represent a Router feature.\n *\n * @publicApi\n */\nexport interface RouterFeature<FeatureKind extends RouterFeatureKind> {\n  ɵkind: FeatureKind;\n  ɵproviders: Provider[];\n}\n\n/**\n * Helper function to create an object that represents a Router feature.\n */\nfunction routerFeature<FeatureKind extends RouterFeatureKind>(\n    kind: FeatureKind, providers: Provider[]): RouterFeature<FeatureKind> {\n  return {ɵkind: kind, ɵproviders: providers};\n}\n\n\n/**\n * An Injection token used to indicate whether `provideRouter` or `RouterModule.forRoot` was ever\n * called.\n */\nexport const ROUTER_IS_PROVIDED =\n    new InjectionToken<boolean>('', {providedIn: 'root', factory: () => false});\n\nconst routerIsProvidedDevModeCheck = {\n  provide: ENVIRONMENT_INITIALIZER,\n  multi: true,\n  useFactory() {\n    return () => {\n      if (!inject(ROUTER_IS_PROVIDED)) {\n        console.warn(\n            '`provideRoutes` was called without `provideRouter` or `RouterModule.forRoot`. ' +\n            'This is likely a mistake.');\n      }\n    };\n  }\n};\n\n/**\n * Registers a [DI provider](guide/glossary#provider) for a set of routes.\n * @param routes The route configuration to provide.\n *\n * @usageNotes\n *\n * ```\n * @NgModule({\n *   providers: [provideRoutes(ROUTES)]\n * })\n * class LazyLoadedChildModule {}\n * ```\n *\n * @deprecated If necessary, provide routes using the `ROUTES` `InjectionToken`.\n * @see {@link ROUTES}\n * @publicApi\n */\nexport function provideRoutes(routes: Routes): Provider[] {\n  return [\n    {provide: ROUTES, multi: true, useValue: routes},\n    (typeof ngDevMode === 'undefined' || ngDevMode) ? routerIsProvidedDevModeCheck : [],\n  ];\n}\n\n/**\n * A type alias for providers returned by `withInMemoryScrolling` for use with `provideRouter`.\n *\n * @see {@link withInMemoryScrolling}\n * @see {@link provideRouter}\n *\n * @publicApi\n */\nexport type InMemoryScrollingFeature = RouterFeature<RouterFeatureKind.InMemoryScrollingFeature>;\n\n/**\n * Enables customizable scrolling behavior for router navigations.\n *\n * @usageNotes\n *\n * Basic example of how you can enable scrolling feature:\n * ```\n * const appRoutes: Routes = [];\n * bootstrapApplication(AppComponent,\n *   {\n *     providers: [\n *       provideRouter(appRoutes, withInMemoryScrolling())\n *     ]\n *   }\n * );\n * ```\n *\n * @see {@link provideRouter}\n * @see {@link ViewportScroller}\n *\n * @publicApi\n * @param options Set of configuration parameters to customize scrolling behavior, see\n *     `InMemoryScrollingOptions` for additional information.\n * @returns A set of providers for use with `provideRouter`.\n */\nexport function withInMemoryScrolling(options: InMemoryScrollingOptions = {}):\n    InMemoryScrollingFeature {\n  const providers = [{\n    provide: ROUTER_SCROLLER,\n    useFactory: () => {\n      const viewportScroller = inject(ViewportScroller);\n      const zone = inject(NgZone);\n      const transitions = inject(NavigationTransitions);\n      const urlSerializer = inject(UrlSerializer);\n      return new RouterScroller(urlSerializer, transitions, viewportScroller, zone, options);\n    },\n  }];\n  return routerFeature(RouterFeatureKind.InMemoryScrollingFeature, providers);\n}\n\nexport function getBootstrapListener() {\n  const injector = inject(Injector);\n  return (bootstrappedComponentRef: ComponentRef<unknown>) => {\n    const ref = injector.get(ApplicationRef);\n\n    if (bootstrappedComponentRef !== ref.components[0]) {\n      return;\n    }\n\n    const router = injector.get(Router);\n    const bootstrapDone = injector.get(BOOTSTRAP_DONE);\n\n    if (injector.get(INITIAL_NAVIGATION) === InitialNavigation.EnabledNonBlocking) {\n      router.initialNavigation();\n    }\n\n    injector.get(ROUTER_PRELOADER, null, InjectFlags.Optional)?.setUpPreloading();\n    injector.get(ROUTER_SCROLLER, null, InjectFlags.Optional)?.init();\n    router.resetRootComponentType(ref.componentTypes[0]);\n    if (!bootstrapDone.closed) {\n      bootstrapDone.next();\n      bootstrapDone.complete();\n      bootstrapDone.unsubscribe();\n    }\n  };\n}\n\n/**\n * A subject used to indicate that the bootstrapping phase is done. When initial navigation is\n * `enabledBlocking`, the first navigation waits until bootstrapping is finished before continuing\n * to the activation phase.\n */\nconst BOOTSTRAP_DONE = new InjectionToken<Subject<void>>(\n    (typeof ngDevMode === 'undefined' || ngDevMode) ? 'bootstrap done indicator' : '', {\n      factory: () => {\n        return new Subject<void>();\n      }\n    });\n\n/**\n * This and the INITIAL_NAVIGATION token are used internally only. The public API side of this is\n * configured through the `ExtraOptions`.\n *\n * When set to `EnabledBlocking`, the initial navigation starts before the root\n * component is created. The bootstrap is blocked until the initial navigation is complete. This\n * value is required for [server-side rendering](guide/ssr) to work.\n *\n * When set to `EnabledNonBlocking`, the initial navigation starts after the root component has been\n * created. The bootstrap is not blocked on the completion of the initial navigation.\n *\n * When set to `Disabled`, the initial navigation is not performed. The location listener is set up\n * before the root component gets created. Use if there is a reason to have more control over when\n * the router starts its initial navigation due to some complex initialization logic.\n *\n * @see {@link ExtraOptions}\n */\nconst enum InitialNavigation {\n  EnabledBlocking,\n  EnabledNonBlocking,\n  Disabled,\n}\n\nconst INITIAL_NAVIGATION = new InjectionToken<InitialNavigation>(\n    (typeof ngDevMode === 'undefined' || ngDevMode) ? 'initial navigation' : '',\n    {providedIn: 'root', factory: () => InitialNavigation.EnabledNonBlocking});\n\n/**\n * A type alias for providers returned by `withEnabledBlockingInitialNavigation` for use with\n * `provideRouter`.\n *\n * @see {@link withEnabledBlockingInitialNavigation}\n * @see {@link provideRouter}\n *\n * @publicApi\n */\nexport type EnabledBlockingInitialNavigationFeature =\n    RouterFeature<RouterFeatureKind.EnabledBlockingInitialNavigationFeature>;\n\n/**\n * A type alias for providers returned by `withEnabledBlockingInitialNavigation` or\n * `withDisabledInitialNavigation` functions for use with `provideRouter`.\n *\n * @see {@link withEnabledBlockingInitialNavigation}\n * @see {@link withDisabledInitialNavigation}\n * @see {@link provideRouter}\n *\n * @publicApi\n */\nexport type InitialNavigationFeature =\n    EnabledBlockingInitialNavigationFeature|DisabledInitialNavigationFeature;\n\n/**\n * Configures initial navigation to start before the root component is created.\n *\n * The bootstrap is blocked until the initial navigation is complete. This value is required for\n * [server-side rendering](guide/ssr) to work.\n *\n * @usageNotes\n *\n * Basic example of how you can enable this navigation behavior:\n * ```\n * const appRoutes: Routes = [];\n * bootstrapApplication(AppComponent,\n *   {\n *     providers: [\n *       provideRouter(appRoutes, withEnabledBlockingInitialNavigation())\n *     ]\n *   }\n * );\n * ```\n *\n * @see {@link provideRouter}\n *\n * @publicApi\n * @returns A set of providers for use with `provideRouter`.\n */\nexport function withEnabledBlockingInitialNavigation(): EnabledBlockingInitialNavigationFeature {\n  const providers = [\n    {provide: INITIAL_NAVIGATION, useValue: InitialNavigation.EnabledBlocking},\n    {\n      provide: APP_INITIALIZER,\n      multi: true,\n      deps: [Injector],\n      useFactory: (injector: Injector) => {\n        const locationInitialized: Promise<any> =\n            injector.get(LOCATION_INITIALIZED, Promise.resolve());\n\n        return () => {\n          return locationInitialized.then(() => {\n            return new Promise(resolve => {\n              const router = injector.get(Router);\n              const bootstrapDone = injector.get(BOOTSTRAP_DONE);\n              afterNextNavigation(router, () => {\n                // Unblock APP_INITIALIZER in case the initial navigation was canceled or errored\n                // without a redirect.\n                resolve(true);\n              });\n\n              injector.get(NavigationTransitions).afterPreactivation = () => {\n                // Unblock APP_INITIALIZER once we get to `afterPreactivation`. At this point, we\n                // assume activation will complete successfully (even though this is not\n                // guaranteed).\n                resolve(true);\n                return bootstrapDone.closed ? of(void 0) : bootstrapDone;\n              };\n              router.initialNavigation();\n            });\n          });\n        };\n      }\n    },\n  ];\n  return routerFeature(RouterFeatureKind.EnabledBlockingInitialNavigationFeature, providers);\n}\n\n/**\n * A type alias for providers returned by `withDisabledInitialNavigation` for use with\n * `provideRouter`.\n *\n * @see {@link withDisabledInitialNavigation}\n * @see {@link provideRouter}\n *\n * @publicApi\n */\nexport type DisabledInitialNavigationFeature =\n    RouterFeature<RouterFeatureKind.DisabledInitialNavigationFeature>;\n\n/**\n * Disables initial navigation.\n *\n * Use if there is a reason to have more control over when the router starts its initial navigation\n * due to some complex initialization logic.\n *\n * @usageNotes\n *\n * Basic example of how you can disable initial navigation:\n * ```\n * const appRoutes: Routes = [];\n * bootstrapApplication(AppComponent,\n *   {\n *     providers: [\n *       provideRouter(appRoutes, withDisabledInitialNavigation())\n *     ]\n *   }\n * );\n * ```\n *\n * @see {@link provideRouter}\n *\n * @returns A set of providers for use with `provideRouter`.\n *\n * @publicApi\n */\nexport function withDisabledInitialNavigation(): DisabledInitialNavigationFeature {\n  const providers = [\n    {\n      provide: APP_INITIALIZER,\n      multi: true,\n      useFactory: () => {\n        const router = inject(Router);\n        return () => {\n          router.setUpLocationChangeListener();\n        };\n      }\n    },\n    {provide: INITIAL_NAVIGATION, useValue: InitialNavigation.Disabled}\n  ];\n  return routerFeature(RouterFeatureKind.DisabledInitialNavigationFeature, providers);\n}\n\n/**\n * A type alias for providers returned by `withDebugTracing` for use with `provideRouter`.\n *\n * @see {@link withDebugTracing}\n * @see {@link provideRouter}\n *\n * @publicApi\n */\nexport type DebugTracingFeature = RouterFeature<RouterFeatureKind.DebugTracingFeature>;\n\n/**\n * Enables logging of all internal navigation events to the console.\n * Extra logging might be useful for debugging purposes to inspect Router event sequence.\n *\n * @usageNotes\n *\n * Basic example of how you can enable debug tracing:\n * ```\n * const appRoutes: Routes = [];\n * bootstrapApplication(AppComponent,\n *   {\n *     providers: [\n *       provideRouter(appRoutes, withDebugTracing())\n *     ]\n *   }\n * );\n * ```\n *\n * @see {@link provideRouter}\n *\n * @returns A set of providers for use with `provideRouter`.\n *\n * @publicApi\n */\nexport function withDebugTracing(): DebugTracingFeature {\n  let providers: Provider[] = [];\n  if (typeof ngDevMode === 'undefined' || ngDevMode) {\n    providers = [{\n      provide: ENVIRONMENT_INITIALIZER,\n      multi: true,\n      useFactory: () => {\n        const router = inject(Router);\n        return () => router.events.subscribe((e: Event) => {\n          // tslint:disable:no-console\n          console.group?.(`Router Event: ${(<any>e.constructor).name}`);\n          console.log(stringifyEvent(e));\n          console.log(e);\n          console.groupEnd?.();\n          // tslint:enable:no-console\n        });\n      }\n    }];\n  } else {\n    providers = [];\n  }\n  return routerFeature(RouterFeatureKind.DebugTracingFeature, providers);\n}\n\nconst ROUTER_PRELOADER = new InjectionToken<RouterPreloader>(\n    (typeof ngDevMode === 'undefined' || ngDevMode) ? 'router preloader' : '');\n\n/**\n * A type alias that represents a feature which enables preloading in Router.\n * The type is used to describe the return value of the `withPreloading` function.\n *\n * @see {@link withPreloading}\n * @see {@link provideRouter}\n *\n * @publicApi\n */\nexport type PreloadingFeature = RouterFeature<RouterFeatureKind.PreloadingFeature>;\n\n/**\n * Allows to configure a preloading strategy to use. The strategy is configured by providing a\n * reference to a class that implements a `PreloadingStrategy`.\n *\n * @usageNotes\n *\n * Basic example of how you can configure preloading:\n * ```\n * const appRoutes: Routes = [];\n * bootstrapApplication(AppComponent,\n *   {\n *     providers: [\n *       provideRouter(appRoutes, withPreloading(PreloadAllModules))\n *     ]\n *   }\n * );\n * ```\n *\n * @see {@link provideRouter}\n *\n * @param preloadingStrategy A reference to a class that implements a `PreloadingStrategy` that\n *     should be used.\n * @returns A set of providers for use with `provideRouter`.\n *\n * @publicApi\n */\nexport function withPreloading(preloadingStrategy: Type<PreloadingStrategy>): PreloadingFeature {\n  const providers = [\n    {provide: ROUTER_PRELOADER, useExisting: RouterPreloader},\n    {provide: PreloadingStrategy, useExisting: preloadingStrategy},\n  ];\n  return routerFeature(RouterFeatureKind.PreloadingFeature, providers);\n}\n\n/**\n * A type alias for providers returned by `withRouterConfig` for use with `provideRouter`.\n *\n * @see {@link withRouterConfig}\n * @see {@link provideRouter}\n *\n * @publicApi\n */\nexport type RouterConfigurationFeature =\n    RouterFeature<RouterFeatureKind.RouterConfigurationFeature>;\n\n/**\n * Allows to provide extra parameters to configure Router.\n *\n * @usageNotes\n *\n * Basic example of how you can provide extra configuration options:\n * ```\n * const appRoutes: Routes = [];\n * bootstrapApplication(AppComponent,\n *   {\n *     providers: [\n *       provideRouter(appRoutes, withRouterConfig({\n *          onSameUrlNavigation: 'reload'\n *       }))\n *     ]\n *   }\n * );\n * ```\n *\n * @see {@link provideRouter}\n *\n * @param options A set of parameters to configure Router, see `RouterConfigOptions` for\n *     additional information.\n * @returns A set of providers for use with `provideRouter`.\n *\n * @publicApi\n */\nexport function withRouterConfig(options: RouterConfigOptions): RouterConfigurationFeature {\n  const providers = [\n    {provide: ROUTER_CONFIGURATION, useValue: options},\n  ];\n  return routerFeature(RouterFeatureKind.RouterConfigurationFeature, providers);\n}\n\n/**\n * A type alias for providers returned by `withHashLocation` for use with `provideRouter`.\n *\n * @see {@link withHashLocation}\n * @see {@link provideRouter}\n *\n * @publicApi\n */\nexport type RouterHashLocationFeature = RouterFeature<RouterFeatureKind.RouterHashLocationFeature>;\n\n/**\n * Provides the location strategy that uses the URL fragment instead of the history API.\n *\n * @usageNotes\n *\n * Basic example of how you can use the hash location option:\n * ```\n * const appRoutes: Routes = [];\n * bootstrapApplication(AppComponent,\n *   {\n *     providers: [\n *       provideRouter(appRoutes, withHashLocation())\n *     ]\n *   }\n * );\n * ```\n *\n * @see {@link provideRouter}\n * @see {@link HashLocationStrategy}\n *\n * @returns A set of providers for use with `provideRouter`.\n *\n * @publicApi\n */\nexport function withHashLocation(): RouterHashLocationFeature {\n  const providers = [\n    {provide: LocationStrategy, useClass: HashLocationStrategy},\n  ];\n  return routerFeature(RouterFeatureKind.RouterHashLocationFeature, providers);\n}\n\n/**\n * A type alias for providers returned by `withNavigationErrorHandler` for use with `provideRouter`.\n *\n * @see {@link withNavigationErrorHandler}\n * @see {@link provideRouter}\n *\n * @publicApi\n */\nexport type NavigationErrorHandlerFeature =\n    RouterFeature<RouterFeatureKind.NavigationErrorHandlerFeature>;\n\n/**\n * Subscribes to the Router's navigation events and calls the given function when a\n * `NavigationError` happens.\n *\n * This function is run inside application's [injection context](guide/dependency-injection-context)\n * so you can use the [`inject`](api/core/inject) function.\n *\n * @usageNotes\n *\n * Basic example of how you can use the error handler option:\n * ```\n * const appRoutes: Routes = [];\n * bootstrapApplication(AppComponent,\n *   {\n *     providers: [\n *       provideRouter(appRoutes, withNavigationErrorHandler((e: NavigationError) =>\n * inject(MyErrorTracker).trackError(e)))\n *     ]\n *   }\n * );\n * ```\n *\n * @see {@link NavigationError}\n * @see {@link core/inject}\n * @see {@link runInInjectionContext}\n *\n * @returns A set of providers for use with `provideRouter`.\n *\n * @publicApi\n */\nexport function withNavigationErrorHandler(fn: (error: NavigationError) => void):\n    NavigationErrorHandlerFeature {\n  const providers = [{\n    provide: ENVIRONMENT_INITIALIZER,\n    multi: true,\n    useValue: () => {\n      const injector = inject(EnvironmentInjector);\n      inject(Router).events.subscribe((e) => {\n        if (e instanceof NavigationError) {\n          injector.runInContext(() => fn(e));\n        }\n      });\n    }\n  }];\n  return routerFeature(RouterFeatureKind.NavigationErrorHandlerFeature, providers);\n}\n\n/**\n * A type alias for providers returned by `withComponentInputBinding` for use with `provideRouter`.\n *\n * @see {@link withComponentInputBinding}\n * @see {@link provideRouter}\n *\n * @publicApi\n */\nexport type ComponentInputBindingFeature =\n    RouterFeature<RouterFeatureKind.ComponentInputBindingFeature>;\n\n/**\n * A type alias for providers returned by `withViewTransitions` for use with `provideRouter`.\n *\n * @see {@link withViewTransitions}\n * @see {@link provideRouter}\n *\n * @publicApi\n */\nexport type ViewTransitionsFeature = RouterFeature<RouterFeatureKind.ViewTransitionsFeature>;\n\n/**\n * Enables binding information from the `Router` state directly to the inputs of the component in\n * `Route` configurations.\n *\n * @usageNotes\n *\n * Basic example of how you can enable the feature:\n * ```\n * const appRoutes: Routes = [];\n * bootstrapApplication(AppComponent,\n *   {\n *     providers: [\n *       provideRouter(appRoutes, withComponentInputBinding())\n *     ]\n *   }\n * );\n * ```\n *\n * @returns A set of providers for use with `provideRouter`.\n */\nexport function withComponentInputBinding(): ComponentInputBindingFeature {\n  const providers = [\n    RoutedComponentInputBinder,\n    {provide: INPUT_BINDER, useExisting: RoutedComponentInputBinder},\n  ];\n\n  return routerFeature(RouterFeatureKind.ComponentInputBindingFeature, providers);\n}\n\n/**\n * Enables view transitions in the Router by running the route activation and deactivation inside of\n * `document.startViewTransition`.\n *\n * Note: The View Transitions API is not available in all browsers. If the browser does not support\n * view transitions, the Router will not attempt to start a view transition and continue processing\n * the navigation as usual.\n *\n * @usageNotes\n *\n * Basic example of how you can enable the feature:\n * ```\n * const appRoutes: Routes = [];\n * bootstrapApplication(AppComponent,\n *   {\n *     providers: [\n *       provideRouter(appRoutes, withViewTransitions())\n *     ]\n *   }\n * );\n * ```\n *\n * @returns A set of providers for use with `provideRouter`.\n * @see https://developer.chrome.com/docs/web-platform/view-transitions/\n * @see https://developer.mozilla.org/en-US/docs/Web/API/View_Transitions_API\n * @experimental\n */\nexport function withViewTransitions(options?: ViewTransitionsFeatureOptions):\n    ViewTransitionsFeature {\n  const providers = [\n    {provide: CREATE_VIEW_TRANSITION, useValue: createViewTransition},\n    {\n      provide: VIEW_TRANSITION_OPTIONS,\n      useValue: {skipNextTransition: !!options?.skipInitialTransition, ...options}\n    },\n  ];\n  return routerFeature(RouterFeatureKind.ViewTransitionsFeature, providers);\n}\n\n/**\n * A type alias that represents all Router features available for use with `provideRouter`.\n * Features can be enabled by adding special functions to the `provideRouter` call.\n * See documentation for each symbol to find corresponding function name. See also `provideRouter`\n * documentation on how to use those functions.\n *\n * @see {@link provideRouter}\n *\n * @publicApi\n */\nexport type RouterFeatures = PreloadingFeature|DebugTracingFeature|InitialNavigationFeature|\n    InMemoryScrollingFeature|RouterConfigurationFeature|NavigationErrorHandlerFeature|\n    ComponentInputBindingFeature|ViewTransitionsFeature|RouterHashLocationFeature;\n\n/**\n * The list of features as an enum to uniquely type each feature.\n */\nexport const enum RouterFeatureKind {\n  PreloadingFeature,\n  DebugTracingFeature,\n  EnabledBlockingInitialNavigationFeature,\n  DisabledInitialNavigationFeature,\n  InMemoryScrollingFeature,\n  RouterConfigurationFeature,\n  RouterHashLocationFeature,\n  NavigationErrorHandlerFeature,\n  ComponentInputBindingFeature,\n  ViewTransitionsFeature,\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {HashLocationStrategy, Location, LocationStrategy, PathLocationStrategy, ViewportScroller} from '@angular/common';\nimport {APP_BOOTSTRAP_LISTENER, ComponentRef, inject, Inject, InjectionToken, ModuleWithProviders, NgModule, NgZone, Optional, Provider, SkipSelf, ɵRuntimeError as RuntimeError} from '@angular/core';\n\nimport {EmptyOutletComponent} from './components/empty_outlet';\nimport {RouterLink} from './directives/router_link';\nimport {RouterLinkActive} from './directives/router_link_active';\nimport {RouterOutlet} from './directives/router_outlet';\nimport {RuntimeErrorCode} from './errors';\nimport {Routes} from './models';\nimport {NavigationTransitions} from './navigation_transition';\nimport {getBootstrapListener, rootRoute, ROUTER_IS_PROVIDED, withComponentInputBinding, withDebugTracing, withDisabledInitialNavigation, withEnabledBlockingInitialNavigation, withPreloading, withViewTransitions} from './provide_router';\nimport {Router} from './router';\nimport {ExtraOptions, ROUTER_CONFIGURATION} from './router_config';\nimport {RouterConfigLoader, ROUTES} from './router_config_loader';\nimport {ChildrenOutletContexts} from './router_outlet_context';\nimport {ROUTER_SCROLLER, RouterScroller} from './router_scroller';\nimport {ActivatedRoute} from './router_state';\nimport {DefaultUrlSerializer, UrlSerializer} from './url_tree';\n\n\n/**\n * The directives defined in the `RouterModule`.\n */\nconst ROUTER_DIRECTIVES = [RouterOutlet, RouterLink, RouterLinkActive, EmptyOutletComponent];\n\n/**\n * @docsNotRequired\n */\nexport const ROUTER_FORROOT_GUARD = new InjectionToken<void>(\n    (typeof ngDevMode === 'undefined' || ngDevMode) ? 'router duplicate forRoot guard' :\n                                                      'ROUTER_FORROOT_GUARD');\n\n// TODO(atscott): All of these except `ActivatedRoute` are `providedIn: 'root'`. They are only kept\n// here to avoid a breaking change whereby the provider order matters based on where the\n// `RouterModule`/`RouterTestingModule` is imported. These can/should be removed as a \"breaking\"\n// change in a major version.\nexport const ROUTER_PROVIDERS: Provider[] = [\n  Location,\n  {provide: UrlSerializer, useClass: DefaultUrlSerializer},\n  Router,\n  ChildrenOutletContexts,\n  {provide: ActivatedRoute, useFactory: rootRoute, deps: [Router]},\n  RouterConfigLoader,\n  // Only used to warn when `provideRoutes` is used without `RouterModule` or `provideRouter`. Can\n  // be removed when `provideRoutes` is removed.\n  (typeof ngDevMode === 'undefined' || ngDevMode) ? {provide: ROUTER_IS_PROVIDED, useValue: true} :\n                                                    [],\n];\n\n/**\n * @description\n *\n * Adds directives and providers for in-app navigation among views defined in an application.\n * Use the Angular `Router` service to declaratively specify application states and manage state\n * transitions.\n *\n * You can import this NgModule multiple times, once for each lazy-loaded bundle.\n * However, only one `Router` service can be active.\n * To ensure this, there are two ways to register routes when importing this module:\n *\n * * The `forRoot()` method creates an `NgModule` that contains all the directives, the given\n * routes, and the `Router` service itself.\n * * The `forChild()` method creates an `NgModule` that contains all the directives and the given\n * routes, but does not include the `Router` service.\n *\n * @see [Routing and Navigation guide](guide/router) for an\n * overview of how the `Router` service should be used.\n *\n * @publicApi\n */\n@NgModule({\n  imports: ROUTER_DIRECTIVES,\n  exports: ROUTER_DIRECTIVES,\n})\nexport class RouterModule {\n  constructor(@Optional() @Inject(ROUTER_FORROOT_GUARD) guard: any) {}\n\n  /**\n   * Creates and configures a module with all the router providers and directives.\n   * Optionally sets up an application listener to perform an initial navigation.\n   *\n   * When registering the NgModule at the root, import as follows:\n   *\n   * ```\n   * @NgModule({\n   *   imports: [RouterModule.forRoot(ROUTES)]\n   * })\n   * class MyNgModule {}\n   * ```\n   *\n   * @param routes An array of `Route` objects that define the navigation paths for the application.\n   * @param config An `ExtraOptions` configuration object that controls how navigation is performed.\n   * @return The new `NgModule`.\n   *\n   */\n  static forRoot(routes: Routes, config?: ExtraOptions): ModuleWithProviders<RouterModule> {\n    return {\n      ngModule: RouterModule,\n      providers: [\n        ROUTER_PROVIDERS,\n        (typeof ngDevMode === 'undefined' || ngDevMode) ?\n            (config?.enableTracing ? withDebugTracing().ɵproviders : []) :\n            [],\n        {provide: ROUTES, multi: true, useValue: routes},\n        {\n          provide: ROUTER_FORROOT_GUARD,\n          useFactory: provideForRootGuard,\n          deps: [[Router, new Optional(), new SkipSelf()]]\n        },\n        {provide: ROUTER_CONFIGURATION, useValue: config ? config : {}},\n        config?.useHash ? provideHashLocationStrategy() : providePathLocationStrategy(),\n        provideRouterScroller(),\n        config?.preloadingStrategy ? withPreloading(config.preloadingStrategy).ɵproviders : [],\n        config?.initialNavigation ? provideInitialNavigation(config) : [],\n        config?.bindToComponentInputs ? withComponentInputBinding().ɵproviders : [],\n        config?.enableViewTransitions ? withViewTransitions().ɵproviders : [],\n        provideRouterInitializer(),\n      ],\n    };\n  }\n\n  /**\n   * Creates a module with all the router directives and a provider registering routes,\n   * without creating a new Router service.\n   * When registering for submodules and lazy-loaded submodules, create the NgModule as follows:\n   *\n   * ```\n   * @NgModule({\n   *   imports: [RouterModule.forChild(ROUTES)]\n   * })\n   * class MyNgModule {}\n   * ```\n   *\n   * @param routes An array of `Route` objects that define the navigation paths for the submodule.\n   * @return The new NgModule.\n   *\n   */\n  static forChild(routes: Routes): ModuleWithProviders<RouterModule> {\n    return {\n      ngModule: RouterModule,\n      providers: [{provide: ROUTES, multi: true, useValue: routes}],\n    };\n  }\n}\n\n/**\n * For internal use by `RouterModule` only. Note that this differs from `withInMemoryRouterScroller`\n * because it reads from the `ExtraOptions` which should not be used in the standalone world.\n */\nexport function provideRouterScroller(): Provider {\n  return {\n    provide: ROUTER_SCROLLER,\n    useFactory: () => {\n      const viewportScroller = inject(ViewportScroller);\n      const zone = inject(NgZone);\n      const config: ExtraOptions = inject(ROUTER_CONFIGURATION);\n      const transitions = inject(NavigationTransitions);\n      const urlSerializer = inject(UrlSerializer);\n      if (config.scrollOffset) {\n        viewportScroller.setOffset(config.scrollOffset);\n      }\n      return new RouterScroller(urlSerializer, transitions, viewportScroller, zone, config);\n    },\n  };\n}\n\n// Note: For internal use only with `RouterModule`. Standalone setup via `provideRouter` should\n// provide hash location directly via `{provide: LocationStrategy, useClass: HashLocationStrategy}`.\nfunction provideHashLocationStrategy(): Provider {\n  return {provide: LocationStrategy, useClass: HashLocationStrategy};\n}\n\n// Note: For internal use only with `RouterModule`. Standalone setup via `provideRouter` does not\n// need this at all because `PathLocationStrategy` is the default factory for `LocationStrategy`.\nfunction providePathLocationStrategy(): Provider {\n  return {provide: LocationStrategy, useClass: PathLocationStrategy};\n}\n\nexport function provideForRootGuard(router: Router): any {\n  if ((typeof ngDevMode === 'undefined' || ngDevMode) && router) {\n    throw new RuntimeError(\n        RuntimeErrorCode.FOR_ROOT_CALLED_TWICE,\n        `The Router was provided more than once. This can happen if 'forRoot' is used outside of the root injector.` +\n            ` Lazy loaded modules should use RouterModule.forChild() instead.`);\n  }\n  return 'guarded';\n}\n\n// Note: For internal use only with `RouterModule`. Standalone router setup with `provideRouter`\n// users call `withXInitialNavigation` directly.\nfunction provideInitialNavigation(config: Pick<ExtraOptions, 'initialNavigation'>): Provider[] {\n  return [\n    config.initialNavigation === 'disabled' ? withDisabledInitialNavigation().ɵproviders : [],\n    config.initialNavigation === 'enabledBlocking' ?\n        withEnabledBlockingInitialNavigation().ɵproviders :\n        [],\n  ];\n}\n\n// TODO(atscott): This should not be in the public API\n/**\n * A [DI token](guide/glossary/#di-token) for the router initializer that\n * is called after the app is bootstrapped.\n *\n * @publicApi\n */\nexport const ROUTER_INITIALIZER = new InjectionToken<(compRef: ComponentRef<any>) => void>(\n    (typeof ngDevMode === 'undefined' || ngDevMode) ? 'Router Initializer' : '');\n\nfunction provideRouterInitializer(): Provider[] {\n  return [\n    // ROUTER_INITIALIZER token should be removed. It's public API but shouldn't be. We can just\n    // have `getBootstrapListener` directly attached to APP_BOOTSTRAP_LISTENER.\n    {provide: ROUTER_INITIALIZER, useFactory: getBootstrapListener},\n    {provide: APP_BOOTSTRAP_LISTENER, multi: true, useExisting: ROUTER_INITIALIZER},\n  ];\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {inject, Type} from '@angular/core';\n\nimport {CanActivateChildFn, CanActivateFn, CanDeactivateFn, CanMatchFn, ResolveFn} from '../models';\n\n/**\n * Maps an array of injectable classes with canMatch functions to an array of equivalent\n * `CanMatchFn` for use in a `Route` definition.\n *\n * Usage {@example router/utils/functional_guards.ts region='CanActivate'}\n *\n * @publicApi\n * @see {@link Route}\n */\nexport function mapToCanMatch(providers: Array<Type<{canMatch: CanMatchFn}>>): CanMatchFn[] {\n  return providers.map(provider => (...params) => inject(provider).canMatch(...params));\n}\n\n/**\n * Maps an array of injectable classes with canActivate functions to an array of equivalent\n * `CanActivateFn` for use in a `Route` definition.\n *\n * Usage {@example router/utils/functional_guards.ts region='CanActivate'}\n *\n * @publicApi\n * @see {@link Route}\n */\nexport function mapToCanActivate(providers: Array<Type<{canActivate: CanActivateFn}>>):\n    CanActivateFn[] {\n  return providers.map(provider => (...params) => inject(provider).canActivate(...params));\n}\n/**\n * Maps an array of injectable classes with canActivateChild functions to an array of equivalent\n * `CanActivateChildFn` for use in a `Route` definition.\n *\n * Usage {@example router/utils/functional_guards.ts region='CanActivate'}\n *\n * @publicApi\n * @see {@link Route}\n */\nexport function mapToCanActivateChild(\n    providers: Array<Type<{canActivateChild: CanActivateChildFn}>>): CanActivateChildFn[] {\n  return providers.map(provider => (...params) => inject(provider).canActivateChild(...params));\n}\n/**\n * Maps an array of injectable classes with canDeactivate functions to an array of equivalent\n * `CanDeactivateFn` for use in a `Route` definition.\n *\n * Usage {@example router/utils/functional_guards.ts region='CanActivate'}\n *\n * @publicApi\n * @see {@link Route}\n */\nexport function mapToCanDeactivate<T = unknown>(\n    providers: Array<Type<{canDeactivate: CanDeactivateFn<T>}>>): CanDeactivateFn<T>[] {\n  return providers.map(provider => (...params) => inject(provider).canDeactivate(...params));\n}\n/**\n * Maps an injectable class with a resolve function to an equivalent `ResolveFn`\n * for use in a `Route` definition.\n *\n * Usage {@example router/utils/functional_guards.ts region='Resolve'}\n *\n * @publicApi\n * @see {@link Route}\n */\nexport function mapToResolve<T>(provider: Type<{resolve: ResolveFn<T>}>): ResolveFn<T> {\n  return (...params) => inject(provider).resolve(...params);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @module\n * @description\n * Entry point for all public APIs of the router package.\n */\n\nimport {Version} from '@angular/core';\n\n/**\n * @publicApi\n */\nexport const VERSION = new Version('17.0.3');\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @module\n * @description\n * Entry point for all public APIs of this package.\n */\nexport * from './src/index';\n\n// This file only reexports content of the `src` folder. Keep it that way.\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// This file is not used to build this module. It is only used during editing\n// by the TypeScript language service and during build for verification. `ngc`\n// replaces this file with production index.ts when it rewrites private symbol\n// names.\n\nexport * from './public_api';\n", "/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],
  "mappings": "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",
  "names": ["PRIMARY_OUTLET", "RouteTitleKey", "Symbol", "ParamsAsMap", "constructor", "params", "has", "name", "Object", "prototype", "hasOwnProperty", "call", "get", "v", "Array", "isArray", "getAll", "keys", "convertToParamMap", "defaultUrlMatcher", "segments", "segmentGroup", "route", "parts", "path", "split", "length", "pathMatch", "hasChildren", "posParams", "index", "part", "segment", "isParameter", "startsWith", "substring", "consumed", "slice", "shallowEqualArrays", "a", "b", "i", "shallowEqual", "k1", "getDataKeys", "undefined", "k2", "key", "equalArraysOrString", "obj", "getOwnPropertySymbols", "aSorted", "sort", "bSorted", "every", "val", "last", "wrapIntoObservable", "value", "isObservable", "ɵisPromise", "from", "Promise", "resolve", "of", "pathCompareMap", "equalSegmentGroups", "containsSegmentGroup", "paramCompareMap", "equalParams", "containsParams", "ignored", "containsTree", "container", "containee", "options", "paths", "root", "matrixParams", "queryParams", "fragment", "equalPath", "matrixParamsMatch", "numberOfChildren", "c", "children", "containsSegmentGroupHelper", "containeePaths", "current", "next", "containerPaths", "containeeSegment", "parameters", "UrlTree", "UrlSegmentGroup", "ngDevMode", "ɵRuntimeError", "queryParamMap", "_queryParamMap", "toString", "DEFAULT_SERIALIZER", "serialize", "parent", "values", "forEach", "serializePaths", "UrlSegment", "parameterMap", "_parameterMap", "serializePath", "equalSegments", "as", "bs", "mapChildrenIntoArray", "fn", "res", "entries", "childOutlet", "child", "concat", "UrlSerializer", "factory", "DefaultUrlSerializer", "providedIn", "Injectable", "args", "useFactory", "parse", "url", "p", "UrlParser", "parseRootSegment", "parseQueryParams", "parseFragment", "tree", "serializeSegment", "query", "serializeQueryParams", "encodeUriFragment", "map", "join", "primary", "k", "push", "encodeUriString", "s", "encodeURIComponent", "replace", "encodeUriQuery", "encodeURI", "encodeUriSegment", "decode", "decodeURIComponent", "decodeQuery", "serializeMatrixParams", "strParams", "filter", "SEGMENT_RE", "matchSegments", "str", "match", "MATRIX_PARAM_SEGMENT_RE", "matchMatrixKeySegments", "QUERY_PARAM_RE", "matchQueryParams", "QUERY_PARAM_VALUE_RE", "matchUrlQueryParamValue", "remaining", "consumeOptional", "peekStartsWith", "parseChildren", "parseQueryParam", "parseSegment", "capture", "parseParens", "parseMatrixParams", "parseParam", "valueMatch", "decodedKey", "decodedVal", "currentVal", "allowPrimary", "outletName", "indexOf", "createRoot", "rootCandidate", "squashSegmentGroup", "newChildren", "childCandidate", "grandChildOutlet", "grandChild", "mergeTrivialChildren", "isUrlTree", "createUrlTreeFromSnapshot", "relativeTo", "commands", "relativeToUrlSegmentGroup", "createSegmentGroupFromRoute", "createUrlTreeFromSegmentGroup", "targetGroup", "createSegmentGroupFromRouteRecursive", "currentRoute", "childOutlets", "childSnapshot", "outlet", "rootSegmentGroup", "nav", "computeNavigation", "toRoot", "position", "findStartingPositionForTargetGroup", "newSegmentGroup", "processChildren", "updateSegmentGroupChildren", "updateSegmentGroup", "isMatrixParams", "command", "outlets", "segmentPath", "isCommandWithOutlets", "oldRoot", "oldSegmentGroup", "qp", "replaceSegment", "newRoot", "oldSegment", "newSegment", "Navigation", "isAbsolute", "numberOfDoubleDots", "cmdWithOutlet", "find", "reduce", "cmd", "cmdIdx", "urlPart", "partIndex", "Position", "target", "NaN", "modifier", "createPositionApplyingDoubleDots", "group", "g", "ci", "dd", "getOutlets", "startIndex", "m", "prefixedWith", "slicedCommands", "commandIndex", "pathIndex", "createNewSegmentGroup", "some", "o", "childrenOfEmptyChild", "currentCommandIndex", "currentPathIndex", "noMatch", "curr", "compare", "createNewSegmentChildren", "stringify", "IMPERATIVE_NAVIGATION", "RouterEvent", "id", "NavigationStart", "navigationTrigger", "restoredState", "type", "NavigationEnd", "urlAfterRedirects", "NavigationCancel", "reason", "code", "NavigationSkipped", "NavigationError", "error", "RoutesRecognized", "state", "GuardsCheckStart", "GuardsCheckEnd", "shouldActivate", "ResolveStart", "ResolveEnd", "RouteConfigLoadStart", "RouteConfigLoadEnd", "ChildActivationStart", "snapshot", "routeConfig", "ChildActivationEnd", "ActivationStart", "ActivationEnd", "Scroll", "routerEvent", "anchor", "pos", "BeforeActivateRoutes", "RedirectRequest", "stringifyEvent", "OutletContext", "injector", "ChildrenOutletContexts", "attachRef", "contexts", "Map", "onChildOutletCreated", "childName", "context", "getOrCreateContext", "set", "onChildOutletDestroyed", "getContext", "onOutletDeactivated", "onOutletReAttached", "ɵprov", "ɵfac", "Tree", "_root", "t", "pathFromRoot", "n", "findNode", "firstChild", "siblings", "findPath", "cc", "node", "unshift", "TreeNode", "nodeChildrenAsMap", "RouterState", "setRouterState", "createEmptyState", "urlTree", "rootComponent", "createEmptyStateSnapshot", "emptyUrl", "BehaviorSubject", "emptyParams", "emptyData", "emptyQueryParams", "activated", "ActivatedRoute", "ActivatedRouteSnapshot", "RouterStateSnapshot", "urlSubject", "paramsSubject", "queryParamsSubject", "fragmentSubject", "dataSubject", "component", "futureSnapshot", "_futureSnapshot", "title", "pipe", "d", "data", "_routerState", "paramMap", "_paramMap", "getInherited", "paramsInheritanceStrategy", "inherited", "loadComponent", "_resolvedData", "hasStaticTitle", "_resolve", "matched", "serializeNode", "advanceActivatedRoute", "currentSnapshot", "nextSnapshot", "equalParamsAndUrlSegments", "equalUrlParams", "parentsMismatch", "config", "RouterOutlet", "_activatedRoute", "activateEvents", "EventEmitter", "deactivateEvents", "attachEvents", "detachEvents", "parentContexts", "inject", "location", "ViewContainerRef", "changeDetector", "ChangeDetectorRef", "environmentInjector", "EnvironmentInjector", "inputBinder", "INPUT_BINDER", "optional", "supportsBindingToComponentInputs", "activatedComponentRef", "ngOnChanges", "changes", "firstChange", "previousValue", "isTrackedInParentContexts", "deactivate", "initializeOutletWithName", "ngOnDestroy", "unsubscribeFromRouteData", "ngOnInit", "attach", "activateWith", "isActivated", "instance", "activatedRoute", "activatedRouteData", "detach", "cmp", "emit", "ref", "insert", "hostView", "bindActivatedRouteToOutletComponent", "destroy", "childContexts", "OutletInjector", "createComponent", "markForCheck", "selectors", "inputs", "outputs", "exportAs", "standalone", "features", "Directive", "selector", "Input", "Output", "token", "notFoundValue", "InjectionToken", "RoutedComponentInputBinder", "outletDataSubscriptions", "subscribeToRouteData", "unsubscribe", "delete", "dataSubscription", "combineLatest", "switchMap", "subscribe", "mirror", "reflectComponentType", "templateName", "setInput", "createRouterState", "routeReuseStrategy", "prevState", "createNode", "shouldReuseRoute", "createOrReuseChildren", "shouldAttach", "detachedRouteHandle", "retrieve", "createActivatedRoute", "NAVIGATION_CANCELING_ERROR", "redirectingNavigationError", "urlSerializer", "redirect", "redirectTo", "navigationBehaviorOptions", "navigationCancelingError", "message", "redirectUrl", "Error", "cancellationCode", "isRedirectingNavigationCancelingError$1", "isNavigationCancelingError$1", "ɵEmptyOutletComponent", "dependencies", "encapsulation", "Component", "template", "imports", "getOrCreateRouteInjectorIfNeeded", "currentInjector", "providers", "_injector", "createEnvironmentInjector", "validateConfig", "config", "parentPath", "requireStandaloneComponents", "i", "length", "route", "fullPath", "getFullPath", "validateNode", "assertStandalone", "component", "ɵisNgModule", "ɵRuntimeError", "isStandalone", "ngDevMode", "Array", "isArray", "redirectTo", "loadComponent", "children", "loadChildren", "outlet", "PRIMARY_OUTLET", "canActivate", "path", "matcher", "charAt", "pathMatch", "exp", "currentRoute", "standardizeConfig", "r", "map", "c", "ɵEmptyOutletComponent", "getOutlet", "sortByMatchingOutlets", "routes", "outletName", "sortedConfig", "filter", "push", "getClosestRouteInjector", "snapshot", "routeConfig", "_injector", "s", "parent", "_loadedInjector", "warnedAboutUnsupportedInputBinding", "activateRoutes", "rootContexts", "routeReuseStrategy", "forwardEvent", "inputBindingEnabled", "t", "ActivateRoutes", "targetRouterState", "currentRouterState", "activate", "constructor", "futureState", "currState", "parentContexts", "futureRoot", "_root", "currRoot", "deactivateChildRoutes", "advanceActivatedRoute", "root", "activateChildRoutes", "futureNode", "currNode", "contexts", "nodeChildrenAsMap", "forEach", "futureChild", "childOutletName", "value", "deactivateRoutes", "Object", "values", "v", "deactivateRouteAndItsChildren", "parentContext", "future", "curr", "context", "getContext", "shouldDetach", "detachAndStoreRouteSubtree", "deactivateRouteAndOutlet", "childOutlet", "keys", "componentRef", "detach", "onOutletDeactivated", "store", "deactivate", "attachRef", "ActivationEnd", "ChildActivationEnd", "getOrCreateContext", "shouldAttach", "stored", "retrieve", "onOutletReAttached", "attach", "injector", "activateWith", "supportsBindingToComponentInputs", "console", "warn", "CanActivate", "CanDeactivate", "getAllRouteGuards", "getChildRouteGuards", "getCanActivateChild", "p", "canActivateChild", "node", "guards", "getTokenOrFunctionIdentity", "tokenOrFunction", "NOT_FOUND", "Symbol", "result", "get", "ɵisInjectable", "futurePath", "checks", "canDeactivateChecks", "canActivateChecks", "prevChildren", "getRouteGuards", "concat", "entries", "k", "shouldRun", "shouldRunGuardsAndResolvers", "runGuardsAndResolvers", "data", "_resolvedData", "isActivated", "mode", "equalPath", "url", "shallowEqual", "queryParams", "equalParamsAndUrlSegments", "childName", "isFunction", "isBoolean", "isCanLoad", "guard", "canLoad", "isCanActivate", "isCanActivateChild", "isCanDeactivate", "canDeactivate", "isCanMatch", "canMatch", "isEmptyError", "e", "EmptyError", "name", "INITIAL_VALUE", "Symbol", "prioritizedGuardValue", "switchMap", "obs", "combineLatest", "map", "o", "pipe", "take", "startWith", "results", "result", "UrlTree", "filter", "item", "checkGuards", "injector", "forwardEvent", "mergeMap", "t", "targetSnapshot", "currentSnapshot", "guards", "canActivateChecks", "canDeactivateChecks", "length", "of", "guardsResult", "runCanDeactivateChecks", "canDeactivate", "isBoolean", "runCanActivateChecks", "checks", "futureRSS", "currRSS", "from", "check", "runCanDeactivate", "component", "route", "first", "futureSnapshot", "concatMap", "concat", "fireChildActivationStart", "parent", "fireActivationStart", "runCanActivateChild", "path", "runCanActivate", "snapshot", "ActivationStart", "ChildActivationStart", "futureARS", "canActivate", "routeConfig", "canActivateObservables", "defer", "closestInjector", "getClosestRouteInjector", "guard", "getTokenOrFunctionIdentity", "guardVal", "isCanActivate", "runInContext", "wrapIntoObservable", "canActivateChildGuards", "slice", "reverse", "p", "getCanActivateChild", "_", "canActivateChildGuardsMapped", "d", "guardsMapped", "canActivateChild", "node", "isCanActivateChild", "currARS", "canDeactivateObservables", "c", "isCanDeactivate", "runCanLoadGuards", "segments", "urlSerializer", "canLoad", "undefined", "canLoadObservables", "injectionToken", "isCanLoad", "redirectIfUrlTree", "tap", "isUrlTree", "redirectingNavigationError", "runCanMatchGuards", "canMatch", "canMatchObservables", "isCanMatch", "NoMatch", "constructor", "segmentGroup", "AbsoluteRedirect", "Error", "urlTree", "noMatch$1", "throwError", "namedOutletsRedirect", "redirectTo", "throwError", "ɵRuntimeError", "ngDevMode", "canLoadFails", "route", "navigationCancelingError", "path", "ApplyRedirects", "constructor", "urlSerializer", "urlTree", "noMatchError", "e", "segmentGroup", "lineralizeSegments", "res", "c", "root", "concat", "segments", "numberOfChildren", "of", "children", "PRIMARY_OUTLET", "applyRedirectCommands", "posParams", "newTree", "applyRedirectCreateUrlTree", "parse", "startsWith", "AbsoluteRedirect", "newRoot", "createSegmentGroup", "UrlTree", "createQueryParams", "queryParams", "fragment", "redirectToParams", "actualParams", "Object", "entries", "forEach", "k", "v", "copySourceValue", "sourceName", "substring", "group", "updatedSegments", "createSegments", "name", "child", "UrlSegmentGroup", "redirectToSegments", "actualSegments", "map", "s", "findPosParam", "findOrReturn", "redirectToUrlSegment", "pos", "idx", "splice", "noMatch", "matched", "consumedSegments", "remainingSegments", "parameters", "positionalParamSegments", "matchWithChecks", "injector", "result", "match", "getOrCreateRouteInjectorIfNeeded", "runCanMatchGuards", "pipe", "pathMatch", "hasChildren", "length", "matcher", "defaultUrlMatcher", "consumed", "slice", "split", "slicedSegments", "config", "containsEmptyPathMatchesWithNamedOutlets", "createChildrenForEmptyPaths", "containsEmptyPathMatches", "addEmptyPathsToChildrenIfNeeded", "routes", "r", "emptyPathMatch", "getOutlet", "primarySegment", "some", "isImmediateMatch", "rawSegment", "outlet", "noLeftoversInUrl", "NoLeftoversInUrl", "recognize$1", "configLoader", "rootComponentType", "paramsInheritanceStrategy", "Recognizer", "recognize", "MAX_ALLOWED_REDIRECTS", "applyRedirects", "absoluteRedirectCount", "allowRedirects", "rootSegmentGroup", "ActivatedRouteSnapshot", "freeze", "rootNode", "TreeNode", "routeState", "RouterStateSnapshot", "tree", "createUrlTreeFromSnapshot", "url", "serialize", "inheritParamsAndData", "_root", "state", "expanded$", "processSegmentGroup", "catchError", "NoMatch", "routeNode", "parent", "value", "i", "getInherited", "params", "data", "n", "processChildren", "processSegment", "childOutlets", "keys", "unshift", "push", "from", "concatMap", "childOutlet", "sortedConfig", "sortByMatchingOutlets", "scan", "outletChildren", "defaultIfEmpty", "last$1", "mergeMap", "noMatch$1", "mergedChildren", "mergeEmptyPathMatches", "checkOutletNameUniqueness", "sortActivatedRouteSnapshots", "processSegmentAgainstRoute", "_injector", "first", "x", "isEmptyError", "undefined", "matchSegmentAgainstRoute", "expandSegmentAgainstRouteUsingRedirect", "createWildcardMatchResult", "newSegments", "matchResult", "switchMap", "getChildConfig", "childConfig", "childInjector", "_loadedInjector", "snapshot", "getData", "component", "_loadedComponent", "getResolve", "matchedOnOutlet", "loadChildren", "_loadedRoutes", "runCanLoadGuards", "shouldLoadResult", "tap", "cfg", "nodes", "sort", "a", "b", "localeCompare", "hasEmptyPathConfig", "node", "routeConfig", "mergedNodes", "Set", "duplicateEmptyPathNode", "find", "resultNode", "add", "mergedNode", "filter", "has", "names", "routeWithSameOutletName", "p", "toString", "join", "resolve", "last", "serializer", "t", "extractedUrl", "targetSnapshot", "urlAfterRedirects", "resolveData", "guards", "canActivateChecks", "routesWithResolversToRun", "check", "routesWithResolversSet", "routesNeedingDataUpdates", "flattenRouteTree", "routesProcessed", "runResolve", "takeLast", "_", "EMPTY", "descendants", "flat", "futureARS", "futureRSS", "_resolve", "title", "hasStaticTitle", "RouteTitleKey", "resolveNode", "resolvedData", "_resolvedData", "getDataKeys", "key", "getResolver", "mapTo", "injectionToken", "closestInjector", "getClosestRouteInjector", "resolver", "getTokenOrFunctionIdentity", "resolverValue", "runInContext", "wrapIntoObservable", "switchTap", "next", "nextResult", "TitleStrategy", "buildTitle", "pageTitle", "getResolvedTitleForRoute", "factory", "inject", "DefaultTitleStrategy", "providedIn", "Injectable", "args", "useFactory", "updateTitle", "setTitle", "Title", "ɵprov", "ɵfac", "ROUTER_CONFIGURATION", "InjectionToken", "ROUTES", "RouterConfigLoader", "componentLoaders", "WeakMap", "childrenLoaders", "compiler", "Compiler", "loadComponent", "get", "onLoadStartListener", "loadRunner", "maybeUnwrapDefaultExport", "onLoadEndListener", "assertStandalone", "finalize", "delete", "loader", "ConnectableObservable", "Subject", "refCount", "set", "parentInjector", "moduleFactoryOrRoutes$", "NgModuleFactory", "Array", "isArray", "compileModuleAsync", "factoryOrRoutes", "rawRoutes", "requireStandaloneComponents", "create", "optional", "self", "standardizeConfig", "validateConfig", "isWrappedDefaultExport", "input", "UrlHandlingStrategy", "DefaultUrlHandlingStrategy", "shouldProcessUrl", "extract", "merge", "newUrlPart", "wholeUrl", "CREATE_VIEW_TRANSITION", "VIEW_TRANSITION_OPTIONS", "createViewTransition", "to", "transitionOptions", "document", "DOCUMENT", "NgZone", "runOutsideAngular", "startViewTransition", "skipNextTransition", "Promise", "resolveViewTransitionStarted", "viewTransitionStarted", "transition", "createRenderPromise", "onViewTransitionCreated", "runInInjectionContext", "afterNextRender", "NavigationTransitions", "hasRequestedNavigation", "navigationId", "currentNavigation", "currentTransition", "lastSuccessfulNavigation", "events", "transitionAbortSubject", "environmentInjector", "EnvironmentInjector", "UrlSerializer", "rootContexts", "ChildrenOutletContexts", "location", "Location", "inputBindingEnabled", "INPUT_BINDER", "titleStrategy", "options", "urlHandlingStrategy", "afterPreactivation", "onLoadStart", "RouteConfigLoadStart", "onLoadEnd", "RouteConfigLoadEnd", "complete", "transitions", "handleNavigationRequest", "request", "id", "setupNavigations", "router", "initialUrlTree", "initialRouterState", "BehaviorSubject", "currentUrlTree", "currentRawUrl", "rawUrl", "extras", "reject", "promise", "source", "IMPERATIVE_NAVIGATION", "restoredState", "currentSnapshot", "currentRouterState", "targetRouterState", "canDeactivateChecks", "guardsResult", "overallTransitionState", "completed", "errored", "initialUrl", "trigger", "previousNavigation", "urlTransition", "navigated", "isUpdatingInternalState", "isUpdatedBrowserUrl", "onSameUrlNavigation", "reason", "NavigationSkipped", "getValue", "NavigationStart", "finalUrl", "routesRecognized", "RoutesRecognized", "navStart", "createEmptyState", "skipLocationChange", "replaceUrl", "guardsStart", "GuardsCheckStart", "getAllRouteGuards", "checkGuards", "evt", "isUrlTree", "redirectingNavigationError", "guardsEnd", "GuardsCheckEnd", "cancelNavigationTransition", "resolveStart", "ResolveStart", "dataResolved", "resolveEnd", "ResolveEnd", "loadComponents", "loaders", "loadedComponent", "combineLatest", "take", "createRouterState", "routeReuseStrategy", "BeforeActivateRoutes", "activateRoutes", "NavigationEnd", "takeUntil", "err", "cancelationReason", "isNavigationCancelingError$1", "NavigationCancel", "message", "cancellationCode", "isRedirectingNavigationCancelingError$1", "RedirectRequest", "NavigationError", "errorHandler", "ee", "code", "navCancel", "extractedBrowserUrl", "isBrowserTriggeredNavigation", "RouteReuseStrategy", "DefaultRouteReuseStrategy", "BaseRouteReuseStrategy", "shouldDetach", "store", "detachedTree", "shouldAttach", "retrieve", "shouldReuseRoute", "future", "curr", "StateManager", "HistoryStateManager", "canceledNavigationResolution", "urlUpdateStrategy", "rawUrlTree", "currentPageId", "lastSuccessfulId", "routerState", "stateMemento", "createStateMemento", "getCurrentUrlTree", "getRawUrlTree", "getState", "browserPageId", "ɵrouterPageId", "getRouterState", "registerNonRouterCurrentEntryChangeListener", "listener", "subscribe", "event", "handleRouterEvent", "setBrowserUrl", "restoreHistory", "isCurrentPathEqualTo", "currentBrowserPageId", "generateNgRouterState", "replaceState", "go", "navigation", "restoringFromCaughtError", "targetPagePosition", "historyGo", "resetState", "resetUrlToCurrentUrlTree", "routerPageId", "NavigationResult", "afterNextNavigation", "action", "COMPLETE", "redirecting", "REDIRECTING", "FAILED", "defaultErrorHandler", "error", "exactMatchOptions", "paths", "matrixParams", "subsetMatchOptions", "Router", "stateManager", "_events", "disposed", "isNgZoneEnabled", "console", "ɵConsole", "pendingTasks", "ɵInitialRenderPendingTasks", "navigationTransitions", "componentInputBindingEnabled", "eventsSubscription", "Subscription", "isInAngularZone", "resetConfig", "warn", "subscribeToNavigationEvents", "subscription", "mergedTree", "scheduleNavigation", "isPublicRouterEvent", "resetRootComponentType", "initialNavigation", "setUpLocationChangeListener", "navigateToSyncWithBrowser", "nonRouterCurrentEntryChangeSubscription", "setTimeout", "stateCopy", "parseUrl", "serializeUrl", "getCurrentNavigation", "ngOnDestroy", "dispose", "unsubscribe", "createUrlTree", "commands", "navigationExtras", "relativeTo", "queryParamsHandling", "preserveFragment", "f", "q", "removeEmptyProps", "relativeToUrlSegmentGroup", "relativeToSnapshot", "createSegmentGroupFromRoute", "createUrlTreeFromSegmentGroup", "navigateByUrl", "navigate", "validateCommands", "isActive", "matchOptions", "containsTree", "reduce", "priorPromise", "rej", "taskId", "queueMicrotask", "remove", "catch", "cmd", "RouterLink", "tabIndexAttribute", "renderer", "el", "locationStrategy", "href", "onChanges", "tagName", "nativeElement", "toLowerCase", "isAnchorElement", "updateHref", "setTabIndexIfNotOnNativeEl", "newTabIndex", "applyAttributeValue", "ngOnChanges", "changes", "routerLink", "onClick", "button", "ctrlKey", "shiftKey", "altKey", "metaKey", "target", "prepareExternalUrl", "sanitizedValue", "ɵɵsanitizeUrlOrResourceUrl", "attrName", "attrValue", "setAttribute", "removeAttribute", "RouterLink_Factory", "ActivatedRoute", "Renderer2", "ElementRef", "LocationStrategy", "ɵdir", "selectors", "hostVars", "hostBindings", "RouterLink_HostBindings", "rf", "ctx", "$event", "booleanAttribute", "standalone", "features", "Directive", "selector", "Attribute", "HostBinding", "Input", "transform", "HostListener", "RouterLinkActive", "_isActive", "element", "cdr", "link", "classes", "routerLinkActiveOptions", "exact", "isActiveChange", "EventEmitter", "routerEventsSubscription", "update", "ngAfterContentInit", "links", "mergeAll", "subscribeToEachLinkOnChanges", "linkInputChangesSubscription", "allLinkChanges", "toArray", "isLinkActive", "routerLinkActive", "hasActiveLinks", "markForCheck", "addClass", "removeClass", "ariaCurrentWhenActive", "emit", "isActiveMatchOptions", "isActiveCheckFn", "ChangeDetectorRef", "contentQueries", "RouterLinkActive_ContentQueries", "dirIndex", "_t", "exportAs", "Optional", "ContentChildren", "Output", "PreloadingStrategy", "PreloadAllModules", "preload", "fn", "NoPreloading", "RouterPreloader", "preloadingStrategy", "setUpPreloading", "processRoutes", "providers", "createEnvironmentInjector", "injectorForCurrentRoute", "injectorForChildren", "canLoad", "preloadConfig", "loadedChildren$", "recursiveLoadChildren$", "loadComponent$", "ROUTER_SCROLLER", "RouterScroller", "viewportScroller", "zone", "lastId", "lastSource", "restoredId", "scrollPositionRestoration", "anchorScrolling", "init", "setHistoryScrollRestoration", "createScrollEvents", "scrollEventsSubscription", "consumeScrollEvents", "getScrollPosition", "navigationTrigger", "scheduleScrollEvent", "Scroll", "position", "scrollToPosition", "anchor", "scrollToAnchor", "routerEvent", "run", "provideRouter", "makeEnvironmentProviders", "provide", "multi", "useValue", "ROUTER_IS_PROVIDED", "rootRoute", "deps", "APP_BOOTSTRAP_LISTENER", "getBootstrapListener", "feature", "ɵproviders", "routerFeature", "kind", "ɵkind", "routerIsProvidedDevModeCheck", "ENVIRONMENT_INITIALIZER", "provideRoutes", "withInMemoryScrolling", "ViewportScroller", "Injector", "bootstrappedComponentRef", "ref", "ApplicationRef", "components", "bootstrapDone", "BOOTSTRAP_DONE", "INITIAL_NAVIGATION", "ROUTER_PRELOADER", "InjectFlags", "componentTypes", "closed", "withEnabledBlockingInitialNavigation", "APP_INITIALIZER", "locationInitialized", "LOCATION_INITIALIZED", "then", "withDisabledInitialNavigation", "withDebugTracing", "log", "stringifyEvent", "groupEnd", "withPreloading", "useExisting", "withRouterConfig", "withHashLocation", "useClass", "HashLocationStrategy", "withNavigationErrorHandler", "withComponentInputBinding", "RoutedComponentInputBinder", "withViewTransitions", "skipInitialTransition", "ROUTER_DIRECTIVES", "RouterOutlet", "ɵEmptyOutletComponent", "ROUTER_FORROOT_GUARD", "ROUTER_PROVIDERS", "DefaultUrlSerializer", "RouterModule", "guard", "forRoot", "ngModule", "enableTracing", "provideForRootGuard", "SkipSelf", "useHash", "provideHashLocationStrategy", "providePathLocationStrategy", "provideRouterScroller", "provideInitialNavigation", "bindToComponentInputs", "enableViewTransitions", "provideRouterInitializer", "forChild", "RouterModule_Factory", "ɵmod", "imports", "exports", "NgModule", "Inject", "scrollOffset", "setOffset", "PathLocationStrategy", "ROUTER_INITIALIZER", "mapToCanMatch", "provider", "canMatch", "mapToCanActivate", "canActivate", "mapToCanActivateChild", "canActivateChild", "mapToCanDeactivate", "canDeactivate", "mapToResolve", "VERSION", "Version"]
}
